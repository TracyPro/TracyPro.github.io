<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>卡巴斯基：APT组织2019行为大盘点（上）</title>
      <link href="/article/%E5%8D%A1%E5%B7%B4%E6%96%AF%E5%9F%BA%EF%BC%9AAPT%E7%BB%84%E7%BB%872019%E8%A1%8C%E4%B8%BA%E5%A4%A7%E7%9B%98%E7%82%B9%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/article/%E5%8D%A1%E5%B7%B4%E6%96%AF%E5%9F%BA%EF%BC%9AAPT%E7%BB%84%E7%BB%872019%E8%A1%8C%E4%B8%BA%E5%A4%A7%E7%9B%98%E7%82%B9%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在即将过去的2019年，APT组织又做了哪些恶？它们的发展动向是什么？我们又能从其中挖掘出怎样的规律？这些问题想要直白回答并不容易，因为研究人员不可能完全了解所有攻击事件及它们背后的发展动机，但我们可以试着从不同的角度来处理这个问题，以便更好地理解所发生的事情，并从中获得后见之明。</p></blockquote><h3 id="供应链攻击">供应链攻击</h3><p>近年来，供应链攻击是最危险和有效的感染途径之一，越来越多地被用于高级攻击行动中——其中最知名的要当属ShadowPad后门、勒索软件ExPetr和被后门化的工具CCleaner。这种攻击针对了产品生命周期中，从初始开发阶段到最终用户的各个环节，涉及人力、组织、物资和智力资源的种种。哪怕供应商的基础设施是安全的，但其提供商的设施中可能包含漏洞，从而危害到供应链，导致毁灭性和意外的数据泄露事故。</p><p>今年1月，我们就发现过一起名为ShadowHammer 行动的供应链攻击事件。攻击者以华硕的实时更新应用程序为感染初始源进行攻击。这种实时更新应用程序是一种预装应用，用于自动进行BIOS、UEFI驱动和应用程序更新。攻击者使用窃取到的华硕数字证书对旧版本的华硕软件进行更改，注入自己的恶意代码，包含木马的华硕应用程序使用了合法的数字签名，并且被放到官方的华硕更新服务器上进行传播和下载，使得大多数安全解决方案无法将其识别。据估计，有 50 万用户通过华硕的自动更新收到了恶意后门，但攻击者只对其中 600 台计算机发动了针对性的后续攻击。</p><h3 id="apt组织信息反泄露">APT组织信息反泄露</h3><p>今年3月，有人在Twitter上泄露了隶属于伊朗国家背景的APT攻击组织APT34（又名oilrig、HelixKitten）的黑客工具及相关人员信息。安全专家证实泄露信息确实跟APT 34组织有关。公布的信息还包括66个APT34组织受害者，主要是中东地区的政府机构和金融、能源等企业，与之前所掌握关于APT 34组织的情况相符。</p><p>4月22日，另一针对中东国家地区的APT组织MuddyWater信息又遭曝光，一个名为Bl4ck_B0X的用户在Telegram频道上公布了MuddyWater组织成员信息，甚至具体到成员的父母和配偶，4月27日还曝光了 其C2服务器的相关信息，但到了5月1日，该频道对公众关闭，状态改为私人，关闭的原因尚不清楚。</p><p>之后Hidden Reality网站上又曝光了伊朗RANA研究所数据，这次攻击者选择了任何人都能浏览的网站，披露了RANA机构计算机网络运营相关的内部文档、聊天记录，以及受害者信息等。此前揭秘的信息更多会集中在工具、源代码和配置文件上。</p><p>第三季度，中东地区的APT事态发展值得关注，尤其是伊朗短时间内又发生了多起数据泄密事件。</p><p>在对泄漏者所使用的材料，基础设施和专用网站的仔细分析后，我们推测上述这些事件可能都与Sofacy / Hades组织有关。</p><h3 id="新组织现身">新组织现身</h3><p>2017年，神秘黑客团体Shadow Brokers泄露了一个名为“ Lost in Translation ”的数据库，据称是从美国国家安全局（NSA）处入侵获得，包含一系列漏洞利用和黑客工具，比如大名鼎鼎的永恒之蓝漏洞和WannaCry勒索病毒。</p><p>但重点是，泄露的文件中还有一个名为sigs.py的Python脚本文件，该文件被NSA用作内置的恶意软件扫描程序，可以检查系统是否已被另一个APT组织破坏，即他国网军的攻击痕迹，从而通过是否存在攻击痕迹而执行下一步操作。文件执行的每次检查都是作为在系统中查找唯一签名的函数实现的，例如唯一名称或注册表路径的文件。sigs.py中列出了44个条目，也就是NSA能识别的44个APT组织，其中许多APT组织都尚未曝光于公众面前。</p><p>而今年，我们确定了sigs.py文件中标注的第27个APT组织——DarkUniverse。根据代码相关性，我们认为 DarkUniverse 就是操纵ItaDuke 恶意行动的幕后黑手，此次行动针对西亚和非洲东北部的医疗机构、核能机构、军事组织和电信公司进行，共有20多个单位受到影响。他们使用的主要组件是一个相当简单的 DLL，仅具有一个导出的功能，却能实现了持久性、恶意软件完整性、C2 通信以及对其他模块的控制。</p><h3 id="移动攻击">移动攻击</h3><p>移动攻击现在几乎成了每个APT组织的标配了，2019年有许多这样的案例发生。</p><p>今年5月，英国《金融时报》报道称，黑客利用了WhatsApp的一个0 day漏洞，能读取用户的加密聊天记录、开启麦克风和摄像头、安装间谍软件等，而利用漏洞的过程只需要攻击者通过WhatsApp给用户打电话即可，通过呼叫触发WhatsApp的缓冲区溢出，进而让攻击者控制应用程序并在其中执行任意代码。WhatsApp很快就发布了一个漏洞补丁。10月，WhatsApp对以色列NSO集团提起诉讼，指控后者对这一漏洞的开发利用行为，并声称NSO将此技术用于20个不同国家的1400多名客户身上，其中包括人权活动人士、记者及其他相关人士，但诉讼遭到了NSO的否决。</p><p>7月，我们介绍了在野发现的最新版FinSpy间谍软件。FinSpy是由德国Gamma Group公司制造的间谍软件，通过其在英国的子公司Gamma Group International向全球的政府和执法机构出售，被用于在各类平台上收集用户的私人信息。FinSpy有iOS和Android两个版本，出现在近20个国家。</p><p>8月，谷歌的Project Zero团队发表报告分析了至少14个在野发现的iOS 0 day漏洞，这些漏洞被用在5个开发链中，影响从 iOS 10 到 iOS 12 的几乎每一个版本。14个漏洞中有 7 个面向 iPhone 的 Web 浏览器、五个面向内核、两个瞄向单独的沙箱转义。据谷歌报道，攻击者可能从三年前就开始对一些网站发起水坑攻击，但谷歌没有列举被入侵网站的详细信息，只声称这些网站“每周都有成千上万的访问者”，是一种没有针对性的攻击。</p><p>9月，“网络军火商”Zerodium公司表示，Android的0 day现在要比iOS的价值高，公司愿意为零点击的Android 0 day支付250万美元的费用，相比该公司之前为远程iOS越狱支付的200万美元的上限有了大幅提高。同一月份，Android媒体驱动程序v412 (Video4Linux) driver被曝出高危0 day漏洞，同时又曝出另一Android漏洞，攻击者可以使用SMS消息完全访问受感染设备上的电子邮件，这一漏洞使超过10亿的三星、华为、LG、索尼等智能手机受到影响。</p><h3 id="apt组织的发展动向">APT组织的发展动向</h3><h4 id="turla">Turla</h4><p>今年在调查中亚的一些恶意活动时，我们确定了一个名为Tunnus的新后门，并将其归于Turla APT组织。Tunnus是基于.NET的恶意软件，能够在受感染的系统上运行命令或执行文件操作并将结果发送到C2。</p><p>Turla还创建了一个名为Topinambour的新dropper，用于分发其臭名昭著的恶意软件JavaScript KopiLuwak。恶意软件几乎完全是“无文件的”：只有在感染的最后阶段，将一个用于远程管理的加密木马嵌入计算机的注册表中。Turla组织还用两个跟KopiLuwak类似的恶意软件进行网络间谍活动——.NET RocketMan木马和PowerShell MiamiBeach木马。</p><p>Turla的另一款新工具Reductor是COMPfun木马的继承者，攻击者入侵Chrome和Firefox浏览器后可以利用TLS追踪用户。Reductor一个引人注目的方面是，攻击者花了很多精力来操纵已安装的数字根证书，并使用惟一的与主机相关的标识符标记出站TLS流量。该恶意软件将嵌入式根证书添加到目标主机，允许操作员通过命名管道远程添加其他证书。攻击者不需要接触网络数据包，相反，他们分析了Firefox源代码和Chrome二进制代码，修改了其中的PRNG代码，并针对每个用户添加唯一的标识符，从而使TLS流量带有唯一的指纹，导致黑客能够轻易在网络上追踪来自受感染主机的加密流量。</p><h4 id="sofacy">Sofacy</h4><p>Zebrocy是我们于2015年底发现的一款归属于Sofacy组织的恶意软件家族，由Delphi下载器、AutoIt下载器和Delphi后门组成，主要针对欧亚地区进行间谍活动。今年Zebrocy再次升级，在6月份对东南亚某一外交事务机构的攻击中使用了一个新Python脚本——PythocyDbg，此脚本主要提供网络代理和通信调试功能的秘密收集。</p><p>早在2019年初，Zebrocy就改变了开发方向，使用了Nimrod/Nim语言，这是一种语法类似于Pascal和Python的编程语言，可以把目标程序编译为JavaScript 或 C 语言。该组织用于鱼叉式网络钓鱼的Nim下载程序和其他Nim后门代码目前都由Zebrocy生成，并与AutoIT脚本、Go和Delphi模块一起交付。</p><p>今年9月，Zebrocy在欧洲多地发起攻击，试图获取电子邮件通信、凭据和敏感文件，此次行动主要针对的是各国的国防和外交机构。</p><h4 id="platinum">Platinum</h4><p>6月，我们发现一系列高度复杂的网络间谍攻击行动，其目的是窃取南亚的外交、政府和军事实体的信息。这些攻击行动持续了近六年，对其中使用的工具手段进一步调查后发现，背后的攻击者为PLATIUM组织——一个我们认为已经消失的网络间谍组织。能在如此长的时间里保持行动隐蔽，是因为Platinum使用了一种前所未见的隐写技术。</p><p>而今年年末，我们又发现了Platinum的一个新后门——Titanium，该恶意软件与一个称为ProjectC的工具集之间存在某些相似性，说明之前利用ProjectC进行的CloudComputating行动也可以归因于Platinum。</p><h4 id="lazarus">Lazarus</h4><p>去年，Lazarus组织利用AppleJeus恶意软件对Mac OS用户展开加密货币窃取行动，今年又使用自定义PowerShell脚本来管理和控制Windows/macOS 恶意软件，进一步拓展了加密攻击。</p><p>Lazarus更新工具的速度很快，除了加密攻击外，还窃取了韩国某游戏公司的程序源码售卖。到了三季度，又入侵了缅甸一家银行，通过公共登录凭据转储程序和自制的PowerShell脚本进行横向移动来获取高价值主机信息。</p><p>Lazarus旗下有两个子组织，分别名为BlueNoroff和Andariel，后者专注于韩国的地缘政治和金融情报的间谍活动。今年，Andariel为易受攻击的weblogic服务器构建新的c2基础设施，攻击者成功后会植入了由韩国安全软件供应商合法签名的恶意软件。由于韩国方面的快速反应，这个签名很快就被撤销了。恶意软件是一种全新的后门，名为Apollozeus，它是由一个具有复杂配置的shellcode启动的。这个后门使用了一个相对较大的shellcode，以使分析变得困难。此外，它还会谨慎地执行最终的有效负载。这个恶意软件的发现让我们找到了几个相关的样本，以及攻击者用来传播它的文档。</p><h4 id="darkhotel">DarkHotel</h4><p>10月，我们发现了一起面向朝鲜的钓鱼攻击事件，主要针对商人，外交实体和人权组织，攻击者使用了高针对性的Ghost RAT恶意软件，可完全控制受害者电脑。据推测，这场行动已经进行了三年多。</p><h4 id="lamberts">Lamberts</h4><p>Lamberts是一个或多个威胁组织都在使用的工具集，它包括网络驱动的后门、几代模块化后门、信息收集工具以及用于实施破坏性攻击的擦除器。有关Lamberts的更多信息，请参见我们之前“拆解Lamberts工具包”的报告。</p><p>今年，Lamberts军火库中又添加了几类新武器。Silver Lambert似乎是Gray Lambert的继任者，它是一个成熟的后门，能实现一些特定的NOBUS和OPSEC概念，例如通过检查服务器SSL证书哈希来防止C2 sink-holing ，为孤立实例自动卸载（即C2不可用的地方）和低级文件擦除功能。中国航空部门就受到过Silver Lambert的影响。</p><p>Violet Lambert是一种模块化后门，应该是在2018年开发部署的，能在各种Windows版本（包括Windows XP，Vista和更高版本的Windows）上运行，我们在中东地区观察到了它的存在痕迹，同时还发现了另外三种后门——前两个称为Cyan Lambert（包括Light和Pro版本），第三个称为Magenta Lambert，后者重用了较早的Lamberts代码，并且与Green、Black和White Lamberts具有多个相似之处。此类恶意软件能进行网络侦听，等待魔术ping，以及能非常隐蔽地执行payload，而我们一直无法对其进行解密。就在我们发现后不久，所有受感染的电脑都离线了。</p><h4 id="luckymouse">LuckyMouse</h4><p>LuckyMouse组织至少自2018年4月以来便一直针对越南政府和外交实体展开“SpoiledLegacy”攻击行动，此次行动被怀疑是是之前IronTiger行动的继承。攻击者使用Cobalt Strike和Metasploit渗透测试框架，主要以网络服务的漏洞为初始感染媒介，此外也通过钓鱼邮件进行感染。除了渗透测试框架外，攻击者还使用NetBot下载器和内网穿透大杀器——EarthWorm，以及将HTran TCP代理源代码包含到恶意软件中来重定向流量。一些NetBot配置数据包含LAN IP，表明它从本地网络中另一台受感染的主机下载下一阶段文件。</p><p>LuckyMouse此次的目标依然是内部数据库服务器。感染的最后阶段，攻击者针对32位和64位系统，分别使用特制的注入系统进程内存的木马。值得强调的是，感染链中的所有工具，都使用了泄漏的HackingTeam代码，动态混淆Win32 API调用。</p><p>从2019年初开始，我们在中亚和中东观察到LuckyMouse活动的激增。攻击者似乎将重点放在电信运营商、大学和政府上。感染媒介是鱼叉式网络钓鱼以及可能的水坑攻击。尽管去年有很多文章都讨论了LuckyMouse的TTP，但LuckyMouse并没有对其进行任何更改，仍然依靠自己的工具在受害者的网络中站稳脚跟。在新活动中，他们使用HTTPBrowser作为第一阶段，用Soldier Trojan作为第二阶段。LuckyMouse更改了其基础设施，因为它似乎只依赖于IPv4地址，而不是C2的域名，我们认为这是为了限制相关性。</p><h4 id="honeymyte">HoneyMyte</h4><p>HoneyMyte APT已经活跃好几年了，在过去的几年中采用了多种技术，对缅甸、蒙古、埃塞俄比亚、越南和孟加拉国的政府，以及位于巴基斯坦、韩国、美国、英国、比利时、尼泊尔、澳大利亚和新加坡的外国大使馆发起攻击。今年将目标对准了缅甸自然资源管理相关的政府组织和一个非洲大陆组织，表明HoneyMyte的主要动机之一是收集地缘政治和经济情报。</p><h4 id="icefog">Icefog</h4><p>自2011年以来，Icefog一直针对主要位于韩国，日本和亚洲中部的政府机构、军事承包商、航运组织、电信运营商、卫星运营商、工业和高科技公司和大众媒体。在2013年该组织被曝光后，运作速度有所放慢，然而2018年后，Icefog又开始对中亚的政府机构和军事承包商发起了大规模进攻。</p><p>在最新一波攻击中，感染始于包含了恶意文件的鱼叉式网络钓鱼电子邮件，利用已知漏洞并最终部署了payload。在2018年到2019年初，最终的payload都是典型的Icefog后门，但自2019年5月以后，攻击者似乎改变了立场，转向使用Poison Ivy后门。Poison Ivy是一类恶意DLL文件，使用了一种称为加载顺序劫持（load order hijacking）的技术，通过合法签名的程序进行加载。这种技术非常普遍，在以前的Icefog活动中也使用过。</p><p>在调查过程中，我们还检测到横向运动中使用的工具，我们观察了从GitHub下载的公共TCP扫描器、从系统内存转储凭证的Mimikatz变体、用于窃取敏感信息的自定义键盘记录程序，以及另一个名为Quarian的新版本后门的使用。Quarian后门被用来在受害者的基础设施内创建隧道以避免网络探测。Quarian的功能包括操作远程文件系统、获取受害者信息、窃取保存的密码、下载或上传任意文件、使用端口转发创建隧道、执行任意命令和启动反向shell。</p><blockquote><p>注：本文翻译自：<a href="https://securelist.com/ksb-2019-review-of-the-year/95394/" target="_blank" rel="noopener">https://securelist.com/ksb-2019-review-of-the-year/95394/</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> APT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>麦迪35秒狂得13分，从此麦迪时刻诞生！</title>
      <link href="/article/%E9%BA%A6%E8%BF%AA35%E7%A7%92%E7%8B%82%E5%BE%9713%E5%88%86%EF%BC%8C%E4%BB%8E%E6%AD%A4%E9%BA%A6%E8%BF%AA%E6%97%B6%E5%88%BB%E8%AF%9E%E7%94%9F%EF%BC%81/"/>
      <url>/article/%E9%BA%A6%E8%BF%AA35%E7%A7%92%E7%8B%82%E5%BE%9713%E5%88%86%EF%BC%8C%E4%BB%8E%E6%AD%A4%E9%BA%A6%E8%BF%AA%E6%97%B6%E5%88%BB%E8%AF%9E%E7%94%9F%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>2004年12月9日（北京时间2004年12月10日），在休斯顿丰田中心球场，惊现不可思议的大逆转，麦迪竟然在35秒内得到13分！全场1.6万名休斯顿球迷有幸见证了火箭主场逆转马刺，麦迪在比赛最后时刻，分别在35秒时一个三分，24.3秒时一个三加一（三分加一个罚球)，11.2秒时一个三分，及最后1.7秒时一个三分绝杀，火箭神奇般的以81-80，1分优势战胜马刺。</p><p>麦迪时刻经典回顾：</p><div id="dplayer4" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer4"),"theme":"#FADFA3","loop":true,"video":{"url":"http://vd3.bdstatic.com/mda-jm88gt29524hts9r/mda-jm88gt29524hts9r.mp4","pic":"https://up.enterdesk.com/edpic_source/b7/9d/b4/b79db48553bb073b60d2ba9593da7750.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>从此，“麦迪时刻”（T-Mac’s time）诞生，麦迪被称为是感动上帝的男人。此次比赛也永远载入NBA史册。<br><img src="./img_1.jpg" alt=""></p><h3 id="麦迪时刻详细经过">麦迪时刻详细经过</h3><p>1、终场52秒，麦迪突破上篮不中，姚明抢到篮板直接空中补扣中的，拉开了火箭队反击的序幕。(74-66)</p><p>2、帕吉特断下帕克给邓肯的传球，扣篮得手。(74-68)</p><p>3、马刺暂停，后麦迪犯规由布朗两罚全中；麦迪开始了他的表演，麦迪时刻降临，他全场运球后镇定自若的投中了他匪夷所思的第一记三分球！(76-71)</p><p>4、苏拉犯规，布朗继续两罚全中；麦迪运球至前场，利用姚明的挡拆绕过鲍文，再假动作骗起邓肯，顺势投篮，球不可思议地再次命中3分，并加罚命中！(78-75)</p><p>5、帕吉特向邓肯犯规，后者也两罚全中。火箭暂停后，麦迪困难的接到巴蒂尔的传球，运球至三分线外面对紧逼的鲍文再次飚中三分！(80-78)</p><p>6、马刺暂停，布朗接球后运球，并于底线附近姚明面前卧倒，麦迪迅速拣下球，持球狂奔，在终场前一秒外线再次三分命中！进球后的麦迪挥拳怒吼！ (80-81)<br><img src="./img_3.jpg" alt=""></p><p>7、尾声：托尼·帕克飞奔前场一记不着边际的大号三分，功臣麦迪被众人压在身下。</p><p>8、德文·布朗神情发呆，就是因为他最后的运球失误，成就了伟大的麦迪时刻！</p><p>9、观众吼叫…</p><h3 id="赛后言论">赛后言论</h3><p>波波维奇：“你眼睁睁地看着他把刀子捅进你心窝，可你根本对此无能为力。”</p><p>麦迪：“提前退场的观众，你们错过了一场伟大的比赛。”</p><p>火箭后卫苏拉：“我们得以第一手地感受到他之所以是这个世界上最伟大球员之一的原因，他竟然将我们从那样的绝境中拉了出来，真是神奇，令人难以置信。”</p><p>火箭队首发位置的鲍恩也表示：“太狂野了，看着麦迪那样将球送进篮圈真是奇妙的感觉，他投中了一两个后我们开始想‘我们是否能将比分追近点？’也许当时每个人都是那样想的：‘至少我们能让比赛看上去不那么难看。’但麦迪有不同的想法，他想为我们赢得胜利，这真是神奇。”</p><p>波波维奇恼羞成怒地回答道：“我怎么知道为什么会这样?!麦迪的手太烫了，他是个出色的家伙，想让比赛结局变成这样，他们必须做到很多事才行(他们竟然做到了)。我们最后时刻有许多糟糕的表现，但麦迪的表现也确实伟大。”</p><p>麦迪赛后回忆道：“老兄，老实说我以前还真的没试过这种事，我当时怎么想的？我想的是‘别放弃，我只需要把球投出去，当他们开球的时候争取把球断下来。如果断不下再用犯规战术让他们上。“</p><h3 id="麦迪赛后采访">麦迪赛后采访</h3><p>采访：T-Mac，多么艰难，你逆转了比赛，你得到了13分，在刚刚过去的45秒内，当时是怎么回事？</p><p>麦迪：这很难做到，一切皆有可能，我们一直坚信，就是像这样，我们就是这样试着去创造奇迹，在最后我们来回4个回合，我不知道我是怎么面对对方防守队员运球穿插其间，你知道，我的意志很坚定，就像龙卷风一样席卷赛场。</p><p>采访：你们在最后1分钟内做了2次战术犯规，当你面对邓肯打了4分时，你是否觉得，我们可以赢下这场比赛？”</p><p>麦迪：这就是我们的关键，当我打了4分时，信心又来了，然后队友通过一切机会在狭小的空间把球传给我，我就准备好了向前冲。</p><p>采访：但是你们仍然落后很多，他们拿有球权，他们最后底线发球，你是怎么拿到球的，你怎么想？</p><p>麦迪：嗯，我们利用他们的分心，他们仍拿着球，但他滑倒了，球向我滚来，我当时唯一做的就是拿起球，我不想打成平局，所以我仍然持球过来，投出了三分球，球就进了，你要原谅我不知所云，我也是碰到第一次这样的情况。</p><p>采访：可以去看回放，但这就是你为什么是NBA的得分王。</p><p>麦迪：我很感激我们做到了。</p><h3 id="特雷西麦克格雷迪简介">特雷西·麦克格雷迪简介</h3><p><img src="./img_4.jpg" alt=""><br>在1997年NBA选秀大会中，麦迪以高中生球员的身份，在第1轮第9顺位被多伦多猛龙队选中。职业生涯曾先后效力于多伦多猛龙队、奥兰多魔术队、休斯敦火箭队、纽约尼克斯队、底特律活塞队、亚特兰大老鹰队、CBA青岛双星队及圣安东尼奥马刺队。在16年的职业生涯中，麦克格雷迪2次荣膺NBA得分王，7次入选NBA全明星阵容，2次入选NBA最佳阵容一阵，3次入选NBA最佳阵容二阵，2次入选NBA最佳阵容三阵，2001年荣获NBA进步最快球员奖。</p><p>2013年8月26日，麦克格雷迪正式宣布退役。2017年4月2日，麦克格雷迪正式入选2017年奈·史密斯篮球名人纪念堂 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> NBA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>何为文件包含漏洞？</title>
      <link href="/article/%E4%BD%95%E4%B8%BA%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%9F/"/>
      <url>/article/%E4%BD%95%E4%B8%BA%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文件包含，原本是将重复使用的函数写入单个文件中，供程序员自已或协同开发者调用，无需重复编写，增加程序的灵活性，提高开发效率。</p></blockquote><h3 id="前言">前言</h3><p>方便与安全永远是一把“双刃剑”，提供方便的同时，也为攻击者打开方便之门。攻击者利用文件包含漏洞，调用构造的恶意文件，达到攻击目的。</p><p>文件包含漏洞主要出现在脚本语言中，如jsp、asp、php等，但漏洞数量居多的是php web应用。</p><p>根据调用文件的位置，分为本地文件包含（LFI）和远程文件包含（RFI）。</p><blockquote><p>下面将介绍，促成该漏洞达到攻击目的几种途径。</p></blockquote><h3 id="上传兄伸出援手">“上传”兄伸出援手</h3><p>web应用存在文件包含漏洞，还存在上传、注入漏洞，利用后者，将够早的文件上传至服务器，利用前者进行调用，完成攻击。</p><h3 id="记录类文件的助力">记录类文件的助力</h3><p>1、包含access.log文件。Apache运行时，会生成两个文件：access.log（访问记录日志）和error.log（错误日志），前端访问URL中，我们可以写入php脚本，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.com/&lt;?php.phpinfo();?&gt;</span><br></pre></td></tr></table></figure><p>访问会报错，同时会将php内容写入到访问记录日志中，此时我们在前端再包含访问记录日志，就可以看到脚本被解析的结果了。</p><p>该方法利用难点：</p><ul><li>攻击者需要知道访问记录日志的存储路径。</li><li>脚本符号转义。“&lt;”和“&gt;”在URL访问时，可能会被后台转码。</li></ul><p>2、CVE-2018-12613。这个漏洞是在phpMyAdmin 4.8.0-4.8.1中存在，利用session文件记录，实现文件包含。请看示例：</p><p>写入语句，登录phpMyAdmin后，在sql一栏中写入下面语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">"&lt;?php phpinfo();?&gt;"</span></span><br></pre></td></tr></table></figure><p>执行效果如下图所示：<br><img src="./img_1.png" alt=""></p><p>取得session值。</p><p>访问session文件。在index.php后构造以下访问链接：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?target=db_sql.php%253f../../../../../../../../var/lib/php/sessions/sess_******</span><br></pre></td></tr></table></figure><p>其中“sess_”后面内容就是此次访问的session值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言常见数据结构实现原理之map</title>
      <link href="/article/Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Bmap/"/>
      <url>/article/Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Bmap/</url>
      
        <content type="html"><![CDATA[<h3 id="map数据结构">map数据结构</h3><p>Golang的map使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。</p><p>map数据结构由<code>runtime/map.go/hmap</code>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="keyword">int</span> <span class="comment">// 当前保存的元素个数</span></span><br><span class="line">    ...</span><br><span class="line">    B         <span class="keyword">uint8</span>  <span class="comment">// 指示bucket数组的大小</span></span><br><span class="line">    ...</span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// bucket数组指针，数组的大小为2^B</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示一个拥有4个bucket的map：</p><p><img src="img_1.png" alt=""></p><p>本例中, <code>hmap.B=2</code>， 而hmap.buckets长度是2^B为4. 元素经过哈希运算后会落到某个bucket中进行存储。查找过程类似。</p><p><code>bucket</code>很多时候被翻译为桶，所谓的<code>哈希桶</code>实际上就是bucket。</p><h3 id="bucket数据结构">bucket数据结构</h3><p>bucket数据结构由<code>runtime/map.go/bmap</code>定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [<span class="number">8</span>]<span class="keyword">uint8</span> <span class="comment">//存储哈希值的高8位</span></span><br><span class="line">    data    <span class="keyword">byte</span>[<span class="number">1</span>]  <span class="comment">//key value数据:key/key/key/.../value/value/value...</span></span><br><span class="line">    overflow *bmap   <span class="comment">//溢出bucket的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个bucket可以存储8个键值对。</p><ul><li>tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。</li><li>data区存放的是key-value数据，存放顺序是key/key/key/…value/value/value，如此存放是为了节省字节对齐带来的空间浪费。</li><li>overflow 指针指向的是下一个bucket，据此将所有冲突的键连接起来。</li></ul><p>注意：上述中data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。</p><p>下图展示bucket存放8个key-value对：</p><p><img src="img_2.png" alt=""></p><h3 id="哈希冲突">哈希冲突</h3><p>当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。<br>由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。</p><p>下图展示产生冲突后的map：</p><p><img src="img_3.png" alt=""></p><p>bucket数据结构指示下一个bucket的指针称为overflow bucket，意为当前bucket盛不下而溢出的部分。事实上哈希冲突并不是好事情，它降低了存取效率，好的哈希算法可以保证哈希值的随机性，但冲突过多也是要控制的，后面会再详细介绍。</p><h3 id="负载因子">负载因子</h3><p>负载因子用于衡量一个哈希表冲突情况，公式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负载因子 = 键数量/bucket数量</span><br></pre></td></tr></table></figure><p>例如，对于一个bucket数量为4，包含4个键值对的哈希表来说，这个哈希表的负载因子为1.</p><p>哈希表需要将负载因子控制在合适的大小，超过其阀值需要进行rehash，也即键值对重新组织：</p><ul><li>哈希因子过小，说明空间利用率低</li><li>哈希因子过大，说明冲突严重，存取效率低</li></ul><p>每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子。</p><h3 id="渐进式扩容">渐进式扩容</h3><h4 id="扩容的前提条件">扩容的前提条件</h4><p>为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。<br>触发扩容的条件有二个：</p><ol><li>负载因子 &gt; 6.5时，也即平均每个bucket存储的键值对达到6.5个。</li><li>overflow数量 &gt; 2^15时，也即overflow数量超过32768时。</li></ol><h4 id="增量扩容">增量扩容</h4><p>当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。<br>考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。</p><p>下图展示了包含一个bucket满载的map(为了描述方便，图中bucket省略了value区域):</p><p><img src="img_4.png" alt=""></p><p>当前map存储了7个键值对，只有1个bucket。此地负载因子为7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的bucket。</p><p>当第8个键值对插入时，将会触发扩容，扩容后示意图如下：</p><p><img src="img_5.png" alt=""></p><p>hmap数据结构中oldbuckets成员指身原bucket，而buckets指向了新申请的bucket。新的键值对被插入新的bucket中。<br>后续对map的访问操作会触发迁移，将oldbuckets中的键值对逐步的搬迁过来。当oldbuckets中的键值对全部搬迁完毕后，删除oldbuckets。</p><p>搬迁完成后的示意图如下：</p><p><img src="img_6.png" alt=""></p><p>数据搬迁过程中原bucket中的键值对将存在于新bucket的前面，新插入的键值对将存在于新bucket的后面。<br>实际搬迁过程中比较复杂，将在后续源码分析中详细介绍。</p><h4 id="等量扩容">等量扩容</h4><p>所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。<br>在极端场景下，比如不断的增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，如下图所示：</p><p><img src="img_7.png" alt=""></p><p>上图可见，overflow的buckt中大部分是空的，访问效率会很差。此时进行一次等量扩容，即buckets数量不变，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。</p><h3 id="查找过程">查找过程</h3><p>查找过程如下：</p><ol><li>跟据key值算出哈希值</li><li>取哈希值低位与hmpa.B取模确定bucket位置</li><li>取哈希值高位在tophash数组中查询</li><li>如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较</li><li>当前bucket没有找到，则继续从下个overflow的bucket中查找。</li><li>如果当前处于搬迁过程，则优先从oldbuckets查找</li></ol><p>注：如果查找不到，也不会返回空值，而是返回相应类型的0值。</p><h3 id="插入过程">插入过程</h3><p>新员素插入过程如下：</p><ol><li>跟据key值算出哈希值</li><li>取哈希值低位与hmap.B取模确定bucket位置</li><li>查找该key是否已经存在，如果存在则直接更新值</li><li>如果没找到将key，将key插入</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言常见数据结构实现原理之slice</title>
      <link href="/article/Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Bslice/"/>
      <url>/article/Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Bslice/</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>Slice又称动态数组，依托数组实现，可以方便的进行扩容、传递等，实际使用中比数组更灵活。</p><p>正因为灵活，如果不了解其内部实现机制，有可能遭遇莫名的异常现象。Slice的实现原理很简单，本节试图根据真实的使用场景，在源码中总结实现原理。</p><h3 id="热身环节">热身环节</h3><p>按照惯例，我们开始前先看几段代码用于检测对Slice的理解程度。</p><h4 id="题目一">题目一</h4><p>下面程序输出什么？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> array [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> slice = array[<span class="number">5</span>:<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"lenth of slice: "</span>, <span class="built_in">len</span>(slice))</span><br><span class="line">    fmt.Println(<span class="string">"capacity of slice: "</span>, <span class="built_in">cap</span>(slice))</span><br><span class="line">    fmt.Println(&amp;slice[<span class="number">0</span>] == &amp;array[<span class="number">5</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序解释： main函数中定义了一个10个长度的整型数组array，然后定义了一个切片slice，切取数组的第6个元素，最后打印slice的长度和容量，判断切片的第一个元素和数组的第6个元素地址是否相等。</p><p>参考答案： slice跟据数组array创建，与数组共享存储空间，slice起始位置是array[5]，长度为1，容量为5，slice[0]和array[5]地址相同。</p><h4 id="题目二">题目二</h4><p>下面程序输出什么？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddElement</span><span class="params">(slice []<span class="keyword">int</span>, e <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(slice, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> slice []<span class="keyword">int</span></span><br><span class="line">    slice = <span class="built_in">append</span>(slice, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    newSlice := AddElement(slice, <span class="number">4</span>)</span><br><span class="line">    fmt.Println(&amp;slice[<span class="number">0</span>] == &amp;newSlice[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序解释： 函数AddElement()接受一个切片和一个元素，把元素append进切片中，并返回切片。main()函数中定义一个切片，并向切片中append 3个元素，接着调用AddElement()继续向切片append进第4个元素同时定义一个新的切片newSlice。最后判断新切片newSlice与旧切片slice是否共用一块存储空间。</p><p>参考答案： append函数执行时会判断切片容量是否能够存放新增元素，如果不能，则会重新申请存储空间，新存储空间将是原来的2倍或1.25倍（取决于扩展原空间大小），本例中实际执行了两次append操作，第一次空间增长到4，所以第二次append不会再扩容，所以新旧两个切片将共用一块存储空间。程序会输出&quot;true&quot;。</p><h4 id="题目三">题目三</h4><p>下面程序由Golang源码改编而来，程序输出什么？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    orderLen := <span class="number">5</span></span><br><span class="line">    order := <span class="built_in">make</span>([]<span class="keyword">uint16</span>, <span class="number">2</span> * orderLen)</span><br><span class="line"></span><br><span class="line">    pollorder := order[:orderLen:orderLen]</span><br><span class="line">    lockorder := order[orderLen:][:orderLen:orderLen]</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"len(pollorder) = "</span>, <span class="built_in">len</span>(pollorder))</span><br><span class="line">    fmt.Println(<span class="string">"cap(pollorder) = "</span>, <span class="built_in">cap</span>(pollorder))</span><br><span class="line">    fmt.Println(<span class="string">"len(lockorder) = "</span>, <span class="built_in">len</span>(lockorder))</span><br><span class="line">    fmt.Println(<span class="string">"cap(lockorder) = "</span>, <span class="built_in">cap</span>(lockorder))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序解释： 该段程序源自select的实现代码，程序中定义一个长度为10的切片order，pollorder和lockorder分别是对order切片做了order[low:high:max]操作生成的切片，最后程序分别打印pollorder和lockorder的容量和长度。</p><p>参考答案： order[low:high:max]操作意思是对order进行切片，新切片范围是[low, high),新切片容量是max。order长度为2倍的orderLen，pollorder切片指的是order的前半部分切片，lockorder指的是order的后半部分切片，即原order分成了两段。所以，pollorder和lockerorder的长度和容量都是orderLen，即5。</p><h3 id="slice实现原理">Slice实现原理</h3><p>Slice依托数组实现，底层数组对用户屏蔽，在底层数组容量不足时可以实现自动重分配并生成新的Slice。 接下来按照实际使用场景分别介绍其实现机制。</p><h4 id="slice数据结构">Slice数据结构</h4><p>源码包中<font color="#dd0000"><strong>src/runtime/slice.go:slice</strong></font>定义了Slice的数据结构：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数据结构看Slice很清晰, array指针指向底层数组，len表示切片长度，cap表示底层数组容量。</p><h4 id="使用make创建slice">使用make创建Slice</h4><p>使用make来创建Slice时，可以同时指定长度和容量，创建时底层会分配一个数组，数组的长度即容量。</p><p>例如，语句<font color="#dd0000"><strong>slice := make([]int, 5, 10)</strong></font>所创建的Slice，结构如下图所示：<br><img src="./img_1.png" alt=""><br>该Slice长度为5，即可以使用下标slice[0] ~ slice[4]来操作里面的元素，capacity为10，表示后续向slice添加新的元素时可以不必重新分配内存，直接使用预留内存即可。</p><h4 id="使用数组创建slice">使用数组创建Slice</h4><p>使用数组来创建Slice时，Slice将与原数组共用一部分内存。</p><p>例如，语句<font color="#dd0000"><strong>slice := array[5:7]</strong></font>所创建的Slice，结构如下图所示：<br><img src="./img_2.png" alt=""><br>切片从数组array[5]开始，到数组array[7]结束（不含array[7]），即切片长度为2，数组后面的内容都作为切片的预留内存，即capacity为5。</p><p>数组和切片操作可能作用于同一块内存，这也是使用过程中需要注意的地方。</p><h4 id="slice-扩容">Slice 扩容</h4><p>使用append向Slice追加元素时，如果Slice空间不足，将会触发Slice扩容，扩容实际上重新一配一块更大的内存，将原Slice数据拷贝进新Slice，然后返回新Slice，扩容后再将数据追加进去。</p><p>例如，当向一个capacity为5，且length也为5的Slice再次追加1个元素时，就会发生扩容，如下图所示：<br><img src="./img_3.png" alt=""><br>扩容操作只关心容量，会把原Slice数据拷贝到新Slice，追加数据由append在扩容结束后完成。上图可见，扩容后新的Slice长度仍然是5，但容量由5提升到了10，原Slice的数据也都拷贝到了新Slice指向的数组中。</p><p>扩容容量的选择遵循以下规则：</p><ul><li>如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍；</li><li>如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍；</li></ul><p>使用append()向Slice添加一个元素的实现步骤如下： 1. 假如Slice容量够用，则将新元素追加进去，Slice.len++，返回原Slice 2. 原Slice容量不够，则将Slice先扩容，扩容后得到新Slice 3. 将新元素追加进新Slice，Slice.len++，返回新的Slice。</p><h4 id="slice-copy">Slice Copy</h4><p>使用copy()内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片长度的最小值。</p><p>例如长度为10的切片拷贝到长度为5的切片时，将会拷贝5个元素。</p><p>也就是说，copy过程中不会发生扩容。</p><h4 id="特殊切片">特殊切片</h4><p>跟据数组或切片生成新的切片一般使用<font color="#dd0000"><strong>slice := array[start:end]</strong></font>方式，这种新生成的切片并没有指定切片的容量，实际上新切片的容量是从start开始直至array的结束。</p><p>比如下面两个切片，长度和容量都是一致的，使用共同的内存地址：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sliceA := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">sliceB := sliceA[<span class="number">0</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>根据数组或切片生成切片还有另一种写法，即切片同时也指定容量，即slice[start:end:cap], 其中cap即为新切片的容量，当然容量不能超过原切片实际值，如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sliceA := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)  <span class="comment">//length = 5; capacity = 10</span></span><br><span class="line">sliceB := sliceA[<span class="number">0</span>:<span class="number">5</span>]         <span class="comment">//length = 5; capacity = 10</span></span><br><span class="line">sliceC := sliceA[<span class="number">0</span>:<span class="number">5</span>:<span class="number">5</span>]       <span class="comment">//length = 5; capacity = 5</span></span><br></pre></td></tr></table></figure><p>这切片方法不常见，在Golang源码里能够见到，不过非常利于切片的理解。</p><h3 id="编程tips">编程Tips</h3><ul><li>创建切片时可跟据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能；</li><li>切片拷贝时需要判断实际拷贝的元素个数</li><li>谨慎使用多个切片操作同一个数组，以防读写冲突</li></ul><h3 id="slice总结">Slice总结</h3><ul><li>每个切片都指向一个底层数组</li><li>每个切片都保存了当前切片的长度、底层数组可用容量</li><li>使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片</li><li>使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片</li><li>通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而矣</li><li>使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑客常用端口利用总结</title>
      <link href="/article/%E9%BB%91%E5%AE%A2%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/article/%E9%BB%91%E5%AE%A2%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="常见端口对应服务和被入侵方式">常见端口对应服务和被入侵方式</h3><table><thead><tr><th style="text-align:center"><font color="#006600">端口</font></th><th style="text-align:center"><font color="#006600">服务</font></th><th style="text-align:center"><font color="#006600">入侵方式</font></th></tr></thead><tbody><tr><td style="text-align:center">21</td><td style="text-align:center">ftp/tftp/vsftpd文件传输协议</td><td style="text-align:center">爆破/嗅探/溢出/后门</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">ssh远程连接</td><td style="text-align:center">爆破/openssh漏洞</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">Telnet远程连接</td><td style="text-align:center">爆破/嗅探/弱口令</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">SMTP邮件服务</td><td style="text-align:center">邮件伪造</td></tr><tr><td style="text-align:center">53</td><td style="text-align:center">DNS域名解析系统</td><td style="text-align:center">域传送/劫持/缓存投毒/欺骗</td></tr><tr><td style="text-align:center">67/68</td><td style="text-align:center">dhcp服务</td><td style="text-align:center">劫持/欺骗</td></tr><tr><td style="text-align:center">110</td><td style="text-align:center">pop3</td><td style="text-align:center">爆破/嗅探</td></tr><tr><td style="text-align:center">139</td><td style="text-align:center">Samba服务</td><td style="text-align:center">爆破/未授权访问/远程命令执行</td></tr><tr><td style="text-align:center">143</td><td style="text-align:center">Imap协议</td><td style="text-align:center">爆破</td></tr><tr><td style="text-align:center">161</td><td style="text-align:center">SNMP协议</td><td style="text-align:center">爆破/搜集目标内网信息</td></tr><tr><td style="text-align:center">389</td><td style="text-align:center">Ldap目录访问协议</td><td style="text-align:center">注入/未授权访问/弱口令</td></tr><tr><td style="text-align:center">445</td><td style="text-align:center">smb</td><td style="text-align:center">ms17-010/端口溢出</td></tr><tr><td style="text-align:center">512/513/514</td><td style="text-align:center">Linux Rexec服务</td><td style="text-align:center">爆破/Rlogin登陆</td></tr><tr><td style="text-align:center">873</td><td style="text-align:center">Rsync服务</td><td style="text-align:center">文件上传/未授权访问</td></tr><tr><td style="text-align:center">1080</td><td style="text-align:center">socket</td><td style="text-align:center">爆破</td></tr><tr><td style="text-align:center">1352</td><td style="text-align:center">Lotus domino邮件服务</td><td style="text-align:center">爆破/信息泄漏</td></tr><tr><td style="text-align:center">1433</td><td style="text-align:center">mssql</td><td style="text-align:center">爆破/注入/SA弱口令</td></tr><tr><td style="text-align:center">1521</td><td style="text-align:center">oracle</td><td style="text-align:center">爆破/注入/TNS爆破/反弹shell</td></tr><tr><td style="text-align:center">2049</td><td style="text-align:center">Nfs服务</td><td style="text-align:center">配置不当</td></tr><tr><td style="text-align:center">2181</td><td style="text-align:center">zookeeper服务</td><td style="text-align:center">未授权访问</td></tr><tr><td style="text-align:center">2375</td><td style="text-align:center">docker remote api</td><td style="text-align:center">未授权访问</td></tr><tr><td style="text-align:center">3306</td><td style="text-align:center">mysql</td><td style="text-align:center">爆破/注入</td></tr><tr><td style="text-align:center">3389</td><td style="text-align:center">Rdp远程桌面链接</td><td style="text-align:center">爆破/shift后门</td></tr><tr><td style="text-align:center">4848</td><td style="text-align:center">GlassFish控制台</td><td style="text-align:center">爆破/认证绕过</td></tr><tr><td style="text-align:center">5000</td><td style="text-align:center">sybase/DB2数据库</td><td style="text-align:center">爆破/注入/提权</td></tr><tr><td style="text-align:center">5432</td><td style="text-align:center">postgresql</td><td style="text-align:center">爆破/注入/缓冲区溢出</td></tr><tr><td style="text-align:center">5632</td><td style="text-align:center">pcanywhere服务</td><td style="text-align:center">抓密码/代码执行</td></tr><tr><td style="text-align:center">5900</td><td style="text-align:center">vnc</td><td style="text-align:center">爆破/认证绕过</td></tr><tr><td style="text-align:center">6379</td><td style="text-align:center">Redis数据库</td><td style="text-align:center">未授权访问/爆破</td></tr><tr><td style="text-align:center">7001/7002</td><td style="text-align:center">weblogic</td><td style="text-align:center">java反序列化/控制台弱口令</td></tr><tr><td style="text-align:center">80/443</td><td style="text-align:center">http/https</td><td style="text-align:center">web应用漏洞/心脏滴血</td></tr><tr><td style="text-align:center">8069</td><td style="text-align:center">zabbix服务</td><td style="text-align:center">远程命令执行/注入</td></tr><tr><td style="text-align:center">8161</td><td style="text-align:center">activemq</td><td style="text-align:center">弱口令/写文件</td></tr><tr><td style="text-align:center">8080/8089</td><td style="text-align:center">Jboss/Tomcat/Resin</td><td style="text-align:center">爆破/PUT文件上传/反序列化</td></tr><tr><td style="text-align:center">8083/8086</td><td style="text-align:center">influxDB</td><td style="text-align:center">未授权访问</td></tr><tr><td style="text-align:center">9000</td><td style="text-align:center">fastcgi</td><td style="text-align:center">远程命令执行</td></tr><tr><td style="text-align:center">9090</td><td style="text-align:center">Websphere控制台</td><td style="text-align:center">爆破/java反序列化/弱口令</td></tr><tr><td style="text-align:center">9200/9300</td><td style="text-align:center"></td><td style="text-align:center">elasticsearch</td></tr><tr><td style="text-align:center">11211</td><td style="text-align:center">memcached</td><td style="text-align:center">未授权访问</td></tr><tr><td style="text-align:center">27017/27018</td><td style="text-align:center">mongodb</td><td style="text-align:center">未授权访问/爆破</td></tr></tbody></table><h3 id="21端口渗透剖析">21端口渗透剖析</h3><p>FTP通常用作对远程服务器进行管理，典型应用就是对web系统进行管理。一旦FTP密码泄露就直接威胁web系统安全，甚至黑客通过提权可以直接控制服务器。这里剖析渗透FTP服务器的几种方法。</p><ul><li>基础爆破：ftp爆破工具很多，这里我推owasp的Bruter,hydra以及msf中的ftp爆破模块。</li><li>ftp匿名访问：用户名：anonymous 密码：为空或者任意邮箱</li><li>后门vsftpd ：version 2到2.3.4存在后门漏洞，攻击者可以通过该漏洞获取root权限。（<a href="https://www.freebuf.com/column/143480.html%EF%BC%89" target="_blank" rel="noopener">https://www.freebuf.com/column/143480.html）</a></li><li>嗅探：ftp使用明文传输技术（但是嗅探给予局域网并需要欺骗或监听网关）,使用Cain进行渗透。</li><li>ftp远程代码溢出。</li><li>ftp跳转攻击。</li></ul><h3 id="22端口渗透剖析">22端口渗透剖析</h3><p>SSH 是协议，通常使用 OpenSSH 软件实现协议应用。SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定；SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其它网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。</p><ul><li>弱口令，可使用工具hydra，msf中的ssh爆破模块。</li><li>防火墙SSH后门。</li><li>28退格 OpenSSL</li><li>openssh 用户枚举 CVE-2018-15473。（<a href="https://www.anquanke.com/post/id/157607%EF%BC%89" target="_blank" rel="noopener">https://www.anquanke.com/post/id/157607）</a></li></ul><h3 id="23端口渗透剖析">23端口渗透剖析</h3><p>telnet是一种旧的远程管理方式，使用telnet工具登录系统过程中，网络上传输的用户和密码都是以明文方式传送的，黑客可使用嗅探技术截获到此类密码。</p><ul><li>暴力破解技术是常用的技术，使用hydra,或者msf中telnet模块对其进行破解。</li><li>在linux系统中一般采用SSH进行远程访问，传输的敏感数据都是经过加密的。而对于windows下的telnet来说是脆弱的，因为默认没有经过任何加密就在网络中进行传输。使用cain等嗅探工具可轻松截获远程登录密码。</li></ul><h3 id="25465端口渗透剖析">25/465端口渗透剖析</h3><p>smtp：邮件协议，在linux中默认开启这个服务，可以向对方发送钓鱼邮件</p><blockquote><p>默认端口：25（smtp）、465（smtps）</p></blockquote><ul><li>爆破：弱口令</li><li>未授权访问</li></ul><h3 id="53端口渗透剖析">53端口渗透剖析</h3><p>53端口是DNS域名服务器的通信端口，通常用于域名解析。也是网络中非常关键的服务器之一。这类服务器容易受到攻击。对于此端口的渗透，一般有三种方式。</p><ul><li>使用DNS远程溢出漏洞直接对其主机进行溢出攻击，成功后可直接获得系统权限。</li><li>使用DNS欺骗攻击，可对DNS域名服务器进行欺骗，如果黑客再配合网页木马进行挂马攻击，无疑是一种杀伤力很强的攻击，黑客可不费吹灰之力就控制内网的大部分主机。这也是内网渗透惯用的技法之一。</li><li>拒绝服务攻击，利用拒绝服务攻击可快速的导致目标服务器运行缓慢，甚至网络瘫痪。如果使用拒绝服务攻击其DNS服务器。将导致用该服务器进行域名解析的用户无法正常上网。</li><li>DNS劫持。</li></ul><h3 id="80端口渗透剖析">80端口渗透剖析</h3><p>80端口通常提供web服务。目前黑客对80端口的攻击典型是采用SQL注入的攻击方法，脚本渗透技术也是一项综合性极高的web渗透技术，同时脚本渗透技术对80端口也构成严重的威胁。</p><ul><li>对于windows2000的IIS5.0版本，黑客使用远程溢出直接对远程主机进行溢出攻击，成功后直接获得系统权限。</li><li>对于windows2000中IIS5.0版本，黑客也尝试利用‘Microsoft IISCGI’文件名错误解码漏洞攻击。使用X-SCAN可直接探测到IIS漏洞。</li><li>IIS写权限漏洞是由于IIS配置不当造成的安全问题，攻击者可向存在此类漏洞的服务器上传恶意代码，比如上传脚本木马扩大控制权限。</li><li>普通的http封包是没有经过加密就在网络中传输的，这样就可通过嗅探类工具截取到敏感的数据。如使用Cain工具完成此类渗透。</li><li>80端口的攻击，更多的是采用脚本渗透技术，利用web应用程序的漏洞进行渗透是目前很流行的攻击方式。</li><li>对于渗透只开放80端口的服务器来说，难度很大。利用端口复用工具可解决此类技术难题。</li><li>CC攻击效果不及DDOS效果明显，但是对于攻击一些小型web站点还是比较有用的。CC攻击可使目标站点运行缓慢，页面无法打开，有时还会爆出web程序的绝对路径。</li></ul><h3 id="135端口渗透剖析">135端口渗透剖析</h3><p>135端口主要用于使用RPC协议并提供DCOM服务，通过RPC可以保证在一台计算机上运行的程序可以顺利地执行远程计算机上的代码；使用DCOM可以通过网络直接进行通信，能够跨包括HTTP协议在内的多种网络传输。同时这个端口也爆出过不少漏洞，最严重的就是缓冲区溢出漏洞，曾经疯狂一时的‘冲击波’病毒就是利用这个漏洞进行传播的。对于135端口的渗透，黑客的渗透方法为:</p><ul><li>查找存在RPC溢出的主机，进行远程溢出攻击，直接获得系统权限。如用‘DSScan’扫描存在此漏洞的主机。对存在漏洞的主机可使用‘ms05011.exe’进行溢出，溢出成功后获得系统权限。（<a href="https://wenku.baidu.com/view/68b3340c79563c1ec5da710a.html%EF%BC%89" target="_blank" rel="noopener">https://wenku.baidu.com/view/68b3340c79563c1ec5da710a.html）</a></li><li>扫描存在弱口令的135主机，利用RPC远程过程调用开启telnet服务并登录telnet执行系统命令。系统弱口令的扫描一般使用hydra。对于telnet服务的开启可使用工具kali链接。（<a href="https://wenku.baidu.com/view/c8b96ae2700abb68a982fbdf.html%EF%BC%89" target="_blank" rel="noopener">https://wenku.baidu.com/view/c8b96ae2700abb68a982fbdf.html）</a></li></ul><h3 id="139445端口渗透剖析">139/445端口渗透剖析</h3><p>139端口是为‘NetBIOS SessionService’提供的，主要用于提供windows文件和打印机共享以及UNIX中的Samba服务。445端口也用于提供windows文件和打印机共享，在内网环境中使用的很广泛。这两个端口同样属于重点攻击对象，139/445端口曾出现过许多严重级别的漏洞。下面剖析渗透此类端口的基本思路。</p><ul><li>对于开放139/445端口的主机，一般尝试利用溢出漏洞对远程主机进行溢出攻击，成功后直接获得系统权限。利用msf的ms-017永恒之蓝。</li><li>对于攻击只开放445端口的主机，黑客一般使用工具‘MS06040’或‘MS08067’.可使用专用的445端口扫描器进行扫描。NS08067溢出工具对windows2003系统的溢出十分有效，工具基本使用参数在cmd下会有提示。</li><li>对于开放139/445端口的主机，黑客一般使用IPC$进行渗透。在没有使用特点的账户和密码进行空连接时，权限是最小的。获得系统特定账户和密码成为提升权限的关键了，比如获得administrator账户的口令。</li><li>对于开放139/445端口的主机，可利用共享获取敏感信息，这也是内网渗透中收集信息的基本途径。</li></ul><h3 id="1433端口渗透剖析">1433端口渗透剖析</h3><p>1433是SQLServer默认的端口，SQL Server服务使用两个端口：tcp-1433、UDP-1434.其中1433用于供SQLServer对外提供服务，1434用于向请求者返回SQLServer使用了哪些TCP/IP端口。1433端口通常遭到黑客的攻击，而且攻击的方式层出不穷。最严重的莫过于远程溢出漏洞了，如由于SQL注射攻击的兴起，各类数据库时刻面临着安全威胁。利用SQL注射技术对数据库进行渗透是目前比较流行的攻击方式，此类技术属于脚本渗透技术。</p><ul><li>对于开放1433端口的SQL Server2000的数据库服务器，黑客尝试使用远程溢出漏洞对主机进行溢出测试，成功后直接获得系统权限。</li><li>暴力破解技术是一项经典的技术。一般破解的对象都是SA用户。通过字典破解的方式很快破解出SA的密码。</li><li>嗅探技术同样能嗅探到SQL Server的登录密码。</li><li>由于脚本程序编写的不严密，例如，程序员对参数过滤不严等，这都会造成严重的注射漏洞。通过SQL注射可间接性的对数据库服务器进行渗透，通过调用一些存储过程执行系统命令。可以使用SQL综合利用工具完成。</li></ul><h3 id="1521端口渗透剖析">1521端口渗透剖析</h3><p>1521是大型数据库Oracle的默认监听端口，估计新手还对此端口比较陌生，平时大家接触的比较多的是Access，MSSQL以及MYSQL这三种数据库。一般大型站点才会部署这种比较昂贵的数据库系统。对于渗透这种比较复杂的数据库系统，黑客的思路如下：</p><ul><li>Oracle拥有非常多的默认用户名和密码，为了获得数据库系统的访问权限，破解数据库系统用户以及密码是黑客必须攻破的一道安全防线。</li><li>SQL注射同样对Oracle十分有效，通过注射可获得数据库的敏感信息，包括管理员密码等。</li><li>在注入点直接创建java，执行系统命令。<br>以上的端口渗透原理只是用作分析，现在网上有很多自动的端口入侵工具，比如445批量抓鸡器或者1433批量抓鸡器。大家有兴趣的可以去网上下载试用。</li></ul><h3 id="2049端口渗透剖析">2049端口渗透剖析</h3><p>NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。如今NFS具备了防止被利用导出文件夹的功能，但遗留系统中的NFS服务配置不当，则仍可能遭到恶意攻击者的利用。</p><ul><li>未授权访问。</li></ul><h3 id="3306端口渗透剖析">3306端口渗透剖析</h3><p>3306是MYSQL数据库默认的监听端口，通常部署在中型web系统中。在国内LAMP的配置是非常流行的，对于php+mysql构架的攻击也是属于比较热门的话题。mysql数据库允许用户使用自定义函数功能，这使得黑客可编写恶意的自定义函数对服务器进行渗透，最后取得服务器最高权限。对于3306端口的渗透，黑客的方法如下:</p><ul><li>由于管理者安全意识淡薄，通常管理密码设置过于简单，甚至为空口令。使用破解软件很容易破解此类密码，利用破解的密码登录远程mysql数据库，上传构造的恶意UDF自定义函数代码进行注册，通过调用注册的恶意函数执行系统命令。或者向web目录导出恶意的脚本程序，以控制整个web系统。</li><li>功能强大的‘cain’同样支持对3306端口的嗅探，同时嗅探也是渗透思路的一种。</li><li>SQL注入同样对mysql数据库威胁巨大，不仅可以获取数据库的敏感信息，还可使用load_file()函数读取系统的敏感配置文件或者从web数据库链接文件中获得root口令等，导出恶意代码到指定路径等。</li></ul><h3 id="3389端口渗透剖析">3389端口渗透剖析</h3><p>3389是windows远程桌面服务默认监听的端口，管理员通过远程桌面对服务器进行维护，这给管理工作带来的极大的方便。通常此端口也是黑客们较为感兴趣的端口之一，利用它可对远程服务器进行控制，而且不需要另外安装额外的软件，实现方法比较简单。当然这也是系统合法的服务，通常是不会被杀毒软件所查杀的。使用‘输入法漏洞’进行渗透。</p><ul><li>对于windows2000的旧系统版本，使用‘输入法漏洞’进行渗透。</li><li>cain是一款超级的渗透工具，同样支持对3389端口的嗅探。</li><li>Shift粘滞键后门：5次shift后门</li><li>社会工程学通常是最可怕的攻击技术，如果管理者的一切习惯和规律被黑客摸透的话，那么他管理的网络系统会因为他的弱点被渗透。</li><li>爆破3389端口。这里还是推荐使用hydra爆破工具。</li><li>ms12_020死亡蓝屏攻击。（<a href="https://www.cnblogs.com/R-Hacker/p/9178066.html%EF%BC%89" target="_blank" rel="noopener">https://www.cnblogs.com/R-Hacker/p/9178066.html）</a></li></ul><h3 id="4899端口渗透剖析">4899端口渗透剖析</h3><p>4899端口是remoteadministrator远程控制软件默认监听的端口，也就是平时常说的radmini影子。radmini目前支持TCP/IP协议，应用十分广泛，在很多服务器上都会看到该款软件的影子。对于此软件的渗透，思路如下：</p><ul><li>radmini同样存在不少弱口令的主机，通过专用扫描器可探测到此类存在漏洞的主机。</li><li>radmini远控的连接密码和端口都是写入到注册表系统中的，通过使用webshell注册表读取功能可读取radmini在注册表的各项键值内容，从而破解加密的密码散列。</li></ul><h3 id="5432端口渗透剖析">5432端口渗透剖析</h3><p>PostgreSQL是一种特性非常齐全的自由软件的对象–关系型数据库管理系统，可以说是目前世界上最先进，功能最强大的自由数据库管理系统。包括kali系统中msf也使用这个数据库；浅谈postgresql数据库攻击技术 大部分关于它的攻击依旧是sql注入，所以注入才是数据库不变的话题。</p><ul><li>爆破：弱口令：postgres postgres</li><li>缓冲区溢出：CVE-2014-2669。</li><li>远程代码执行：CVE-2018-1058。</li></ul><h3 id="5631端口渗透剖析">5631端口渗透剖析</h3><p>5631端口是著名远程控制软件pcanywhere的默认监听端口，同时也是世界领先的远程控制软件。利用此软件，用户可以有效管理计算机并快速解决技术支持问题。由于软件的设计缺陷，使得黑客可随意下载保存连接密码的*.cif文件，通过专用破解软件进行破解。这些操作都必须在拥有一定权限下才可完成，至少通过脚本渗透获得一个webshell。通常这些操作在黑客界被称为pcanywhere提权技术。</p><ul><li>PcAnyWhere提权。</li></ul><h3 id="5900端口渗透剖析">5900端口渗透剖析</h3><p>5900端口是优秀远程控制软件VNC的默认监听端口，此软件由著名的AT&amp;T的欧洲研究实验室开发的。VNC是在基于unix和linux操作系统的免费的开放源码软件，远程控制能力强大，高效实用，其性能可以和windows和MAC中的任何一款控制软件媲美。对于该端口的渗透，思路如下：</p><ul><li>VNC软件存在密码验证绕过漏洞，此高危漏洞可以使得恶意攻击者不需要密码就可以登录到一个远程系统。</li><li>cain同样支持对VNC的嗅探，同时支持端口修改。</li><li>VNC的配置信息同样被写入注册表系统中，其中包括连接的密码和端口。利用webshell的注册表读取功能进行读取加密算法，然后破解。</li><li>VNC拒绝服务攻击（CVE-2015-5239）。（<a href="http://blogs.360.cn/post/vnc%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9Ecve-2015-5239%E5%88%86%E6%9E%90.html%EF%BC%89" target="_blank" rel="noopener">http://blogs.360.cn/post/vnc拒绝服务漏洞cve-2015-5239分析.html）</a></li><li>VNC权限提升（CVE-2013-6886）。</li></ul><h3 id="6379端口渗透剖析">6379端口渗透剖析</h3><p>Redis是一个开源的使用C语言写的，支持网络、可基于内存亦可持久化的日志型、key-value数据库。关于这个数据库这两年还是很火的，暴露出来的问题也很多。特别是前段时间暴露的未授权访问。</p><ul><li>爆破：弱口令</li><li>未授权访问+配合ssh key提权。</li></ul><h3 id="70017002端口渗透剖析">7001/7002端口渗透剖析</h3><p>7001/7002通常是weblogic中间件端口</p><ul><li>弱口令、爆破，弱密码一般为weblogic/Oracle@123 or weblogic</li><li>管理后台部署 war 后门</li><li>SSRF</li><li>反序列化漏洞</li><li>weblogic_uachttps://github.com/vulhub/vulhub/tree/master/weblogic/ssrfhttps://bbs.pediy.com/thread-224954.htmhttps://fuping.site/2017/06/05/Weblogic-Vulnerability-Verification/<a href="https://blog.gdssecurity.com/labs/2015/3/30/weblogic-ssrf-and-xss-cve-2014-4241-cve-2014-4210-cve-2014-4.html" target="_blank" rel="noopener">https://blog.gdssecurity.com/labs/2015/3/30/weblogic-ssrf-and-xss-cve-2014-4241-cve-2014-4210-cve-2014-4.html</a></li></ul><h3 id="8080端口渗透剖析">8080端口渗透剖析</h3><p>8080端口通常是apache_Tomcat服务器默认监听端口，apache是世界使用排名第一的web服务器。国内很多大型系统都是使用apache服务器，对于这种大型服务器的渗透，主要有以下方法：</p><ul><li>Tomcat远程代码执行漏洞（<a href="https://www.freebuf.com/column/159200.html%EF%BC%89" target="_blank" rel="noopener">https://www.freebuf.com/column/159200.html）</a></li><li>Tomcat任意文件上传。</li><li>Tomcat远程代码执行&amp;信息泄露。</li><li>Jboss远程代码执行。</li><li>Jboss反序列化漏洞。</li><li>Jboss漏洞利用。</li></ul><h3 id="27017端口渗透剖析">27017端口渗透剖析</h3><p>MongoDB，NoSQL数据库；攻击方法与其他数据库类似</p><ul><li>爆破：弱口令</li><li>未授权访问；（<a href="http://www.cnblogs.com/LittleHann/p/6252421.html%EF%BC%89" target="_blank" rel="noopener">http://www.cnblogs.com/LittleHann/p/6252421.html）</a></li></ul><h3 id="参考链接">参考链接</h3><p><font color="#00dddd"><a href="http://www.pinlue.com/article/2018/09/1119/337041546717.html" target="_blank" rel="noopener">http://www.pinlue.com/article/2018/09/1119/337041546717.html</a></font></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言常见数据结构实现原理之chan</title>
      <link href="/article/Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Bchan/"/>
      <url>/article/Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Bchan/</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>channel是Golang在语言层面提供的goroutine间的通信方式，比Unix管道更易用也更轻便。channel主要用于进程内各goroutine间通信，如果需要跨进程通信，建议使用分布式系统的方法来解决。本文从源码角度分析channel的实现机制。</p><h3 id="chan数据结构">chan数据结构</h3><p>src/runtime/chan.go:hchan定义了channel的数据结构：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// 当前队列中剩余元素个数</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// 环形队列长度，即可以存放的元素个数</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 环形队列指针</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span>         <span class="comment">// 每个元素的大小</span></span><br><span class="line">    closed   <span class="keyword">uint32</span>            <span class="comment">// 标识关闭状态</span></span><br><span class="line">    elemtype *_type         <span class="comment">// 元素类型</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>           <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>           <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">    recvq    waitq          <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">    sendq    waitq          <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line">    lock mutex              <span class="comment">// 互斥锁，chan不允许并发读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数据结构可以看出channel由队列、类型信息、goroutine等待队列组成，下面分别说明其原理。</p><h4 id="环形队列">环形队列</h4><p>chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的。下图展示了一个可缓存6个元素的channel示意图：<br><img src="./img_1.png" alt=""></p><ul><li>dataqsiz指示了队列长度为6，即可缓存6个元素；</li><li>buf指向队列的内存，队列中还剩余两个元素；</li><li>qcount表示队列中还有两个元素；</li><li>sendx指示后续写入的数据存储的位置，取值[0, 6)；</li><li>recvx指示从该位置读取数据, 取值[0, 6)；</li></ul><h4 id="等待队列">等待队列</h4><p>从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。 向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。被阻塞的goroutine将会挂在channel的等待队列中：</p><ul><li>因读阻塞的goroutine会被向channel写入数据的goroutine唤醒；</li><li>因写阻塞的goroutine会被从channel读数据的goroutine唤醒；</li></ul><p>下图展示了一个没有缓冲区的channel，有几个goroutine阻塞等待读数据：<br><img src="./img_2.png" alt=""></p><blockquote><p>注意，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。</p></blockquote><h4 id="类型信息">类型信息</h4><p>一个channel只能传递一种类型的值，类型信息存储在hchan数据结构中。</p><ul><li>elemtype代表类型，用于数据传递过程中的赋值；</li><li>elemsize代表类型大小，用于在buf中定位元素位置。</li></ul><h4 id="锁">锁</h4><p>一个channel同时仅允许被一个goroutine读写，为简单起见，本章后续部分说明读写过程时不再涉及加锁和解锁。</p><h3 id="channel读写">channel读写</h3><h4 id="创建channel">创建channel</h4><p>创建channel的过程实际上是初始化hchan结构。其中类型信息和缓冲区长度由make语句传入，buf的大小则与元素大小和缓冲区长度共同决定。</p><p>创建channel的伪代码如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    c = <span class="built_in">new</span>(hchan)</span><br><span class="line">    c.buf = malloc(元素类型大小*size)</span><br><span class="line">    c.elemsize = 元素类型大小</span><br><span class="line">    c.elemtype = 元素类型</span><br><span class="line">    c.dataqsiz = size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向channel写数据">向channel写数据</h4><p>向一个channel中写数据简单过程如下：</p><ol><li>如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程；</li><li>如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程；</li><li>如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒；</li></ol><p>简单流程图如下：<br><img src="./img_3.png" alt=""></p><h4 id="从channel读数据">从channel读数据</h4><p>从一个channel读数据简单过程如下：</p><ol><li>如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；</li><li>如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；</li><li>如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；</li><li>将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；</li></ol><p>简单流程图如下：<br><img src="./img_4.png" alt=""></p><h4 id="关闭channel">关闭channel</h4><p>关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。</p><p>除此之外，panic出现的常见场景还有：</p><ol><li>关闭值为nil的channel</li><li>关闭已经被关闭的channel</li><li>向已经关闭的channel写数据</li></ol><h3 id="常见用法">常见用法</h3><h4 id="单向channel">单向channel</h4><p>顾名思义，单向channel指只能用于发送或接收数据，实际上也没有单向channel。</p><p>我们知道channel可以通过参数传递，所谓单向channel只是对channel的一种使用限制，这跟C语言使用const修饰函数参数为只读是一个道理。</p><ul><li>func readChan(chanName &lt;-chan int)： 通过形参限定函数内部只能从channel中读取数据</li><li>func writeChan(chanName chan&lt;- int)： 通过形参限定函数内部只能向channel中写入数据</li></ul><p>一个简单的示例程序如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readChan</span><span class="params">(chanName &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    &lt;- chanName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeChan</span><span class="params">(chanName <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    chanName &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mychan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    writeChan(mychan)</span><br><span class="line">    readChan(mychan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mychan是个正常的channel，而readChan()参数限制了传入的channel只能用来读，writeChan()参数限制了传入的channel只能用来写。</p><h4 id="select">select</h4><p>使用select可以监控多channel，比如监控多个channel，当其中某一个channel有数据时，就从其读出数据。</p><p>一个简单的示例程序如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNumberToChan</span><span class="params">(chanName <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        chanName &lt;- <span class="number">1</span></span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> chan1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">var</span> chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> addNumberToChan(chan1)</span><br><span class="line">    <span class="keyword">go</span> addNumberToChan(chan2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e := &lt;- chan1 :</span><br><span class="line">            fmt.Printf(<span class="string">"Get element from chan1: %d\n"</span>, e)</span><br><span class="line">        <span class="keyword">case</span> e := &lt;- chan2 :</span><br><span class="line">            fmt.Printf(<span class="string">"Get element from chan2: %d\n"</span>, e)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"No element in chan1 and chan2.\n"</span>)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中创建两个channel： chan1和chan2。函数addNumberToChan()函数会向两个channel中周期性写入数据。通过select可以监控两个channel，任意一个可读时就从其中读出数据。</p><p>程序输出如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;<span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">Get element from chan1: <span class="number">1</span></span><br><span class="line">Get element from chan2: <span class="number">1</span></span><br><span class="line">No element in chan1 and chan2.</span><br><span class="line">Get element from chan2: <span class="number">1</span></span><br><span class="line">Get element from chan1: <span class="number">1</span></span><br><span class="line">No element in chan1 and chan2.</span><br><span class="line">Get element from chan2: <span class="number">1</span></span><br><span class="line">Get element from chan1: <span class="number">1</span></span><br><span class="line">No element in chan1 and chan2.</span><br></pre></td></tr></table></figure><p>从输出可见，从channel中读出数据的顺序是随机的，事实上select语句的多个case执行顺序是随机的，关于select的实现原理会有专门章节分析。</p><p>通过这个示例想说的是：select的case语句读channel不会阻塞，尽管channel中没有数据。这是由于case语句编译后调用读channel时会明确传入不阻塞的参数，此时读不到数据时不会将当前goroutine加入到等待队列，而是直接返回。</p><h4 id="range">range</h4><p>通过range可以持续从channel中读出数据，好像在遍历一个数组一样，当channel中没有数据时会阻塞当前goroutine，与读channel时阻塞处理机制一样。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanRange</span><span class="params">(chanName <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> e := <span class="keyword">range</span> chanName &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Get element from chan: %d\n"</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果向此channel写数据的goroutine退出时，系统检测到这种情况后会panic，否则range将会永久阻塞。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Channel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安天蜜网捕获“利用ElasticSearch Groovy漏洞进行门罗币(Dog)挖矿”事件分析</title>
      <link href="/article/%E5%AE%89%E5%A4%A9%E8%9C%9C%E7%BD%91%E6%8D%95%E8%8E%B7%E2%80%9C%E5%88%A9%E7%94%A8ElasticSearch-Groovy%E6%BC%8F%E6%B4%9E%E8%BF%9B%E8%A1%8C%E9%97%A8%E7%BD%97%E5%B8%81-Dog-%E6%8C%96%E7%9F%BF%E2%80%9D%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/article/%E5%AE%89%E5%A4%A9%E8%9C%9C%E7%BD%91%E6%8D%95%E8%8E%B7%E2%80%9C%E5%88%A9%E7%94%A8ElasticSearch-Groovy%E6%BC%8F%E6%B4%9E%E8%BF%9B%E8%A1%8C%E9%97%A8%E7%BD%97%E5%B8%81-Dog-%E6%8C%96%E7%9F%BF%E2%80%9D%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="概述">概述</h3><p>2019年6月13日，安天蜜网捕获到利用CVE-2015-1427(ElasticSearch Groovy)远程命令执行漏洞的攻击行为。该漏洞原理是Elaticsearch将groovy作为脚本语言，并使用基于黑白名单的沙盒机制限制危险代码执行，但该机制不够严格，可以被绕过，从而导致出现远程代码执行的情况。安天对此次事件进行了详细的样本分析，并给出预防及修复建议。</p><h3 id="具体分析">具体分析</h3><h4 id="关键攻击载荷">关键攻击载荷</h4><p>从攻击载荷来看，攻击者通过groovy作为脚本语言，向_search?pretty页面发送一段带有恶意链接为http://185.181.10.234/E5DB0E07C3D7BE80V520/init.sh的json脚本，进行恶意shell脚本下载，从而实现远程代码攻击，并进行挖矿行为<br><img src="./img_1.jpg" alt=""><br>解密后核心代码：<br><img src="./img_2.jpg" alt=""></p><h4 id="样本分析">样本分析</h4><h5 id="入侵脚本initsh分析">入侵脚本init.sh分析</h5><p>攻击者通过http://185.181.10.234/E5DB0E07C3D7BE80V520/init.sh下载并执行恶意脚本init.sh来植入Dog挖矿程序，同时对主机进行扫描等一系列操作。<br><img src="./img_3.jpg" alt=""><br>之后执行关闭防火墙、关闭selinux并释放占用的资源、杀掉其他与挖矿相关的进程、设置定时任务（每30分钟下载一次可执行文件<font color="#dd0000"><a href="http://update.sh" target="_blank" rel="noopener">update.sh</a></font>），获取ssh权限，进行iptables规则转发修改，同时清理相关操作历史、日志等操作。</p><p>检查并杀死其他存在的挖矿进程：<br><img src="./img_4.jpg" alt=""></p><p>设置定时任务：<br><img src="./img_5.jpg" alt=""></p><p>恶意脚本下载地址、备份地址以及大小设置:<br><img src="./img_6.jpg" alt=""></p><p>清理相关日志、历史：<br><img src="./img_7.jpg" alt=""></p><p>在此过程中，脚本会检查sysupdate、networkservice 和sysguard这3个进程是否启动，如果没有则进行启动。</p><p>当其中一个被kill掉后，调度文件重新启动:<br><img src="./img_8.jpg" alt=""></p><h5 id="样本分析sysguard-networkservice-sysupdate">样本分析sysguard、networkservice、sysupdate</h5><p>三个样本为go语言编写并使用UPX加壳，对应的main_main函数结构分别如下：</p><p>sysguard-main_main函数结构:<br><img src="./img_9.jpg" alt=""></p><p>networkservice-main_main函数结构:<br><img src="./img_10.jpg" alt=""></p><p>sysupdate-main函数函数结构:<br><img src="./img_11.jpg" alt=""></p><p>通过与之前捕获的systemctI样本对比发现，此次攻击分成挖矿、扫描、函数调用三个进程进行调度。并且在networkservice样本中发现了相关漏洞利用函数和扫描函数。</p><p>networkservice扫描函数:<br><img src="./img_12.jpg" alt=""><br>通过对比之前捕获的样本发现两次攻击手法类似，不同的是此次攻击是通过sysguard、networkservice（扫描）和sysupdate三个进程共同进行的。这也意味着，发现服务器被感染后要将这三个进程同时kill掉。</p><h5 id="配置文件configjson">配置文件config.json</h5><p>在下载的配置文件中，我们发现了多个矿池地址：</p><table><thead><tr><th style="text-align:center">矿池地址</th></tr></thead><tbody><tr><td style="text-align:center"><a href="http://xmr.f2pool.com:13531" target="_blank" rel="noopener">xmr.f2pool.com:13531</a></td></tr><tr><td style="text-align:center"><a href="http://cryptonightr.in.nicehash.com:3375" target="_blank" rel="noopener">cryptonightr.in.nicehash.com:3375</a></td></tr><tr><td style="text-align:center"><a href="http://cryptonightr.br.nicehash.com:3375" target="_blank" rel="noopener">cryptonightr.br.nicehash.com:3375</a></td></tr><tr><td style="text-align:center"><a href="http://cryptonightr.hk.nicehash.com:3375" target="_blank" rel="noopener">cryptonightr.hk.nicehash.com:3375</a></td></tr><tr><td style="text-align:center"><a href="http://cryptonightr.jp.nicehash.com:3375" target="_blank" rel="noopener">cryptonightr.jp.nicehash.com:3375</a></td></tr><tr><td style="text-align:center"><a href="http://cryptonightr.usa.nicehash.com:3375" target="_blank" rel="noopener">cryptonightr.usa.nicehash.com:3375</a></td></tr></tbody></table><p>配置文件矿池字段：<br><img src="./img_13.jpg" alt=""></p><h3 id="受影响的服务及漏洞">受影响的服务及漏洞</h3><table><thead><tr><th>服务</th><th>漏洞</th></tr></thead><tbody><tr><td>Weblogic</td><td>CVE-2017-10271</td></tr><tr><td>Thinkphp5</td><td>远程代码执行</td></tr><tr><td>Spring Data Commons</td><td>CVE-2018-1273</td></tr><tr><td>Hadoop</td><td>未授权访问</td></tr><tr><td>ElasticSearch</td><td>CVE-2014-3120  CVE-2015-1427</td></tr><tr><td>Drupal</td><td>CVE-2018-7600</td></tr><tr><td>Redis</td><td>未授权访问</td></tr><tr><td>SQL Server</td><td>弱密码</td></tr></tbody></table><h3 id="ioc">IOC</h3><p>攻击IP：</p><table><thead><tr><th>IP</th><th>地理位置</th></tr></thead><tbody><tr><td>132.145.186.243</td><td>美国</td></tr><tr><td>111.40.10.11</td><td>中国-黑龙江­哈尔滨</td></tr><tr><td>167.86.106.102</td><td>美国-科罗拉多州-利特尔顿</td></tr><tr><td>221.176.156.164</td><td>中国-河南-开封</td></tr><tr><td>185.181.10.234</td><td>德国-黑森州-法兰克福</td></tr></tbody></table><p>URL：</p><table><thead><tr><th style="text-align:center">URL</th></tr></thead><tbody><tr><td style="text-align:center"><a href="http://185.181.10.234/E5DB0E07C3D7BE80V520/config.json" target="_blank" rel="noopener">http://185.181.10.234/E5DB0E07C3D7BE80V520/config.json</a></td></tr><tr><td style="text-align:center"><a href="http://185.181.10.234/E5DB0E07C3D7BE80V520/networkservice" target="_blank" rel="noopener">http://185.181.10.234/E5DB0E07C3D7BE80V520/networkservice</a></td></tr><tr><td style="text-align:center"><a href="http://185.181.10.234/E5DB0E07C3D7BE80V520/sysguard" target="_blank" rel="noopener">http://185.181.10.234/E5DB0E07C3D7BE80V520/sysguard</a></td></tr><tr><td style="text-align:center"><a href="http://185.181.10.234/E5DB0E07C3D7BE80V520/sysupdate" target="_blank" rel="noopener">http://185.181.10.234/E5DB0E07C3D7BE80V520/sysupdate</a></td></tr><tr><td style="text-align:center"><a href="http://185.181.10.234/E5DB0E07C3D7BE80V520/update.sh" target="_blank" rel="noopener">http://185.181.10.234/E5DB0E07C3D7BE80V520/update.sh</a></td></tr><tr><td style="text-align:center"><a href="https://de.gsearch.com.de/api/config.json" target="_blank" rel="noopener">https://de.gsearch.com.de/api/config.json</a></td></tr><tr><td style="text-align:center"><a href="https://de.gsearch.com.de/api/networkservice" target="_blank" rel="noopener">https://de.gsearch.com.de/api/networkservice</a></td></tr><tr><td style="text-align:center"><a href="https://de.gsearch.com.de/api/sysguard" target="_blank" rel="noopener">https://de.gsearch.com.de/api/sysguard</a></td></tr><tr><td style="text-align:center"><a href="https://de.gsearch.com.de/api/sysupdate" target="_blank" rel="noopener">https://de.gsearch.com.de/api/sysupdate</a></td></tr><tr><td style="text-align:center"><a href="https://de.gsearch.com.de/api/update.sh" target="_blank" rel="noopener">https://de.gsearch.com.de/api/update.sh</a></td></tr><tr><td style="text-align:center"><a href="http://185.181.10.234/E5DB0E07C3D7BE80V520/init.sh" target="_blank" rel="noopener">http://185.181.10.234/E5DB0E07C3D7BE80V520/init.sh</a></td></tr></tbody></table><p>MD5：</p><table><thead><tr><th style="text-align:center">MD5</th></tr></thead><tbody><tr><td style="text-align:center">09c3dbdb39e1437a40b5c22600b375ca</td></tr><tr><td style="text-align:center">8e9957b496a745f5db09b0f963eba74e</td></tr><tr><td style="text-align:center">c31038f977f766eeba8415f3ba2c242c</td></tr><tr><td style="text-align:center">ff879d31ed80841482c27c90e2bfe268</td></tr><tr><td style="text-align:center">1cc08560de0edb78a9c4a0f1ba664e5f</td></tr></tbody></table><h3 id="预防与修复建议">预防与修复建议</h3><h4 id="预防建议">预防建议</h4><ul><li><p>确保系统与应用程序及时下载更新为官方提供的最新补丁；</p></li><li><p>禁止使用弱口令密码；</p></li><li><p>定期检查服务器异常，如CPU持续占用高、磁盘异常情况；</p></li><li><p>安装终端威胁安全防护产品–安天智甲终端防御系统。安天智甲终端防御系统可以为您量身定制专属安全基线，为您打造安全的内网环境；同时，文档安全保护功能、全网病毒定点清除功能、以及国产操作系统的安全防护功能更好的解决您遇到的安全问题，保护您的服务器。</p></li></ul><h4 id="修复建议">修复建议</h4><ul><li>断网、备份重要的crontab，关闭或删除定时任务：systemctl stop crontab或 rm -rf /etc/cron.d/*；</li><li>锁定crontab中的恶意文件；</li><li>查看并杀掉病毒进程：同时杀掉sysguard、networkservice、sysupdate三个进程；</li><li>删除病毒相关文件，确认无误后，重启服务器，安装漏洞补丁，并采用安天智甲终端防御系统进行预防和保护服务器的安全。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安天每日安全简讯2019-12-05</title>
      <link href="/article/%E5%AE%89%E5%A4%A9%E6%AF%8F%E6%97%A5%E5%AE%89%E5%85%A8%E7%AE%80%E8%AE%AF2019-12-05/"/>
      <url>/article/%E5%AE%89%E5%A4%A9%E6%AF%8F%E6%97%A5%E5%AE%89%E5%85%A8%E7%AE%80%E8%AE%AF2019-12-05/</url>
      
        <content type="html"><![CDATA[<h3 id="恶意软件callerspy伪装成聊天程序窃取用户信息">恶意软件CallerSpy伪装成聊天程序窃取用户信息</h3><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"https://techrepublicvideo.cbsistatic.com/media/2019/07/25/1576454211504/2019-07-25-wochit-mobile-malware-is-on-the-rise-thanks-to-banking-apps-and-weak-security_1898142_740.mp4","pic":"./img_1.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>趋势科技的网络安全研究人员发现并详细描述了被称为CallerSpy的木马恶意软件，他们认为该恶意软件攻击是网络间谍活动的一部分。尽管被广告宣传为聊天应用程序，但CallerSpy应用程序不包含任何聊天功能，CallerSpy的恶意功能包括收集设备上所有的通话记录、短信、联系人列表和文件，能够使用手机的麦克风记录周围环境的音频，以及能够截屏用户活动。所有被盗的数据都会定期上传到攻击者那里。</p><blockquote><p><a href="https://www.zdnet.com/article/this-new-android-malware-comes-disguised-as-a-chat-app/" target="_blank" rel="noopener">https://www.zdnet.com/article/this-new-android-malware-comes-disguised-as-a-chat-app/</a></p></blockquote><h3 id="新版本的icedid木马中使用了隐写负载">新版本的IcedID木马中使用了隐写负载</h3><p><img src="./img_2.png" alt=""><br>安全公司Proofpoint最近发布了一份报告，该报告涉及一系列归因于威胁行为者TA2101的垃圾邮件活动，恶意电子邮件浪潮针对美国，推动了IcedID木马。IcedID不仅是银行木马，而且是能够提取各种凭证的通用窃取者。该木马是由经验丰富的开发人员编写的成熟程序。 它部署了各种典型技术，包括Zeus风格的Webinject，用于各种浏览器的挂钩，隐藏的VNC和反向连接。在最近的更新中，恶意软件的作者给木马安装了隐写术。 在威胁环境中看到它并不是什么新鲜事物，但是它使此恶意软件更加隐蔽。</p><blockquote><p><a href="https://blog.malwarebytes.com/threat-analysis/2019/12/new-version-of-icedid-trojan-uses-steganographic-payloads/" target="_blank" rel="noopener">https://blog.malwarebytes.com/threat-analysis/2019/12/new-version-of-icedid-trojan-uses-steganographic-payloads/</a></p></blockquote><h3 id="两个恶意python库窃取了ssh和gpg密钥">两个恶意Python库窃取了SSH和GPG密钥</h3><p><img src="./img_3.png" alt=""><br>Python安全团队从PyPI（Python软件包索引）中删除了两个木马化的Python库，这些库被发现从受感染的开发人员的项目中窃取SSH和GPG密钥。第一个是“ python3-dateutil”，它模仿了流行的“ dateutil”库。 第二个是“jeIlyfish”（第一个L是I），它模仿“jellyfish”库。这两名恶意克隆者是在12月1日周日被德国软件开发人员Lukas Martini发现的。在Martini通知dateutil开发人员和PyPI安全团队后，这两个库都被删除了。</p><blockquote><p><a href="https://www.zdnet.com/article/two-malicious-python-libraries-removed-from-pypi/" target="_blank" rel="noopener">https://www.zdnet.com/article/two-malicious-python-libraries-removed-from-pypi/</a></p></blockquote><h3 id="西门子的s7-1200-plc产品中存在安全漏洞">西门子的S7-1200 PLC产品中存在安全漏洞</h3><p><img src="./img_4.jpg" alt=""><br>西门子最近发布了一份安全公告，其中包含针对研究人员在其S7-1200可编程逻辑控制器（PLC）中发现的漏洞的变通办法和缓解措施，该漏洞可用于绕过固件完整性检查以加载恶意软件或劫持设备的工业流程。西门子表示：“我们正在审查我们的产品模型，并将在SSA-686531上发布更新，以防其他模型受到影响。研究人员还发现，可编程逻辑控制器（PLC）中的特殊访问功能也可以很好地用作：作为防御者的取证工具。他们利用该功能查看PLC存储器的内容，因此工厂操作员也可以使用它来查找设备上的恶意代码。</p><blockquote><p><a href="https://www.darkreading.com/vulnerabilities/threats/siemens-offers-workarounds-for-newly-found-plc-vulnerability/d/d-id/1336503" target="_blank" rel="noopener">https://www.darkreading.com/vulnerabilities/threats/siemens-offers-workarounds-for-newly-found-plc-vulnerability/d/d-id/1336503</a></p></blockquote><h3 id="goahead嵌入式web服务器中存在安全漏洞">GoAhead嵌入式Web服务器中存在安全漏洞</h3><p><img src="./img_5.png" alt=""><br>思科Talos的专家在GoAhead的嵌入式web服务器中发现了两个漏洞，包括一个超危的远程代码执行漏洞。第一个漏洞(跟踪为CVE-2019-5096)与如何处理多部分/表单数据请求有关。未经身份验证的攻击者可以利用这个缺陷触发一个空闲后使用的条件，并通过发送特殊的HTTP请求在服务器上执行任意代码。Talos在GoAhead web服务器中发现的第二个漏洞(被跟踪为CVE-2019-5097)可被未经身份验证的攻击者利用，通过发送经过特殊处理的HTTP请求来造成拒绝服务(DoS)条件。Talos在8月份向EmbedThis报告了这些漏洞，供应商在11月21日修复了它们。</p><blockquote><p><a href="https://securityaffairs.co/wordpress/94692/hacking/goahead-rce.html" target="_blank" rel="noopener">https://securityaffairs.co/wordpress/94692/hacking/goahead-rce.html</a></p></blockquote><h3 id="accusoft-imagegear中存在代码执行漏洞">Accusoft ImageGear中存在代码执行漏洞</h3><p><img src="./img_6.jpg" alt=""><br>思科Talos发现，文档和映像库Accusoft ImageGear中的漏洞可能使攻击者能够在易受攻击的计算机上远程执行代码。作为CVE-2019-5083进行跟踪，第一个问题影响igcore19d.dll TIF_decode_thunderscan函数。第二个漏洞CVE-2019-5076影响了该工具包的igcore19d.dll PNG标头解析器。在ImageGear的igcore19d.dll GEM Raster解析器中发现了另一个越界写入漏洞。跟踪为CVE-2019-5132，它需要特制的GEM文件才能在受影响的系统上执行代码。第四个漏洞CVE-2019-5133影响了该库的igcore19d.dll BMP解析器。思科Talos于7月底将漏洞报告给Accusoft。上周发布了补丁。</p><blockquote><p><a href="https://www.securityweek.com/code-execution-vulnerabilities-patched-accusoft-imagegear" target="_blank" rel="noopener">https://www.securityweek.com/code-execution-vulnerabilities-patched-accusoft-imagegear</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISC和CISC科普</title>
      <link href="/article/RISC%E5%92%8CCISC%E7%A7%91%E6%99%AE/"/>
      <url>/article/RISC%E5%92%8CCISC%E7%A7%91%E6%99%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>RISC是英文Reduced Instruction Set Computer<br>CISC是英文Complex Instruction Set Computer<br>RISC（精简指令集计算机）和CISC（复杂指令集计算机）是当前CPU的两种架构。它们的区别在于不同的CPU设计理念和方法。</p></blockquote><h3 id="cisc架构">CISC架构</h3><p>早期的CPU全部是CISC架构，它的设计目的是要用最少的机器语言指令来完成所需的计算任务。比如对于乘法运算，在CISC架构的CPU上，您可能需要这样一条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL ADDRA, ADDRB</span><br></pre></td></tr></table></figure><p>就可以将ADDRA和ADDRB中的数相乘并将结果储存在ADDRA中。将ADDRA, ADDRB中的数据读入寄存器，相乘和将结果写回内存的操作全部依赖于CPU中设计的逻辑来实现。这种架构会增加CPU结构的复杂性和对CPU工艺的要求，但对于编译器的开发十分有利。比如上面的例子，C程序中的<font color="#dd0000">a*=b</font>就可以直接编译为一条乘法指令。今天只有Intel及其兼容CPU还在使用CISC架构。</p><h3 id="risc架构">RISC架构</h3><p>RISC架构要求软件来指定各个操作步骤。上面的例子如果要在RISC架构上实现，将ADDRA, ADDRB中的数据读入寄存器，相乘和将结果写回内存的操作都必须由软件来实现，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV A, ADDRA; </span><br><span class="line">MOV B, ADDRB; </span><br><span class="line">MUL A, B; </span><br><span class="line">STR ADDRA, A;</span><br></pre></td></tr></table></figure><p>这种架构可以降低CPU的复杂性以及允许在同样的工艺水平下生产出功能更强大的CPU，但对于编译器的设计有更高的要求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APT恶意软件分析之从WORD中提取EXE技术</title>
      <link href="/article/APT%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%8EWORD%E4%B8%AD%E6%8F%90%E5%8F%96EXE%E6%8A%80%E6%9C%AF/"/>
      <url>/article/APT%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%8EWORD%E4%B8%AD%E6%8F%90%E5%8F%96EXE%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>本文章讲解的是一个word恶意样本的提取出来恶意EXE文件的方法。</p><h1 id="恶意样本下载地址">恶意样本下载地址</h1><p>注册登录后即可下载原始的word恶意样本</p><blockquote><p><a href="https://malwr.com/analysis/MjQxOTQ5NWNjMGZlNGFiZmJkYzcwOTlkNDE3ZDdhZTU/" target="_blank" rel="noopener">https://malwr.com/analysis/MjQxOTQ5NWNjMGZlNGFiZmJkYzcwOTlkNDE3ZDdhZTU/</a></p></blockquote><h1 id="分析工具准备工作">分析工具准备工作</h1><h1 id="安装依赖包">安装依赖包</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//bitbucket.org/decalage/olefileio_pl/downloads/olefile-0.41.zip</span></span><br><span class="line"></span><br><span class="line">unzip oldfile - <span class="number">0.41</span>.zip</span><br><span class="line"></span><br><span class="line">cd oldfile - <span class="number">0.41</span></span><br><span class="line"></span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><h1 id="下载oledump">下载oledump</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//didierstevens.com/files/software/oledump_V0_0_4.zip</span></span><br><span class="line"></span><br><span class="line">wget http:<span class="comment">//didierstevens.com/files/software/pecheck_v0_3_0.zip</span></span><br></pre></td></tr></table></figure><h1 id="word恶意样本分析">word恶意样本分析</h1><h1 id="查看word恶意样本信息">查看word恶意样本信息</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oledump.py <span class="number">1.</span>doc</span><br></pre></td></tr></table></figure><blockquote><p>结果说明: 模块7包含了一个宏</p></blockquote><p><img src="./oledump_apt_1.png" alt="avatar"></p><h1 id="查看宏脚本">查看宏脚本</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oledump.py - s <span class="number">7</span> - v  <span class="number">1.</span>doc</span><br></pre></td></tr></table></figure><p>输出内容：<br><img src="./oledump_apt_2.png" alt="avatar"></p><h1 id="查看word中插入的内容">查看word中插入的内容</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oledump.py - s <span class="number">14</span>  <span class="number">1.</span>doc</span><br></pre></td></tr></table></figure><p>结果：<br><img src="./oledump_apt_3.png" alt="avatar"></p><h4 id="宏内容解码">宏内容解码</h4><ul><li>解码脚本：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line">__description__ = <span class="string">'&amp;H decoder for oledump.py'</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'Didier Stevens'</span></span><br><span class="line"></span><br><span class="line">__version__ = <span class="string">'0.0.1'</span></span><br><span class="line"></span><br><span class="line">__date__ = <span class="string">'2014/12/19'</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Source code put in public domain by Didier Stevens, no Copyright</span></span><br><span class="line"><span class="string">https://DidierStevens.com</span></span><br><span class="line"><span class="string">Use at your own risk</span></span><br><span class="line"><span class="string">History:</span></span><br><span class="line"><span class="string">  2014/12/19: start</span></span><br><span class="line"><span class="string">Todo:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cAmpersandHexDecoder</span><span class="params">(cDecoderParent)</span>:</span></span><br><span class="line"></span><br><span class="line">    name = <span class="string">'&amp;H decoder'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, stream, options)</span>:</span></span><br><span class="line">        self.stream = stream</span><br><span class="line">        self.options = options</span><br><span class="line">        self.done = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Available</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.done</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Decode</span><span class="params">(self)</span>:</span></span><br><span class="line">        decoded = <span class="string">''</span>.join([chr(int(s[<span class="number">2</span>:], <span class="number">16</span>)) <span class="keyword">for</span> s <span class="keyword">in</span> re.compile(<span class="string">'&amp;H[0-9a-f]&#123;2&#125;'</span>, re.IGNORECASE).findall(self.stream)])</span><br><span class="line">        self.name = <span class="string">'&amp;H decoder'</span></span><br><span class="line">        self.done = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> decoded</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">AddDecoder(cAmpersandHexDecoder)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oledump.py -s <span class="number">14</span>  -D decoder_ay.py <span class="number">1.</span>doc  | more</span><br></pre></td></tr></table></figure><ul><li>进行解码</li></ul><p>结果输出：<br><img src="./oledump_apt_4.png" alt="avatar"></p><h4 id="word样本中的exe病毒样本导出">WORD样本中的EXE病毒样本导出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oledump.py -s <span class="number">14</span>  -D decoder_ay.py -d <span class="number">1.</span>doc  &gt;<span class="number">1.</span>exe</span><br></pre></td></tr></table></figure><h4 id="查看virustotal结果">查看virustotal结果</h4><p><img src="./oledump_apt_5.png" alt="avatar"></p><blockquote><p>【原文】<a href="http://blog.sina.com.cn/s/blog_e8e60bc00102velj.html" target="_blank" rel="noopener">原链接</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> APT样本提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用go管理Makefile</title>
      <link href="/article/%E4%BD%BF%E7%94%A8go%E7%AE%A1%E7%90%86Makefile/"/>
      <url>/article/%E4%BD%BF%E7%94%A8go%E7%AE%A1%E7%90%86Makefile/</url>
      
        <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>很多时候， 我们需要运行多个命令来能完成一件事，又或者某个命令需要指定很多参数。这个时候，就需要使用脚本来取代这些复杂的命令，减少输错命令的可能，也可以为后来者指明常用的操作。</p><h3 id="makefile">Makefile</h3><p>Makefile就是为此而生的，相对于用途广泛的shell脚本，Makefile专注于构建自动化过程， 通常用于编译源码等。 很多项目都会提供Makefile文件，只需要简单地运行<code>make</code> 就能轻松完成编译构建的过程。</p><p>简单介绍下Makefile的规则。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target: dependencies</span><br><span class="line">    system command(s)</span><br></pre></td></tr></table></figure><ul><li><p>target通常是程序要生成的目标文件的名字。但也可以是一个动作的名字。</p></li><li><p>dependencies是依赖，通常是文件，完成target所需要的输入。</p></li><li><p>system command(s) 是完成 target 所需要运行的指令， 即 shell 命令。<br>一条语句一行， 使用单个 tab 缩进。</p></li></ul><p>使用 make 命令可以运行各种 target。 如果不带 target 参数，<br>第一个 target 会被作为默认目标。</p><p>很多时候， Makefile 不是为了编译， 也不再引用任何文件，<br>仅仅是为了整合多个命令， 比写脚本方便多。<br>这个时候涉及到一个叫做伪目标的指令 <code>.PHONY</code>。<br><code>.PHONY</code> 后面跟着的多个 target 都不是要生成的文件的名字，<br>而是指代一个动作， 一个行为。 比如 test 指运行测试， clean 清理文件等。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: all test clean doc ci</span><br></pre></td></tr></table></figure><p>更多内容可以参考<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fseisman.github.io%2Fhow-to-write-makefile%2Findex.html" target="_blank" rel="noopener">跟我一起写 Makefile</a></p><h3 id="实践">实践</h3><p><strong>注意， windows 下没有 make 命令， 所以 Makefile 也就无法使用。</strong></p><p>你可以在 docker 容器中运行命令， 可以参考另一篇文章<br><code>在 VS Code 中使用容器开发</code>。</p><p>在项目的根目录添加 <code>Makefile</code> 文件:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">all: gotool build</span><br><span class="line">build:</span><br><span class="line">    @<span class="keyword">go</span> build ./</span><br><span class="line">run:</span><br><span class="line">    @<span class="keyword">go</span> run ./</span><br><span class="line">clean:</span><br><span class="line">    rm -f web</span><br><span class="line">    find . -name <span class="string">"[._]*.s[a-w][a-z]"</span> | xargs -i rm -f &#123;&#125;</span><br><span class="line">gotool:</span><br><span class="line">    <span class="keyword">go</span> fmt ./</span><br><span class="line">    <span class="keyword">go</span> vet ./</span><br><span class="line">ca:</span><br><span class="line">    MSYS_NO_PATHCONV=<span class="number">1</span> openssl req -<span class="built_in">new</span> -nodes -x509 -out conf/server.crt -keyout conf/server.key -days <span class="number">3650</span> -subj <span class="string">"/C=CN/ST=SH/L=SH/O=CoolCat/OU=CoolCat Software/CN=127.0.0.1/emailAddress=coolcat@qq.com"</span></span><br><span class="line">mysql:</span><br><span class="line">    docker-compose up -d mysql</span><br><span class="line">dbcli:</span><br><span class="line">    docker-compose run --rm dbclient</span><br><span class="line"></span><br><span class="line">help:</span><br><span class="line">    @echo <span class="string">"make - 格式化 Go 代码， 并编译生成二进制文件"</span></span><br><span class="line">    @echo <span class="string">"make build - 编译 Go 代码， 生成二进制文件"</span></span><br><span class="line">    @echo <span class="string">"make run - 直接运行 Go 代码"</span></span><br><span class="line">    @echo <span class="string">"make clean - 移除二进制文件和 vim swap files"</span></span><br><span class="line">    @echo <span class="string">"make gotool - 运行 Go 工具 'fmt' and 'vet'"</span></span><br><span class="line">    @echo <span class="string">"make ca - 生成证书文件"</span></span><br><span class="line">    @echo <span class="string">"make mysql - 启动 mysql 服务器"</span></span><br><span class="line">    @echo <span class="string">"make dbcli - 连接到 mysql 命令行"</span></span><br><span class="line"></span><br><span class="line">。PHONY: all build run clean gotool ca mysql dbcli help</span><br></pre></td></tr></table></figure><p>这里的所有 target 都是伪目标。用来包装一些简单的 shell 命令。</p><p>可以在项目根目录下运行以下命令:</p><ul><li>make - 格式化 Go 代码， 并编译生成二进制文件</li><li>make build - 编译 Go 代码， 生成二进制文件</li><li>make run - 直接运行 Go 代码</li><li>make clean - 移除二进制文件和 vim swap files</li><li>make gotool - 运行 Go 工具 ‘fmt’ and ‘vet’</li><li>make ca - 生成证书文件</li><li>make mysql - 启动 mysql 服务器</li><li>make dbcli - 连接到 mysql 命令行</li><li>make help - 查看帮助信息</li></ul><p>有了 Makefile 的帮助， 很多事情变得简单起来了，<br>比如要生成证书文件， 只需要运行 <code>make ca</code> 就行了，<br>不用输入一大行命令了。</p><h3 id="总结">总结</h3><p>Makefile 是 linux 下常用的工具， 对于提升效率是非常有效的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> make </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花花与三猫CatLive-第三篇</title>
      <link href="/article/%E8%8A%B1%E8%8A%B1%E4%B8%8E%E4%B8%89%E7%8C%ABCatLive-%E7%AC%AC%E4%B8%89%E7%AF%87/"/>
      <url>/article/%E8%8A%B1%E8%8A%B1%E4%B8%8E%E4%B8%89%E7%8C%ABCatLive-%E7%AC%AC%E4%B8%89%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="带家里胆最大的猫咪出门以为可以遛弯儿结果怂成一团">带家里胆最大的猫咪出门，以为可以遛弯儿，结果怂成一团！</h2><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"video":{"url":"http://gslb.miaopai.com/stream/wssuU3yJrVOqvDLg3UursIbQ~jemHI8VtDNSBg__.mp4","pic":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1575045065&di=3a926764f3c280d97a71f67dbfa06ecb&imgtype=jpg&er=1&src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2F5ba90764c07e49e0315523ce4aafc580dbad2b1c.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      
      
        <tags>
            
            <tag> 猫咪 </tag>
            
            <tag> 短视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker搭建MongoDB环境</title>
      <link href="/article/Docker-%E6%90%AD%E5%BB%BAMongoDB%E7%8E%AF%E5%A2%83/"/>
      <url>/article/Docker-%E6%90%AD%E5%BB%BAMongoDB%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h3 id="从dockerhub下载mongodb官方镜像">从DockerHUB下载MongoDB官方镜像</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mongo</span><br></pre></td></tr></table></figure><h3 id="运行镜像生成容器">运行镜像生成容器</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">27017</span>:<span class="number">27017</span> --name mongo -v /home/data/db:/data/db -d mongo --auth</span><br><span class="line">-p <span class="number">27017</span>:<span class="number">27017</span> 端口映射</span><br><span class="line">-v /home/data/db:/data/db 通过卷挂载将MongoDB的数据存在宿主机的/home/data/db中</span><br><span class="line">-- auth 设置授权与鉴权</span><br></pre></td></tr></table></figure><h3 id="添加admin用户">添加admin用户</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mongo mongo admin</span><br></pre></td></tr></table></figure><h3 id="创建数据库">创建数据库</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&#123; user: <span class="string">'root'</span>, pwd: <span class="string">'password'</span>, roles: [ &#123; role: <span class="string">"userAdminAnyDatabase"</span>, db: <span class="string">"admin"</span> &#125; ] &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker教程</title>
      <link href="/article/Docker%E6%95%99%E7%A8%8B/"/>
      <url>/article/Docker%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="跟我学-docker企业级私有仓库-harbor十七完结篇">跟我学 Docker：企业级私有仓库 harbor（十七）完结篇</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F22%3Ft%3D1567387069929" target="_blank" rel="noopener">https://www.sudo.ren/article/22?t=1567387069929</a></p><h3 id="跟我学-docker跨主机容器间通信之-overlay十六">跟我学 Docker：跨主机容器间通信之 overlay（十六）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F21%3Ft%3D1567387061602" target="_blank" rel="noopener">https://www.sudo.ren/article/21?t=1567387061602</a></p><h3 id="跟我学-dockerdocker-跨主机通信之-macvlan十五">跟我学 Docker：docker 跨主机通信之 macvlan（十五）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F20%3Ft%3D1567387054474" target="_blank" rel="noopener">https://www.sudo.ren/article/20?t=1567387054474</a></p><h3 id="跟我学-docker容器的四种网络类型十四">跟我学 Docker：容器的四种网络类型（十四）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F19%3Ft%3D1567387044323" target="_blank" rel="noopener">https://www.sudo.ren/article/19?t=1567387044323</a></p><h3 id="跟我学-docker容器编排-docker-compose十三">跟我学 Docker：容器编排 docker-compose（十三）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F18%3Ft%3D1567387033915" target="_blank" rel="noopener">https://www.sudo.ren/article/18?t=1567387033915</a></p><h3 id="跟我学-dockerdocker-私有仓库-registry十二">跟我学 Docker：docker 私有仓库 registry（十二）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F17%3Ft%3D1567387025131" target="_blank" rel="noopener">https://www.sudo.ren/article/17?t=1567387025131</a></p><h3 id="跟我学-dockerdocker-容器间的互联和应用十一">跟我学 Docker：docker 容器间的互联和应用（十一）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F16%3Ft%3D1567387016458" target="_blank" rel="noopener">https://www.sudo.ren/article/16?t=1567387016458</a></p><h3 id="跟我学-dockerdocker-镜像的分层十">跟我学 Docker：docker 镜像的分层（十）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F15%3Ft%3D1567387003906" target="_blank" rel="noopener">https://www.sudo.ren/article/15?t=1567387003906</a></p><h3 id="跟我学-dockerdockerfile-自动构建私有云平台九">跟我学 Docker：dockerfile 自动构建私有云平台（九）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F14%3Ft%3D1567386989954" target="_blank" rel="noopener">https://www.sudo.ren/article/14?t=1567386989954</a></p><h3 id="跟我学-dockerdockerfile-自动构建镜像八">跟我学 Docker：dockerfile 自动构建镜像（八）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F13%3Ft%3D1567386976354" target="_blank" rel="noopener">https://www.sudo.ren/article/13?t=1567386976354</a></p><h3 id="跟我学-docker手动制作-docker-镜像七">跟我学 Docker：手动制作 docker 镜像（七）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F12%3Ft%3D1567386968066" target="_blank" rel="noopener">https://www.sudo.ren/article/12?t=1567386968066</a></p><h3 id="跟我学-dockerdocker-数据卷存储六">跟我学 Docker：docker 数据卷存储（六）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F11%3Ft%3D1567386957538" target="_blank" rel="noopener">https://www.sudo.ren/article/11?t=1567386957538</a></p><h3 id="跟我学-dockerdocker-的网络原理五">跟我学 Docker：docker 的网络原理（五）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F10%3Ft%3D1567386947466" target="_blank" rel="noopener">https://www.sudo.ren/article/10?t=1567386947466</a></p><h3 id="跟我学-dockerdocker-容器日常管理四">跟我学 Docker：docker 容器日常管理（四）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F9%3Ft%3D1567386936625" target="_blank" rel="noopener">https://www.sudo.ren/article/9?t=1567386936625</a></p><h3 id="跟我学-dockerdocker-镜像的常用命令三">跟我学 Docker：docker 镜像的常用命令（三）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F8%3Ft%3D1567386925401" target="_blank" rel="noopener">https://www.sudo.ren/article/8?t=1567386925401</a></p><h3 id="跟我学-docker启动第一个-docker-容器二">跟我学 Docker：启动第一个 docker 容器（二）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F7%3Ft%3D1567386909531" target="_blank" rel="noopener">https://www.sudo.ren/article/7?t=1567386909531</a></p><h3 id="跟我学-dockerdocker-的介绍和安装一">跟我学 Docker：docker 的介绍和安装（一）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F6%3Ft%3D1567386895266" target="_blank" rel="noopener">https://www.sudo.ren/article/6?t=1567386895266</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一张图告诉你, 科班程序员和自学编程的差别在哪 网友：真实！！</title>
      <link href="/article/%E4%B8%80%E5%BC%A0%E5%9B%BE%E5%91%8A%E8%AF%89%E4%BD%A0-%E7%A7%91%E7%8F%AD%E7%A8%8B%E5%BA%8F%E5%91%98%E5%92%8C-%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%88%AB%E5%9C%A8%E5%93%AA-%E7%BD%91%E5%8F%8B%EF%BC%9A%E7%9C%9F%E5%AE%9E%EF%BC%81%EF%BC%81/"/>
      <url>/article/%E4%B8%80%E5%BC%A0%E5%9B%BE%E5%91%8A%E8%AF%89%E4%BD%A0-%E7%A7%91%E7%8F%AD%E7%A8%8B%E5%BA%8F%E5%91%98%E5%92%8C-%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%88%AB%E5%9C%A8%E5%93%AA-%E7%BD%91%E5%8F%8B%EF%BC%9A%E7%9C%9F%E5%AE%9E%EF%BC%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>自学编程的程序员，似乎都处于轻视链的底端，而计算机专业的毕业生，似乎自然存在着一种自卑感。自学编程和科班程序员的差距，到底有多大？这也是行将“入坑”的编程喜好者，最关怀的一个问题。</p><h3 id="学问体系的差异">学问体系的差异</h3><p>科班出身的程序员，相关于自学编程者，具备愈加完善的学问体系，在实践工作中，能更快的构成完好的任职，从而更深化地处理问题。</p><p><img src="./img_1.png" alt=""></p><p>由于大学期间，曾经系统的学习了计算机学问，因而科班程序员的学问体系愈加完好，学起东西的速度也更快。</p><p>自学成才者，可能由于触及到本人未知的根底概念，而不得不先补根底，再学习。</p><p>那么，谁的代码写的更好呢？还真不一定！</p><h3 id="就业的区别">就业的区别</h3><p>关于 BAT 大厂而言，僧多粥少，为了降低用人风险，他们更倾向于招聘科班选手。</p><p>关于初创公司而言，我没有时间等你从一个理论型选手，生长为实战型选手，我更喜欢具有短平快的技术。</p><p><img src="./img_2.png" alt=""></p><p>索性，没有公司会仅仅看学历一个标签，代码 or 成果，这两个标签页非常重要。开源项目的掌管或参与，漂亮而充实的 GitHub 页面、优秀的 Top Coder，也会是很亮眼的标签。</p><p><img src="./img_3.png" alt=""></p><h3 id="具有资源的不同">具有资源的不同</h3><p>科班程序员就像是宠物饲养员，被狗狗熏着熏着，本人也会把本人想象成狗了。</p><p>自学成才的，自家里只养了条狗，需求更努力的与大咖们交流思想，才干把本人想象成狗。</p><p><img src="./img_4.png" alt=""></p><p>市场的需求量大增，编程入门门槛的降低，让无数自学编程的喜好者，涌入了这一行业，殊不知，若不时辰坚持学习心态，锐意进取，那么就会如马云那句名言：</p><p><img src="./img_5.png" alt=""></p><p>反之，关于科班程序员而言，就算是再牛，人之为学，不日进则日退，不过几年，也会泯然众人矣。</p><p>话说回来，到底科班程序员，和自学成才的人，有什么区别呢？一张图能够表达的明明白白。</p><p><img src="./img_6.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可以免费自学的10个编程网站</title>
      <link href="/article/%E5%8F%AF%E4%BB%A5%E5%85%8D%E8%B4%B9%E8%87%AA%E5%AD%A6%E7%9A%8410%E4%B8%AA%E7%BC%96%E7%A8%8B%E7%BD%91%E7%AB%99/"/>
      <url>/article/%E5%8F%AF%E4%BB%A5%E5%85%8D%E8%B4%B9%E8%87%AA%E5%AD%A6%E7%9A%8410%E4%B8%AA%E7%BC%96%E7%A8%8B%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p><img src="./header.jpeg" alt=""><br>编程学习,很多人包括一些企业家，和市场营销人员都认为学习编程对一个人走向成功十分有帮助。在过去的一年里，我一直在学习编程。它有助我成为一个更好的创业者，我甚至可以提供一些帮助，当我的团队需要解决一些 bug 的时候。</p><p>现在，如果你想学编程的话，这 10个网站可以帮助你，它们都提供了免费的课程供你学习，因此你无需担心费用的问题。</p><h2 id="codecademy"><a href="https://link.jianshu.com?t=http://www.codecademy.com/" target="_blank" rel="noopener">Codecademy</a></h2><p>其中，Codecademy 是最受欢迎的免费编程学习网站之一。事实上，已经有超过 2400 万人通过这家公司的教育模式学会了编程。Codecademy 开设的课程有 HTML&amp;CSS，JavaScript，jQuery 的，PHP，Python 和 Ruby。</p><h2 id="coursera"><a href="https://link.jianshu.com?t=https://www.coursera.org/courses?query=programming" target="_blank" rel="noopener">Coursera</a></h2><p>Coursera 成立于 2012 年，如今已经成长为一个主要以营利为目的的技术教育公司，现提供来自 119 家机构的超过 1000 门课程。如果你想要获得证书，可能需要为一定的课程付费，这里也有一些来自不同大学的免费编程课程，如华盛顿大学，斯坦福大学，多伦多大学和范德比尔特大学等。</p><h2 id="edx"><a href="https://link.jianshu.com?t=https://www.edx.org/" target="_blank" rel="noopener">edX</a></h2><p>edX 是另一个领先的在线学习平台，重点是它不是以营利为目的，而是开源的。edX 是由美国哈佛大学和麻省理工学院于 2012 年联合创办的，所以你将会在这里学习到先进的技术和理论。如今，edX 已涵盖了 60 所学校。此外在这里，你应该不会错过哈佛大学的计算机科学导论的，免费的哦。</p><h2 id="udemy"><a href="https://link.jianshu.com?t=https://www.udemy.com/" target="_blank" rel="noopener">Udemy</a></h2><p>Udemy 成立于 2010 年，是一个在线学习平台，可以帮助你改善或学习工作技能。虽然有部分课程需要付费，但也有大量的免费编程学习课程，通过视频讲授。</p><h2 id="agupieware"><a href="https://link.jianshu.com?t=http://blog.agupieware.com/2014/05/online-learning-bachelors-level.html" target="_blank" rel="noopener">aGupieWare</a></h2><p>一个独立 APP 开发者从美国的一些领先机构调查了计算机科学程序，然后基于斯坦福大学，麻省理工学院，卡耐基梅隆大学伯克利分校和哥伦比亚大学提供的免费课程，它创建了一个类似的课程。该程序分为 15 个课程：3 个入门课程，7 门核心课程和 5 个选修课程。</p><p>对有潜力的程序员来说，这简直是一个完美的入门程序。（本段感觉译的不是很好，有其他见解还请赐教~）</p><h2 id="github"><a href="https://link.jianshu.com?t=https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md#professional-development" target="_blank" rel="noopener">GitHub</a></h2><p>这个我想大多数开发者都知道就不多说了，作为开源代码库以及版本控制系统，Github 拥有 140 多万开发者用户。</p><h2 id="code-avengers"><a href="https://link.jianshu.com?t=https://www.codeavengers.com/" target="_blank" rel="noopener">Code Avengers</a></h2><p>Code Avengers 提供了很多有趣的和互动性的程序设计课程，教你如何编写游戏，应用程序，以及如何使用 JavaScript，HTML 和 CSS 创建网站。每门课程只需要 12 个小时即可完成，并且支持英语，俄语，荷兰语，西班牙语，意大利语，土耳其语和葡萄牙语。</p><h2 id="khan-academy"><a href="https://link.jianshu.com?t=https://www.khanacademy.org/" target="_blank" rel="noopener">Khan Academy</a></h2><p>Khan Academy 由教育家萨尔曼汗创建于 2006 年，是其免费在线学习机构之一。这里提供一步一步的视频教程，你可以在这里学习如何使用 JavaScript 和 ProcessingJS 编写动画，游戏等，或者学习如何使用 HTML 和 CSS 创建网页。</p><h2 id="free-code-camp"><a href="https://www.freecodecamp.cn/" target="_blank" rel="noopener">Free Code Camp</a></h2><p>在这里，你可以学习 HTML5，CSS3，JavaScript，数据库，DevTools，Node.js，Angular.js 和 Agile 的知识。你甚至免费创建自己的应用，以锻炼自己的编程技巧。总之，在这里你可以学习到真正的技能，并且对你解决实际中的问题十分有帮助。</p><h2 id="html5-rocks"><a href="https://www.html5rocks.com/en/" target="_blank" rel="noopener">HTML5 Rocks</a></h2><p>为对抗苹果的 HTML 5，谷歌于 2010 年推出该项目。该网站提供了大量的教程，资源以及最新的 HTML5 更新。它是开源的，因此开发人员可以尽情使用 HTML5 代码。由于这比大多数课程都要先进，因此在这里你肯定会比没来之前获得更多的知识和经验。</p><p>学习编程常常需要看一些比较昂贵的书籍和课程，但是现在由于互联网的发展，市场上有很多可以免费学习编程的网站，所以费用问题就不用太担心了。</p><p>我强烈建议每个企业家都能去学学代码，这对于你成为一个成功的企业家非常有帮助。</p><p>在 entrepreneur 看到这篇文章，也许会对大家有帮助，就拿来翻译一下，需要的朋友可以看一下。有不足之处还请指正，多谢。</p><blockquote><p>写在最最后</p></blockquote><p>本文为译文，所以文章里列举的学编程网站均是来自国外，可能对一些英文不是很好的小伙伴来说用起来有点儿吃力，其实国内也有一些编程学习网站，像网易云课堂、慕课网、极客学院等，大家可以参考一下。但是，如果英文不错的话，Aylee 还是建议大家多看看国外的网站，毕竟代码都是用英文写的吧是吧哈哈～开个玩笑啦～～总之，希望本文对大家会有所帮助吧。</p><hr><blockquote><p>转载于简书作者：Aylee姓Liu</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python解析pcap文件</title>
      <link href="/article/Python%E8%A7%A3%E6%9E%90pcap%E6%96%87%E4%BB%B6/"/>
      <url>/article/Python%E8%A7%A3%E6%9E%90pcap%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>需求：使用Python解析pcap数据包文件，获取基于TCP/IP的应用层协议类型。</p></blockquote><p>使用<font color="#dd0000"> dpkt </font>模块</p><h2 id="dpkt安装">dpkt安装</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install dpkt</span><br></pre></td></tr></table></figure><p>dpkt模块的使用方法，可以查看官网<a href="https://dpkt.readthedocs.io/en/latest/" target="_blank" rel="noopener">dpkt官网</a>。</p><h2 id="了解pcap数据包各层结构如下图所示">了解pcap数据包，各层结构，如下图所示：</h2><p><img src="./OSI.png" alt="alt tcp/ip" title="TCP/IP模型与OSI模型对比"><br>我们要做的就是通过解析，知道应用层是哪一种协议。</p><h2 id="代码实现">代码实现</h2><h3 id="pcap样本文件">pcap样本文件</h3><p>如下图所示：<br><img src="./pcap_tcp.png" alt="alt pcap" title="pcap样本截图"><br>里面有很多基于TCP/IP的协议，如SSH、SMTP和SMB等。</p><h3 id="读取pcap文件">读取pcap文件</h3><p>通过dpkt模块下的Reader()函数读取，并返回文件句柄对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pcap_obj</span><span class="params">(self)</span>:</span></span><br><span class="line">    f = open(self.file)</span><br><span class="line">    <span class="keyword">return</span> dpkt.pcap.Reader(f)</span><br></pre></td></tr></table></figure><h3 id="遍历解析">遍历解析</h3><p>逐层遍历，直到获取TCP层中应用层的数据（payload）, 并写入一个列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tcp_data</span><span class="params">(self)</span>:</span></span><br><span class="line">    pcap = self.get_pcap_obj()</span><br><span class="line">    <span class="keyword">for</span> timestamp, buf <span class="keyword">in</span> pcap:</span><br><span class="line">        <span class="comment"># 解析以太网层</span></span><br><span class="line">        eth = dpkt.ethernet.Ethernet(buf)</span><br><span class="line">        <span class="comment"># 判断是否为IP层，如果不是，下一次循环</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(eth.data, dpkt.ip.IP):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ip = eth.data</span><br><span class="line">        <span class="comment"># 过滤掉UDP</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(ip.data, dpkt.tcp.TCP):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        tcp = ip.data</span><br><span class="line">        self.data_list.append(tcp.data)</span><br><span class="line">    <span class="keyword">return</span> self.data_list</span><br></pre></td></tr></table></figure><h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dpkt</span><br><span class="line"></span><br><span class="line">file = <span class="string">'./base_protoall.pcap'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParsePcap</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pcap_file)</span>:</span></span><br><span class="line">        self.file = pcap_file</span><br><span class="line">        self.data_list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pcap_obj</span><span class="params">(self)</span>:</span></span><br><span class="line">        f = open(self.file)</span><br><span class="line">        <span class="keyword">return</span> dpkt.pcap.Reader(f)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_tcp_data</span><span class="params">(self)</span>:</span></span><br><span class="line">        pcap = self.get_pcap_obj()</span><br><span class="line">        <span class="keyword">for</span> timestamp, buf <span class="keyword">in</span> pcap:</span><br><span class="line">            <span class="comment"># 解析以太网层</span></span><br><span class="line">            eth = dpkt.ethernet.Ethernet(buf)</span><br><span class="line">            <span class="comment"># 判断是否为IP层，如果不是，下一次循环</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isinstance(eth.data, dpkt.ip.IP):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            ip = eth.data</span><br><span class="line">            <span class="comment"># 过滤掉UDP</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isinstance(ip.data, dpkt.tcp.TCP):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            tcp = ip.data</span><br><span class="line">            self.data_list.append(tcp.data)</span><br><span class="line">        <span class="keyword">return</span> self.data_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parse = ParsePcap(file)</span><br><span class="line">    data_list = parse.get_tcp_data()</span><br><span class="line">    <span class="keyword">for</span> tcp <span class="keyword">in</span> data_list:</span><br><span class="line">        <span class="keyword">print</span> tcp</span><br></pre></td></tr></table></figure><h3 id="运行结果">运行结果</h3><p><img src="./goland.png" alt="alt goland" title="运行截图"></p><p>与通过wireshark查看的payload数据是相同的。</p><p><img src="./wireshark.png" alt="alt wireshark" title="wireshark截图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dep使用</title>
      <link href="/article/dep%E4%BD%BF%E7%94%A8/"/>
      <url>/article/dep%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="dep简介">dep简介</h2><p><font color="#dd0000">dep</font>是一个golang项目的包管理工具，一般只需要2-3个命令就可以将go依赖包自动下载并归档到<font color="#dd0000">vender</font>的目录中。dep官网参考：<a href="https://github.com/golang/dep" target="_blank" rel="noopener">https://github.com/golang/dep</a></p><h2 id="dep安装">dep安装</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/golang/dep/cmd/dep</span><br></pre></td></tr></table></figure><h2 id="dep使用">dep使用</h2><h3 id="进入到项目目录">进入到项目目录</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/gopath/src/demo</span><br></pre></td></tr></table></figure><h3 id="dep初始化初始化配置文件gopkgtoml">dep初始化，初始化配置文件Gopkg.toml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep init</span><br></pre></td></tr></table></figure><h3 id="dep加载依赖包自动归档到vendor目录">dep加载依赖包，自动归档到vendor目录</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep ensure</span><br></pre></td></tr></table></figure><p>最终会生成vendor目录，Gopkg.toml和Gopkg.lock的文件</p><h2 id="dep的配置文件">dep的配置文件</h2><p><font color="#dd0000">Gopkg.toml</font>记录依赖包列表。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># Gopkg.toml example</span><br><span class="line">#</span><br><span class="line"># Refer to https:<span class="comment">//golang.github.io/dep/docs/Gopkg.toml.html</span></span><br><span class="line"># <span class="keyword">for</span> detailed Gopkg.toml documentation.</span><br><span class="line">#</span><br><span class="line"># required = [<span class="string">"github.com/user/thing/cmd/thing"</span>]</span><br><span class="line"># ignored = [<span class="string">"github.com/user/project/pkgX"</span>, <span class="string">"bitbucket.org/user/project/pkgA/pkgY"</span>]</span><br><span class="line">#</span><br><span class="line"># [[constraint]]</span><br><span class="line">#   name = <span class="string">"github.com/user/project"</span></span><br><span class="line">#   version = <span class="string">"1.0.0"</span></span><br><span class="line">#</span><br><span class="line"># [[constraint]]</span><br><span class="line">#   name = <span class="string">"github.com/user/project2"</span></span><br><span class="line">#   branch = <span class="string">"dev"</span></span><br><span class="line">#   source = <span class="string">"github.com/myfork/project2"</span></span><br><span class="line">#</span><br><span class="line"># [[override]]</span><br><span class="line">#   name = <span class="string">"github.com/x/y"</span></span><br><span class="line">#   version = <span class="string">"2.4.0"</span></span><br><span class="line">#</span><br><span class="line"># [prune]</span><br><span class="line">#   non-<span class="keyword">go</span> = <span class="literal">false</span></span><br><span class="line">#   <span class="keyword">go</span>-tests = <span class="literal">true</span></span><br><span class="line">#   unused-packages = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">ignored = [<span class="string">"demo"</span>]</span><br><span class="line"></span><br><span class="line">[[constraint]]</span><br><span class="line">  name = <span class="string">"github.com/BurntSushi/toml"</span></span><br><span class="line">  version = <span class="string">"0.3.0"</span></span><br><span class="line">  </span><br><span class="line">[prune]</span><br><span class="line">  <span class="keyword">go</span>-tests = <span class="literal">true</span></span><br><span class="line">  unused-packages = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="dep-help">dep-help</h2><p>更多<font color="#dd0000">dep</font>的命令帮助参考<font color="#dd0000">dep</font>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ dep</span><br><span class="line">Dep is a tool <span class="keyword">for</span> managing dependencies <span class="keyword">for</span> Go projects</span><br><span class="line"></span><br><span class="line">Usage: <span class="string">"dep [command]"</span></span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line"></span><br><span class="line">  init     Set up a <span class="built_in">new</span> Go project, or migrate an existing one</span><br><span class="line">  status   Report the status of the project<span class="string">'s dependencies</span></span><br><span class="line"><span class="string">  ensure   Ensure a dependency is safely vendored in the project</span></span><br><span class="line"><span class="string">  prune    Pruning is now performed automatically by dep ensure.</span></span><br><span class="line"><span class="string">  version  Show the dep version information</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Examples:</span></span><br><span class="line"><span class="string">  dep init                               set up a new project</span></span><br><span class="line"><span class="string">  dep ensure                             install the project'</span>s dependencies</span><br><span class="line">  dep ensure -update                     update the locked versions of all dependencies</span><br><span class="line">  dep ensure -add github.com/pkg/errors  add a dependency to the project</span><br><span class="line"></span><br><span class="line">Use <span class="string">"dep help [command]"</span> <span class="keyword">for</span> more information about a command.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> dep </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>etcd常用命令</title>
      <link href="/article/etcd%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/article/etcd%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="etcdctl介绍">etcdctl介绍</h2><hr><p>etcdctl是一个命令行的客户端，它提供了一下简洁的命令，可理解为命令工具集，可以方便我们在对服务进行测试或者手动修改数据库内容。etcdctl与其他xxxctl的命令原理及操作类似（例如kubectl，systemctl）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用法：etcdctl \[global options\] command \[command options\]\[args…\]</span><br></pre></td></tr></table></figure><h2 id="etcd常用命令">Etcd常用命令</h2><hr><h3 id="数据库操作命令">数据库操作命令</h3><p>etcd 在键的组织上采用了层次化的空间结构（类似于文件系统中目录的概念），数据库操作围绕对键值和目录的 CRUD [增删改查]（符合 REST 风格的一套操作：Create, Read, Update, Delete）完整生命周期的管理。</p><p>具体的命令选项参数可以通过 etcdctl command --help来获取相关帮助。</p><h4 id="对象为键值">对象为键值</h4><ul><li><p>set增无论是否存在etcdctl-set-key-value)set[增:无论是否存在]:etcdctl set key value</p></li><li><p>mk增必须不存在etcdctl-mk-key-value)mk[增:必须不存在]:etcdctl mk key value</p></li><li><p>rm删etcdctl-rm-key)rm[删]:etcdctl rm key</p></li><li><p>update改etcdctl-update-key-value)update[改]:etcdctl update key value</p></li><li><p>get查etcdctl-get-key)get[查]:etcdctl get key</p></li></ul><h4 id="对象为目录">对象为目录</h4><ul><li><p>setdir增无论是否存在etcdctl-setdir-dir)setdir[增:无论是否存在]:etcdctl setdir dir</p></li><li><p>mkdir增必须不存在-etcdctl-mkdir-dir)mkdir[增:必须不存在]: etcdctl mkdir dir</p></li><li><p>rmdir删etcdctl-rmdir-dir)rmdir[删]:etcdctl rmdir dir</p></li><li><p>updatedir改etcdctl-updatedir-dir)updatedir[改]:etcdctl updatedir dir</p></li><li><p>ls查etcdclt-ls)ls[查]:etcdclt ls</p></li></ul><h3 id="非数据库操作命令">非数据库操作命令</h3><ul><li>backup备份-etcd-的数据)backup[备份 etcd 的数据]</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl backup</span><br></pre></td></tr></table></figure><ul><li>watch监测一个键值的变化一旦键值发生更新就会输出最新的值并退出)watch[监测一个键值的变化，一旦键值发生更新，就会输出最新的值并退出]</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl watch key</span><br></pre></td></tr></table></figure><ul><li>exec-watch监测一个键值的变化一旦键值发生更新就执行给定命令)exec-watch[监测一个键值的变化，一旦键值发生更新，就执行给定命令]</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl <span class="built_in">exec</span>-watch key --sh -c “ls”</span><br></pre></td></tr></table></figure><ul><li>member通过-list-add-remove-update-命令列出-添加-删除-更新etcd-实例到-etcd-集群中)member[通过 list、add、remove、update 命令列出、添加、删除 、更新etcd 实例到 etcd 集群中]</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl member list；etcdctl member add 实例；etcdctl member remove 实例；etcdctl member update 实例。</span><br></pre></td></tr></table></figure><ul><li>etcdctl-cluster-health检查集群健康状态)etcdctl cluster-health[检查集群健康状态]</li></ul><h3 id="常用配置参数">常用配置参数</h3><p>设置配置文件，默认为/etc/etcd/etcd.conf。</p><table><thead><tr><th>配置参数</th><th>参数说明</th></tr></thead><tbody><tr><td>-name</td><td>节点名称</td></tr><tr><td>-data-dir</td><td>保存日志和快照的目录，默认为当前工作目录，指定节点的数据存储目录</td></tr><tr><td>-addr</td><td>公布的ip地址和端口。 默认为127.0.0.1:2379</td></tr><tr><td>-bind-addr</td><td>用于客户端连接的监听地址，默认为-addr配置</td></tr><tr><td>-peers</td><td>集群成员逗号分隔的列表，例如 127.0.0.1:2380,127.0.0.1:2381</td></tr><tr><td>-peer-addr</td><td>集群服务通讯的公布的IP地址，默认为 127.0.0.1:2380.</td></tr><tr><td>-peer-bind-addr</td><td>集群服务通讯的监听地址，默认为-peer-addr配置</td></tr><tr><td>-wal-dir</td><td>指定节点的was文件的存储目录，若指定了该参数，wal文件会和其他数据文件分开存储</td></tr><tr><td>-listen-client-urls</td><td>监听URL，用于与其他节点通讯</td></tr><tr><td>-listen-peer-urls</td><td>监听URL，用于与其他节点通讯</td></tr><tr><td>-initial-advertise-peer-urls</td><td>告知集群其他节点url.</td></tr><tr><td>-advertise-client-urls</td><td>告知客户端url, 也就是服务的url</td></tr><tr><td>-initial-cluster-token</td><td>集群的ID</td></tr><tr><td>-initial-cluster</td><td>集群中所有节点</td></tr><tr><td>-initial-cluster-state</td><td>-initial-cluster-state=new 表示从无到有搭建etcd集群</td></tr><tr><td>-discovery-srv</td><td>用于DNS动态服务发现，指定DNS SRV域名</td></tr><tr><td>-discovery</td><td>用于etcd动态发现，指定etcd发现服务的URL [<a href="https://discovery.etcd.io/" target="_blank" rel="noopener">https://discovery.etcd.io/</a>],用环境变量表示</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基于etcd实现分布式锁</title>
      <link href="/article/golang%E5%9F%BA%E4%BA%8Eetcd%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/article/golang%E5%9F%BA%E4%BA%8Eetcd%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>我们希望同一时间只有一个线程能够访问到资源，但是分布式资源点之间的协调会非常麻烦，这个时候我们就需要一个分布式锁。</p><h3 id="etcd分布式锁实现原理">etcd分布式锁实现原理：</h3><p>1.利用租约在etcd集群中创建一个key，这个key有两种形态，存在和不存在，而这两种形态就是互斥量。<br>2.如果这个key不存在，那么线程创建key，成功则获取到锁，该key就为存在状态。<br>3.如果该key已经存在，那么线程就不能创建key，则获取锁失败。</p><h3 id="锁结构体">锁结构体：</h3><p>在使用该锁时，需要传入Ttl,Conf,Key字段来初始化锁</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EtcdMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Ttl <span class="keyword">int64</span>  <span class="comment">//租约时间</span></span><br><span class="line">    Conf clientv3.Config  <span class="comment">//etcd集群配置</span></span><br><span class="line">    Key <span class="keyword">string</span>   <span class="comment">//etcd的key</span></span><br><span class="line">    cancel context.CancelFunc  <span class="comment">//关闭续租的func</span></span><br><span class="line">    lease clientv3.Lease</span><br><span class="line">    leaseID clientv3.LeaseID</span><br><span class="line">    txn clientv3.Txn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化锁">初始化锁：</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(em *EtcdMutex)</span><span class="title">init</span><span class="params">()</span><span class="title">error</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">var</span> ctx context.Context</span><br><span class="line">    client,err := clientv3.New(em.Conf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    em.txn = clientv3.NewKV(client).Txn(context.TODO())</span><br><span class="line">    em.lease = clientv3.NewLease(client)</span><br><span class="line">    leaseResp,err := em.lease.Grant(context.TODO(),em.Ttl)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    ctx,em.cancel = context.WithCancel(context.TODO())</span><br><span class="line">    em.leaseID = leaseResp.ID</span><br><span class="line">    _,err = em.lease.KeepAlive(ctx,em.leaseID)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取锁">获取锁:</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(em *EtcdMutex)</span><span class="title">Lock</span><span class="params">()</span><span class="title">error</span></span>&#123;</span><br><span class="line">    err := em.init()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//LOCK:</span></span><br><span class="line">        em.txn.If(clientv3.Compare(clientv3.CreateRevision(em.Key),<span class="string">"="</span>,<span class="number">0</span>)).</span><br><span class="line">            Then(clientv3.OpPut(em.Key,<span class="string">""</span>,clientv3.WithLease(em.leaseID))).</span><br><span class="line">            Else()</span><br><span class="line">    txnResp,err := em.txn.Commit()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !txnResp.Succeeded&#123;   <span class="comment">//判断txn.if条件是否成立</span></span><br><span class="line">        <span class="keyword">return</span> fmt.Errof(<span class="string">"抢锁失败"</span>)        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放锁">释放锁：</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(em *EtcdMutex)</span><span class="title">UnLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    em.cancel()</span><br><span class="line">    em.lease.Revoke(context.TODO(),em.leaseID)</span><br><span class="line">    fmt.Println(<span class="string">"释放了锁"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用锁">调用锁：</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> conf = clientv3.Config&#123;</span><br><span class="line">        Endpoints:   []<span class="keyword">string</span>&#123;<span class="string">"172.16.196.129:2380"</span>, <span class="string">"192.168.50.250:2380"</span>&#125;,</span><br><span class="line">        DialTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">    &#125;</span><br><span class="line">    eMutex1 := &amp;EtcdMutex&#123;</span><br><span class="line">        Conf:conf,</span><br><span class="line">        Ttl:<span class="number">10</span>,</span><br><span class="line">        Key:<span class="string">"lock"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">     eMutex2 := &amp;EtcdMutex&#123;</span><br><span class="line">        Conf:conf,</span><br><span class="line">        Ttl:<span class="number">10</span>,</span><br><span class="line">        Key:<span class="string">"lock"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//groutine1 </span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        err := eMutex1.Lock()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">            fmt.Println(<span class="string">"groutine1抢锁失败"</span>)</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"groutine1抢锁成功"</span>)</span><br><span class="line">        time.Sleep(<span class="number">10</span>*time.Second)</span><br><span class="line">        <span class="keyword">defer</span> eMutex.UnLock()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//groutine2</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        err := eMutex2.Lock()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">            fmt.Println(<span class="string">"groutine2抢锁失败"</span>)</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"groutine2抢锁成功"</span>)</span><br><span class="line">        <span class="keyword">defer</span> eMutex.UnLock()</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(<span class="number">30</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>etcd应用场景</title>
      <link href="/article/etcd%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/article/etcd%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>提到etcd很多人第一反应就是一个键值存储仓库。不过etcd官方文档的定义却是这样的：</p><blockquote><p>A highly-available key value store for shared configuration and service discovery.</p></blockquote><h4 id="包含了配置共享和服务发现">包含了配置共享和服务发现。</h4><p>etcd作为一个受到ZooKeeper与doozer启发而催生的项目，除了拥有与之类似的功能外，更专注于以下四点。</p><ul><li>简单：基于HTTP+JSON的API让你用curl就可以轻松使用。</li><li>安全：可选SSL客户认证机制。</li><li>快速：每个实例每秒支持一千次写操作。</li><li>可信：使用Raft算法充分实现了分布式。</li></ul><p>接下来将针对剖析一些etcd的经典使用场景，来看看etcd这个基于Raft强一致性算法的分布式存储仓库能给我们带来哪些帮助。</p><blockquote><p>值得注意的是，分布式系统中的数据分为控制数据和应用数据。使用etcd的场景默认处理的数据都是控制数据，对于应用数据，只推荐数据量很小，但是更新访问频繁的情况。</p></blockquote><h3 id="场景一服务发现">场景一：服务发现</h3><p>在分布式系统中“服务发现”也是比较常见的问题：在同一个集群环境中不同的应用或服务，如何能够找到对方并建立连接，来完成后续的行为。本质上来说，服务发现就是想要知道集群中是否有进程在监听udp或tcp端口，并能通过名字就可以查找和连接。而要解决服务发现的问题，需要满足如下三个方面，缺一不可。</p><ol><li>一个强一致性、高可用的服务存储目录： 基于Raft算法的etcd天生就是这样一个强一致性高可用的服务存储目录【安全的记录集群中的应用或服务的信息(地址、端口等)】。</li><li>一种注册服务和监控服务健康状态的机制：用户可以在etcd中注册服务，并且对注册的服务设置key TTL，定时保持服务的心跳以达到监控健康状态的效果。【能够完成新的应用或服务的注册添加进来，同样也能对现有的服务是否可用进行监控】</li><li>一种查找和连接服务的机制： 通过在etcd指定的主题下注册的服务也能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个Proxy模式的etcd，这样就可以确保能访问etcd集群的服务都能互相连接。【已有的服务当被使用能够被找到并能连接】</li></ol><p><img src="./%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.jpg" alt=""></p><p>来看服务发现对应的具体场景：</p><ul><li>微服务协同工作架构中，服务动态添加。随着Docker容器的流行，多种微服务共同协作，构成一个相对功能强大的架构的案例越来越多。透明化的动态添加这些服务的需求也日益强烈。通过服务发现机制，在etcd中注册某个服务名字的目录，在该目录下存储可用的服务节点的IP。在使用服务的过程中，只要从服务目录下查找可用的服务节点去使用即可。</li></ul><p><img src="./%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8D%8F%E5%90%8C.jpg" alt=""></p><ul><li>PaaS平台中应用多实例与实例故障重启透明化。PaaS平台中的应用一般都有多个实例，通过域名，不仅可以透明的对这多个实例进行访问，而且还可以做到负载均衡。但是应用的某个实例随时都有可能故障重启，这时就需要动态的配置域名解析（路由）中的信息。通过etcd的服务发现功能就可以轻松解决这个动态配置的问题。</li></ul><p><img src="./cloud.jpg" alt=""></p><h3 id="场景二消息发布与订阅">场景二：消息发布与订阅</h3><p>在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。通过这种方式可以做到分布式系统配置的集中式管理与动态更新。</p><ul><li>应用中用到的一些配置信息放到etcd上进行集中管理。这类场景的使用方式通常是这样：应用在启动的时候主动从etcd获取一次配置信息，同时，在etcd节点上注册一个Watcher并等待，以后每次配置有更新的时候，etcd都会实时通知订阅者，以此达到获取最新配置信息的目的。</li><li>分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在etcd中，供各个客户端订阅使用。使用etcd的key TTL功能可以确保机器状态是实时更新的。</li><li>分布式日志收集系统。这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用（或主题）来分配收集任务单元，因此可以在etcd上创建一个以应用（主题）命名的目录P，并将这个应用（主题相关）的所有机器ip，以子目录的形式存储到目录P上，然后设置一个etcd递归的Watcher，递归式的监控应用（主题）目录下所有信息的变动。这样就实现了机器IP（消息）变动的时候，能够实时通知到收集器调整任务分配。</li><li>系统中信息需要动态自动获取与人工干预修改信息请求内容的情况。通常是暴露出接口，例如JMX接口，来获取一些运行时的信息。引入etcd之后，就不用自己实现一套方案了，只要将这些信息存放到指定的etcd目录中即可，etcd的这些目录就可以通过HTTP的接口在外部访问。</li></ul><p><img src="./message.jpg" alt=""></p><h3 id="场景三负载均衡">场景三：负载均衡</h3><p>在场景一中也提到了负载均衡，本文所指的负载均衡均为软负载均衡。分布式系统中，为了保证服务的高可用以及数据的一致性，通常都会把数据和服务部署多份，以此达到对等服务，即使其中的某一个服务失效了，也不影响使用。由此带来的坏处是数据写入性能下降，而好处则是数据访问时的负载均衡。因为每个对等服务节点上都存有完整的数据，所以用户的访问流量就可以分流到不同的机器上。</p><ul><li>etcd本身分布式架构存储的信息访问支持负载均衡。etcd集群化以后，每个etcd的核心节点都可以处理用户的请求。所以，把数据量小但是访问频繁的消息数据直接存储到etcd中也是个不错的选择，如业务系统中常用的二级代码表（在表中存储代码，在etcd中存储代码所代表的具体含义，业务系统调用查表的过程，就需要查找表中代码的含义）。</li><li>利用etcd维护一个负载均衡节点表。etcd可以监控一个集群中多个节点的状态，当有一个请求发过来后，可以轮询式的把请求转发给存活着的多个状态。类似KafkaMQ，通过ZooKeeper来维护生产者和消费者的负载均衡。同样也可以用etcd来做ZooKeeper的工作。</li></ul><p><img src="./%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.jpg" alt=""></p><h3 id="场景四分布式通知与协调">场景四：分布式通知与协调</h3><p>这里说到的分布式通知与协调，与消息发布和订阅有些相似。都用到了etcd中的Watcher机制，通过注册与异步通知机制，实现分布式环境下不同系统之间的通知与协调，从而对数据变更做到实时处理。实现方式通常是这样：不同系统都在etcd上对同一个目录进行注册，同时设置Watcher观测该目录的变化（如果对子目录的变化也有需要，可以设置递归模式），当某个系统更新了etcd的目录，那么设置了Watcher的系统就会收到通知，并作出相应处理。</p><ul><li>通过etcd进行低耦合的心跳检测。检测系统和被检测系统通过etcd上某个目录关联而非直接关联起来，这样可以大大减少系统的耦合性。</li><li>通过etcd完成系统调度。某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了etcd上某些目录节点的状态，而etcd就把这些变化通知给注册了Watcher的推送系统客户端，推送系统再作出相应的推送任务。</li><li>通过etcd完成工作汇报。大部分类似的任务分发系统，子任务启动后，到etcd来注册一个临时工作目录，并且定时将自己的进度进行汇报（将进度写入到这个临时目录），这样任务管理者就能够实时知道任务进度。</li></ul><p><img src="./%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C.jpg" alt=""></p><h3 id="场景五分布式锁">场景五：分布式锁</h3><p>因为etcd使用Raft算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。</p><ul><li>保持独占即所有获取锁的用户最终只有一个可以得到。etcd为此提供了一套实现分布式锁原子操作CAS（CompareAndSwap）的API。通过设置prevExist值，可以保证在多个节点同时去创建某个目录时，只有一个成功。而创建成功的用户就可以认为是获得了锁。</li><li>控制时序，即所有想要获得锁的用户都会被安排执行，但是获得锁的顺序也是全局唯一的，同时决定了执行顺序。etcd为此也提供了一套API（自动创建有序键），对一个目录建值时指定为POST动作，这样etcd会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用API按顺序列出所有当前目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。</li></ul><p><img src="./%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.jpg" alt=""></p><h3 id="场景六分布式队列">场景六：分布式队列</h3><p>分布式队列的常规用法与场景五中所描述的分布式锁的控制时序用法类似，即创建一个先进先出的队列，保证顺序。</p><p>另一种比较有意思的实现是在保证队列达到某个条件时再统一按顺序执行。这种方法的实现可以在/queue这个目录中另外建立一个/queue/condition节点。</p><ul><li>condition可以表示队列大小。比如一个大的任务需要很多小任务就绪的情况下才能执行，每次有一个小任务就绪，就给这个condition数字加1，直到达到大任务规定的数字，再开始执行队列里的一系列小任务，最终执行大任务。</li><li>condition可以表示某个任务在不在队列。这个任务可以是所有排序任务的首个执行程序，也可以是拓扑结构中没有依赖的点。通常，必须执行这些任务后才能执行队列中的其他任务。</li><li>condition还可以表示其它的一类开始执行任务的通知。可以由控制程序指定，当condition出现变化时，开始执行队列任务。</li></ul><p><img src="./%E5%88%86%E5%B8%83%E5%BC%8F%E9%98%9F%E5%88%97.jpg" alt=""></p><h3 id="场景七集群监控与leader竞选">场景七：集群监控与Leader竞选</h3><p>通过etcd来进行监控实现起来非常简单并且实时性强。</p><ol><li>前面几个场景已经提到Watcher机制，当某个节点消失或有变动时，Watcher会第一时间发现并告知用户。</li><li>节点可以设置TTL key，比如每隔30s发送一次心跳使代表该机器存活的节点继续存在，否则节点消失。</li></ol><p>这样就可以第一时间检测到各节点的健康状态，以完成集群的监控要求。</p><p>另外，使用分布式锁，可以完成Leader竞选。这种场景通常是一些长时间CPU计算或者使用IO操作的机器，只需要竞选出的Leader计算或处理一次，就可以把结果复制给其他的Follower。从而避免重复劳动，节省计算资源。</p><p>这个的经典场景是搜索系统中建立全量索引。如果每个机器都进行一遍索引的建立，不但耗时而且建立索引的一致性不能保证。通过在etcd的CAS机制同时创建一个节点，创建成功的机器作为Leader，进行索引计算，然后把计算结果分发到其它节点。</p><p><img src="./leader.jpg" alt=""></p><h3 id="场景八为什么用etcd而不用zookeeper">场景八：为什么用etcd而不用ZooKeeper？</h3><p>etcd实现的这些功能，ZooKeeper都能实现。那么为什么要用etcd而非直接使用ZooKeeper呢？</p><p>相较之下，ZooKeeper有如下缺点：</p><ol><li>复杂。ZooKeeper的部署维护复杂，管理员需要掌握一系列的知识和技能；而Paxos强一致性算法也是素来以复杂难懂而闻名于世；另外，ZooKeeper的使用也比较复杂，需要安装客户端，官方只提供了Java和C两种语言的接口。</li><li>Java编写。这里不是对Java有偏见，而是Java本身就偏向于重型应用，它会引入大量的依赖。而运维人员则普遍希望保持强一致、高可用的机器集群尽可能简单，维护起来也不易出错。</li><li>发展缓慢。Apache基金会项目特有的<a href="http://www.infoworld.com/article/2612082/open-source-software/has-apache-lost-its-way-.html" target="_blank" rel="noopener">“Apache Way”</a>在开源界饱受争议，其中一大原因就是由于基金会庞大的结构以及松散的管理导致项目发展缓慢。</li></ol><p>而etcd作为一个后起之秀，其优点也很明显。</p><ol><li>简单。使用Go语言编写部署简单；使用HTTP作为接口使用简单；使用Raft算法保证强一致性让用户易于理解。</li><li>数据持久化。etcd默认数据一更新就进行持久化。</li><li>安全。etcd支持SSL客户端安全认证。</li></ol><p>最后，etcd作为一个年轻的项目，真正告诉迭代和开发中，这既是一个优点，也是一个缺点。优点是它的未来具有无限的可能性，缺点是无法得到大项目长时间使用的检验。然而，目前CoreOS、Kubernetes和CloudFoundry等知名项目均在生产环境中使用了etcd，所以总的来说，etcd值得你去尝试。</p><h2 id="后续etcd实现原理解读">后续：etcd实现原理解读</h2><h3 id="架构">架构</h3><p><img src="./etcd%E6%9E%B6%E6%9E%84.jpg" alt=""></p><p>从etcd的架构图中我们可以看到，etcd主要分为四个部分。</p><ul><li>HTTP Server： 用于处理用户发送的API请求以及其它etcd节点的同步与心跳信息请求。</li><li>Store：用于处理etcd支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是etcd对用户提供的大多数API功能的具体实现。</li><li>Raft：Raft强一致性算法的具体实现，是etcd的核心。</li><li>WAL：Write Ahead Log（预写式日志），是etcd的数据存储方式。除了在内存中存有所有数据的状态以及节点的索引以外，etcd就通过WAL进行持久化存储。WAL中，所有的数据提交前都会事先记录日志。Snapshot是为了防止数据过多而进行的状态快照；Entry表示存储的具体日志内容。</li></ul><p>通常，一个用户的请求发送过来，会经由HTTP Server转发给Store进行具体的事务处理，如果涉及到节点的修改，则交给Raft模块进行状态的变更、日志的记录，然后再同步给别的etcd节点以确认数据提交，最后进行数据的提交，再次同步。</p><h3 id="新版etcd重要变更列表">新版etcd重要变更列表</h3><ul><li>获得了IANA认证的端口，2379用于客户端通信，2380用于节点通信，与原先的（4001 peers / 7001 clients）共用。</li><li>每个节点可监听多个广播地址。监听的地址由原来的一个扩展到多个，用户可以根据需求实现更加复杂的集群环境，如一个是公网IP，一个是虚拟机（容器）之类的私有IP。</li><li>etcd可以代理访问leader节点的请求，所以如果你可以访问任何一个etcd节点，那么你就可以无视网络的拓扑结构对整个集群进行读写操作。</li><li>etcd集群和集群中的节点都有了自己独特的ID。这样就防止出现配置混淆，不是本集群的其他etcd节点发来的请求将被屏蔽。</li><li>etcd集群启动时的配置信息目前变为完全固定，这样有助于用户正确配置和启动。</li><li>运行时节点变化(Runtime Reconfiguration)。用户不需要重启 etcd 服务即可实现对 etcd 集群结构进行变更。启动后可以动态变更集群配置。</li><li>重新设计和实现了Raft算法，使得运行速度更快，更容易理解，包含更多测试代码。</li><li>Raft日志现在是严格的只能向后追加、预写式日志系统，并且在每条记录中都加入了CRC校验码。</li><li>启动时使用的_etcd/* 关键字不再暴露给用户</li><li>废弃集群自动调整功能的standby模式，这个功能使得用户维护集群更困难。</li><li>新增Proxy模式，不加入到etcd一致性集群中，纯粹进行代理转发。</li><li>ETCD_NAME（-name）参数目前是可选的，不再用于唯一标识一个节点。</li><li>摒弃通过配置文件配置 etcd 属性的方式，你可以用环境变量的方式代替。</li><li>通过自发现方式启动集群必须要提供集群大小，这样有助于用户确定集群实际启动的节点数量。</li></ul><h3 id="etcd概念词汇表">etcd概念词汇表</h3><ul><li>Raft：etcd所采用的保证分布式系统强一致性的算法。</li><li>Node：一个Raft状态机实例。</li><li>Member： 一个etcd实例。它管理着一个Node，并且可以为客户端请求提供服务。</li><li>Cluster：由多个Member构成可以协同工作的etcd集群。</li><li>Peer：对同一个etcd集群中另外一个Member的称呼。</li><li>Client： 向etcd集群发送HTTP请求的客户端。</li><li>WAL：预写式日志，etcd用于持久化存储的日志格式。</li><li>snapshot：etcd防止WAL文件过多而设置的快照，存储etcd数据状态。</li><li>Proxy：etcd的一种模式，为etcd集群提供反向代理服务。</li><li>Leader：Raft算法中通过竞选而产生的处理所有数据提交的节点。</li><li>Follower：竞选失败的节点作为Raft中的从属节点，为算法提供强一致性保证。</li><li>Candidate：当Follower超过一定时间接收不到Leader的心跳时转变为Candidate开始竞选。</li><li>Term：某个节点成为Leader到下一次竞选时间，称为一个Term。</li><li>Index：数据项编号。Raft中通过Term和Index来定位数据。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花花与三猫CatLive-第二篇</title>
      <link href="/article/%E8%8A%B1%E8%8A%B1%E4%B8%8E%E4%B8%89%E7%8C%ABCatLive-%E7%AC%AC%E4%BA%8C%E7%AF%87/"/>
      <url>/article/%E8%8A%B1%E8%8A%B1%E4%B8%8E%E4%B8%89%E7%8C%ABCatLive-%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="花花与三猫的养猫日常-给猫咪洗屁屁">花花与三猫的养猫日常 :给猫咪洗屁屁!</h2><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"theme":"#FADFA3","loop":true,"video":{"url":"https://vdse.bdstatic.com/c973beddb915910024b4ad72c7080474.mp4","pic":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1575045065&di=3a926764f3c280d97a71f67dbfa06ecb&imgtype=jpg&er=1&src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2F5ba90764c07e49e0315523ce4aafc580dbad2b1c.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      
      
        <tags>
            
            <tag> 猫咪 </tag>
            
            <tag> 短视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花花与三猫CatLive-第一篇</title>
      <link href="/article/%E8%8A%B1%E8%8A%B1%E4%B8%8E%E4%B8%89%E7%8C%ABCatLive/"/>
      <url>/article/%E8%8A%B1%E8%8A%B1%E4%B8%8E%E4%B8%89%E7%8C%ABCatLive/</url>
      
        <content type="html"><![CDATA[<h2 id="花花与三猫的养猫日常-橘猫吃播开始吃海鲜了">花花与三猫的养猫日常 :橘猫吃播开始吃海鲜了</h2><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"theme":"#FADFA3","loop":true,"video":{"url":"https://vdse.bdstatic.com/28fee90459ac36d58cbeaa01689a8354.mp4","pic":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1575045065&di=3a926764f3c280d97a71f67dbfa06ecb&imgtype=jpg&er=1&src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2F5ba90764c07e49e0315523ce4aafc580dbad2b1c.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      
      
        <tags>
            
            <tag> 猫咪 </tag>
            
            <tag> 短视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python与C混合编程遇到的问题</title>
      <link href="/article/Python%E4%B8%8EC%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/article/Python%E4%B8%8EC%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="相互调用的方式选择">相互调用的方式选择</h2><p>在做项目时，调研过两种方式：一是扩展Python ctypes 类型；二是引入Python开发文件实现Python的扩展。</p><h3 id="扩展-ctypes-类型">扩展 ctypes 类型</h3><p>项目中遇到的第一个需要扩展的地方是，C/C++项目中用了C++ stl::vector。问题来了，在Python 的 ctypes 中没相关类型的封装呀，于是第一时间想到的是扩展 ctypes 类型。可是在实现的时候才发现这种方式是有多麻烦。</p><h4 id="编写-c-gt-python-的接口文件">编写 c =&gt; python 的接口文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vectory_py.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">point_t</span>&gt;* new_vector()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">point_t</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">point_t</span>&gt;* v)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor called in C++ for "</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">vector_size</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">point_t</span>&gt;* v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v-&gt;size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">point_t</span> vector_get(<span class="built_in">vector</span>&lt;<span class="keyword">point_t</span>&gt;* v, <span class="keyword">int</span> i)&#123;</span><br><span class="line">        <span class="keyword">return</span> v-&gt;at(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">vector_push_back</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">point_t</span>&gt;* v, <span class="keyword">point_t</span> i)</span></span>&#123;</span><br><span class="line">        v-&gt;push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译： gcc -fPIC -shared -lpython3.6m -o vector_py.so vectory_py.c</p></blockquote><h4 id="编写-ctypes-类型文件">编写 ctypes 类型文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c_point_t</span><span class="params">(Structure)</span>:</span></span><br><span class="line">    _fields_ = [(<span class="string">"x"</span>, c_int), (<span class="string">"y"</span>, c_int)]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span><span class="params">(object)</span>:</span></span><br><span class="line">    lib = cdll.LoadLibrary(<span class="string">'./vector_py_lib.so'</span>) <span class="comment"># class level loading lib</span></span><br><span class="line">    lib.new_vector.restype = c_void_p</span><br><span class="line">    lib.new_vector.argtypes = []</span><br><span class="line">    lib.delete_vector.restype = <span class="keyword">None</span></span><br><span class="line">    lib.delete_vector.argtypes = [c_void_p]</span><br><span class="line">    lib.vector_size.restype = c_int</span><br><span class="line">    lib.vector_size.argtypes = [c_void_p]</span><br><span class="line">    lib.vector_get.restype = c_point_t</span><br><span class="line">    lib.vector_get.argtypes = [c_void_p, c_int]</span><br><span class="line">    lib.vector_push_back.restype = <span class="keyword">None</span></span><br><span class="line">    lib.vector_push_back.argtypes = [c_void_p, c_point_t]</span><br><span class="line">    lib.foo.restype = <span class="keyword">None</span></span><br><span class="line">    lib.foo.argtypes = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.vector = Vector.lib.new_vector()  <span class="comment"># pointer to new vector</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span>  <span class="comment"># when reference count hits 0 in Python,</span></span><br><span class="line">        Vector.lib.delete_vector(self.vector)  <span class="comment"># call C++ vector destructor</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Vector.lib.vector_size(self.vector)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, i)</span>:</span>  <span class="comment"># access elements in vector at index</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; len(self):</span><br><span class="line">            <span class="keyword">return</span> Vector.lib.vector_get(self.vector, c_int(i))</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">'Vector index out of range'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'[&#123;&#125;]'</span>.format(<span class="string">', '</span>.join(str(self[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self))))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, i)</span>:</span>  <span class="comment"># push calls vector's push_back</span></span><br><span class="line">        Vector.lib.vector_push_back(self.vector, i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span>  <span class="comment"># foo in Python calls foo in C++</span></span><br><span class="line">        Vector.lib.foo(self.vector)</span><br></pre></td></tr></table></figure><h4 id="然后才是调用">然后才是调用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> vector <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = Vector()</span><br><span class="line">b = c_point_t(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">a.push(b)</span><br><span class="line">a.foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)) :</span><br><span class="line">    print(a[i].x)</span><br><span class="line">    print(a[i].y)</span><br></pre></td></tr></table></figure><h3 id="为python写扩展">为Python写扩展</h3><p>完成上述的操作后，我头很大，很难想象当项目稍微修改后，我们要跟随变化的代码量有多大！于是换了一种思路，为Python写扩展。</p><h4 id="安装python开发包">安装Python开发包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y python36-devel</span><br></pre></td></tr></table></figure><h4 id="修改数据交互文件">修改数据交互文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;python3.6m/Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">PyObject* <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyObject* result = PyList_New(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">        PyObject* sub = PyList_New(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            PyList_Append(sub, Py_BuildValue(<span class="string">"&#123;s:i, s:i&#125;"</span>, <span class="string">"x"</span>, i, <span class="string">"y"</span>, <span class="number">100</span> - i));</span><br><span class="line">        &#125;</span><br><span class="line">        PyList_Append(result, sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用">调用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lib = cdll.LoadLibrary(<span class="string">'./extlist.so'</span>) <span class="comment"># class level loading lib</span></span><br><span class="line">lib.foo.restype = py_object</span><br><span class="line">b = lib.foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(b)) :</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(len(b[i])) :</span><br><span class="line">      d = b[i][j]</span><br><span class="line">      print(d[<span class="string">'x'</span>])</span><br></pre></td></tr></table></figure><p>很显然，第二种方式中，我已经封装了很复杂的结构了，如果用 c++ 来表示的话，将是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;point&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="遇到的问题">遇到的问题</h3><h3 id="python-c-混编时-segment">Python C 混编时 Segment</h3><p>这个问题困扰了我有一段时间，开始一直在纠结是代码哪错了，后来恍然大悟，Python 和 C 的堆栈是完全不同的，而当我在交互大量数据的时候，Python GC 可能会把 C 的内存当作未使用，直接给释放了(尤其是上述第二种方案)，这就是问题所在。(Python GC 中使用的代龄后续专门开文章来说明，欢迎关注公众号 cn_isnap)<br>这里的解决方案其实有很多，内存能撑过Python前两代的检查就可了，或者是纯C管理。在这里我推荐一种粗暴的解决方案：<br>对于任何调用Python对象或Python C API的C代码，确保你首先已经正确地获取和释放了GIL。 这可以用 PyGILState_Ensure() 和 PyGILState_Release() 来做到，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* Make sure we own the GIL */</span></span><br><span class="line">PyGILState_STATE state = PyGILState_Ensure();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use functions in the interpreter */</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* Restore previous GIL state and return */</span></span><br><span class="line">PyGILState_Release(state);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现C/C++与Python程序之间通信</title>
      <link href="/article/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0C-C-%E4%B8%8EPython%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%9F/"/>
      <url>/article/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0C-C-%E4%B8%8EPython%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>属于混合编程的问题。较全面的介绍一下，不仅限于题主提出的问题。<br>以下讨论中，Python指它的标准实现，即CPython（虽然不是很严格）</p><h2 id="本文结构">本文结构</h2><ul><li>C/C++ 调用 Python （基础篇）— 仅讨论Python官方提供的实现方式</li><li>Python 调用 C/C++ （基础篇）— 仅讨论Python官方提供的实现方式</li><li>C/C++ 调用 Python （高级篇）— 使用 Cython</li><li>Python 调用 C/C++ （高级篇）— 使用 SWIG</li></ul><p>练习本文中的例子，需要搭建Python扩展开发环境。具体细节见<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fzhuanlan.zhihu.com%2Fpython-dev%2F20150730" target="_blank" rel="noopener">搭建Python扩展开发环境 - 蛇之魅惑 - 知乎专栏</a></p><h2 id="cc-调用-python基础篇">C/C++ 调用 Python（基础篇）</h2><p>Python 本身就是一个C库。你所看到的可执行体python只不过是个stub。真正的python实体在动态链接库里实现，在Windows平台上，这个文件位于 %SystemRoot%\System32\python27.dll。</p><p>你也可以在自己的程序中调用Python，看起来非常容易：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//my_python.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Py_SetProgramName(argv[<span class="number">0</span>]);</span><br><span class="line">  Py_Initialize();</span><br><span class="line">  PyRun_SimpleString(<span class="string">"print 'Hello Python!'\n"</span>);</span><br><span class="line">  Py_Finalize();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Windows平台下，打开Visual Studio命令提示符，编译命令为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl my_python.c -IC:\Python27\include C:\Python27\libs\python27.lib</span><br></pre></td></tr></table></figure><p>在Linux下编译命令为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc my_python.c -o my_python -I/usr/include/python2<span class="number">.7</span>/ -lpython2<span class="number">.7</span></span><br></pre></td></tr></table></figure><p>在Mac OS X 下的编译命令同上</p><p>产生可执行文件后，直接运行，结果为输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Python!</span><br></pre></td></tr></table></figure><p>Python库函数PyRun_SimpleString可以执行字符串形式的Python代码。</p><p>虽然非常简单，但这段代码除了能用C语言动态生成一些Python代码之外，并没有什么用处。我们需要的是C语言的数据结构能够和Python交互。</p><p>下面举个例子，比如说，有一天我们用Python写了一个功能特别强大的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">great_function</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>接下来要把它包装成C语言的函数。我们期待的C语言的对应函数应该是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">great_function_from_python</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res; </span><br><span class="line">    <span class="comment">// some magic</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，复用Python模块得做‘import’，这里也不例外。所以我们把great_function放到一个module里，比如说，这个module名字叫 great_module.py</p><p>接下来就要用C来调用Python了，完整的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">great_function_from_python</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    PyObject *pModule,*pFunc;</span><br><span class="line">    PyObject *pArgs, *pValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* import */</span></span><br><span class="line">    pModule = PyImport_Import(PyString_FromString(<span class="string">"great_module"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* great_module.great_function */</span></span><br><span class="line">    pFunc = PyObject_GetAttrString(pModule, <span class="string">"great_function"</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* build args */</span></span><br><span class="line">    pArgs = PyTuple_New(<span class="number">1</span>);</span><br><span class="line">    PyTuple_SetItem(pArgs,<span class="number">0</span>, PyInt_FromLong(a));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call */</span></span><br><span class="line">    pValue = PyObject_CallObject(pFunc, pArgs);</span><br><span class="line"></span><br><span class="line">    res = PyInt_AsLong(pValue);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可以窥见Python内部运行的方式：</p><ul><li>所有Python元素，module、function、tuple、string等等，实际上都是PyObject。C语言里操纵它们，一律使用PyObject *。</li><li>Python的类型与C语言类型可以相互转换。Python类型XXX转换为C语言类型YYY要使用PyXXX_AsYYY函数；C类型YYY转换为Python类型XXX要使用PyXXX_FromYYY函数。</li><li>也可以创建Python类型的变量，使用PyXXX_New可以创建类型为XXX的变量。</li><li>若a是Tuple，则a[i] = b对应于 PyTuple_SetItem(a,i,b)，有理由相信还有一个函数PyTuple_GetItem完成取得某一项的值。</li><li>不仅Python语言很优雅，Python的库函数API也非常优雅。</li></ul><p>现在我们得到了一个C语言的函数了，可以写一个main测试它</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">great_function_from_python</span><span class="params">(<span class="keyword">int</span> a)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Py_Initialize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,great_function_from_python(<span class="number">2</span>));</span><br><span class="line">    Py_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译的方式就用本节开头使用的方法。</p><p>在Linux/Mac OSX运行此示例之前，可能先需要设置环境变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bash:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> PYTHONPATH=.:$PYTHONPATH</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">csh:</span><br><span class="line"></span><br><span class="line">    setenv PYTHONPATH .:$PYTHONPATH</span><br></pre></td></tr></table></figure><h2 id="python-调用-cc基础篇">Python 调用 C/C++（基础篇）</h2><p>这种做法称为Python扩展。<br>比如说，我们有一个功能强大的C函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">great_function</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>期望在Python里这样使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> great_module <span class="keyword">import</span> great_function </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>great_function(<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>考虑最简单的情况。我们把功能强大的函数放入C文件 great_module.c 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">great_function</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject * _great_function(PyObject *self, PyObject *args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">"i"</span>, &amp;_a))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    res = great_function(_a);</span><br><span class="line">    <span class="keyword">return</span> PyLong_FromLong(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyMethodDef GreateModuleMethods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"great_function"</span>,</span><br><span class="line">        _great_function,</span><br><span class="line">        METH_VARARGS,</span><br><span class="line">        <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">PyMODINIT_FUNC <span class="title">initgreat_module</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) Py_InitModule(<span class="string">"great_module"</span>, GreateModuleMethods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了功能强大的函数great_function外，这个文件中还有以下部分：</p><ul><li>包裹函数_great_function。它负责将Python的参数转化为C的参数（PyArg_ParseTuple），调用实际的great_function，并处理great_function的返回值，最终返回给Python环境。</li><li>导出表GreateModuleMethods。它负责告诉Python这个模块里有哪些函数可以被Python调用。导出表的名字可以随便起，每一项有4个参数：第一个参数是提供给Python环境的函数名称，第二个参数是_great_function，即包裹函数。第三个参数的含义是参数变长，第四个参数是一个说明性的字符串。导出表总是以{NULL, NULL, 0, NULL}结束。</li><li>导出函数initgreat_module。这个的名字不是任取的，是你的module名称添加前缀init。导出函数中将模块名称与导出表进行连接。</li></ul><p>在Windows下面，在Visual Studio命令提示符下编译这个文件的命令是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /LD great_module.c /o great_module.pyd -IC:\Python27\include C:\Python27\libs\python27.lib</span><br></pre></td></tr></table></figure><p>/LD 即生成动态链接库。编译成功后在当前目录可以得到 great_module.pyd（实际上是dll）。这个pyd可以在Python环境下直接当作module使用。</p><p>在Linux下面，则用gcc编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared great_module.c -o great_module.so -I/usr/include/python2.7/ -lpython2.7</span><br></pre></td></tr></table></figure><p>在当前目录下得到great_module.so，同理可以在Python中直接使用。</p><p><strong>本部分参考资料</strong></p><ul><li>《Python源码剖析-深度探索动态语言核心技术》是系统介绍CPython实现以及运行原理的优秀教程。</li><li>Python 官方文档的这一章详细介绍了C/C++与Python的双向互动<a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdocs.python.org%2F2%2Fextending%2Findex.html%2523extending-index" target="_blank" rel="noopener">Extending and Embedding the Python Interpreter</a></li><li>关于编译环境，本文所述方法仅为出示原理所用。规范的方式如下：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdocs.python.org%2F2%2Fextending%2Fbuilding.html%2523building" target="_blank" rel="noopener">3. Building C and C++ Extensions with distutils</a></li><li>作为字典使用的官方参考文档 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdocs.python.org%2F2%2Fc-api%2Findex.html%2523c-api-index" target="_blank" rel="noopener">Python/C API Reference Manual</a></li></ul><p>用以上的方法实现C/C++与Python的混合编程，需要对Python的内部实现有相当的了解。接下来介绍当前较为成熟的技术Cython和SWIG。</p><h2 id="cc-调用-python使用cython">C/C++ 调用 Python（使用Cython）</h2><p>在前面的小节中谈到，Python的数据类型和C的数据类型貌似是有某种“一一对应”的关系的，此外，由于Python（确切的说是CPython）本身是由C语言实现的，故Python数据类型之间的函数运算也必然与C语言有对应关系。那么，有没有可能“自动”的做替换，把Python代码直接变成C代码呢？答案是肯定的，这就是Cython主要解决的问题。</p><p>安装Cython非常简单。Python 2.7.9以上的版本已经自带easy_install：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install -U cython</span><br></pre></td></tr></table></figure><p>在Windows环境下依然需要Visual Studio，由于安装的过程需要编译Cython的源代码，故上述命令需要在Visual Studio命令提示符下完成。一会儿使用Cython的时候，也需要在Visual Studio命令提示符下进行操作，这一点和第一部分的要求是一样的。</p><p>继续以例子说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#great_module.pyx</span><br><span class="line">cdef public great_function(a,index):</span><br><span class="line">    <span class="keyword">return</span> a[index]</span><br></pre></td></tr></table></figure><p>这其中有非Python关键字cdef和public。这些关键字属于Cython。由于我们需要在C语言中使用“编译好的Python代码”，所以得让great_function从外面变得可见，方法就是以“public”修饰。而cdef类似于Python的def，只有使用cdef才可以使用Cython的关键字public。</p><p>这个函数中其他的部分与正常的Python代码是一样的。</p><p>接下来编译 great_module.pyx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cython great_module.pyx</span><br></pre></td></tr></table></figure><p>得到great_module.h和great_module.c。打开great_module.h可以找到这样一句声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__PYX_EXTERN_C DL_IMPORT(PyObject) *great_function(PyObject *, PyObject *)</span><br></pre></td></tr></table></figure><p>写一个main使用great_function。注意great_function并不规定a是何种类型，它的功能只是提取a的第index的成员而已，故使用great_function的时候，a可以传入Python String，也可以传入tuple之类的其他可迭代类型。仍然使用之前提到的类型转换函数PyXXX_FromYYY和PyXXX_AsYYY。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"great_module.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    PyObject *tuple;</span><br><span class="line">    Py_Initialize();</span><br><span class="line">    initgreat_module();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,PyString_AsString(</span><br><span class="line">                great_function(</span><br><span class="line">                    PyString_FromString(<span class="string">"hello"</span>),</span><br><span class="line">                    PyInt_FromLong(<span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            ));</span><br><span class="line">    tuple = Py_BuildValue(<span class="string">"(iis)"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">"three"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,PyInt_AsLong(</span><br><span class="line">                great_function(</span><br><span class="line">                    tuple,</span><br><span class="line">                    PyInt_FromLong(<span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            ));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,PyString_AsString(</span><br><span class="line">                great_function(</span><br><span class="line">                    tuple,</span><br><span class="line">                    PyInt_FromLong(<span class="number">2</span>)</span><br><span class="line">                )</span><br><span class="line">            ));</span><br><span class="line">    Py_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译命令和第一部分相同：<br>在Windows下编译命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl main.c great_module.c -IC:\Python27\include C:\Python27\libs\python27.lib</span><br></pre></td></tr></table></figure><p>在Linux下编译命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c great_module.c -o main -I/usr/include/python2.7/ -lpython2.7</span><br></pre></td></tr></table></figure><p>这个例子中我们使用了Python的动态类型特性。如果你想指定类型，可以利用Cython的静态类型关键字。例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#great_module.pyx</span><br><span class="line">cdef public char great_function(const char * a,int index):</span><br><span class="line">    <span class="keyword">return</span> a[index]</span><br></pre></td></tr></table></figure><p>cython编译后得到的.h里，great_function的声明是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">PYX_EXTERN_C <span class="title">DL_IMPORT</span><span class="params">(<span class="keyword">char</span>)</span> <span class="title">great_function</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>很开心对不对！<br>这样的话，我们的main函数已经几乎看不到Python的痕迹了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"great_module.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Py_Initialize();</span><br><span class="line">    initgreat_module();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,great_function(<span class="string">"Hello"</span>,<span class="number">2</span>));</span><br><span class="line">    Py_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这一部分的最后我们给一个看似实用的应用（仅限于Windows）：<br>还是利用刚才的great_module.pyx，准备一个dllmain.c：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"great_module.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> __declspec(dllexport) <span class="keyword">int</span> __stdcall _great_function(<span class="keyword">const</span> <span class="keyword">char</span> * a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> great_function(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL,DWORD fdwReason,LPVOID lpReserved)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>( fdwReason ) &#123; </span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">            Py_Initialize();</span><br><span class="line">            initgreat_module();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">            Py_Finalize();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Visual Studio命令提示符下编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /LD dllmain.c great_module.c -IC:\Python27\include C:\Python27\libs\python27.lib</span><br></pre></td></tr></table></figure><p>会得到一个dllmain.dll。我们在Excel里面使用它，没错，传说中的<strong>Excel与Python混合编程</strong>：</p><p><noscript><img data-rawheight="797" data-rawwidth="1007" src="https://pic2.zhimg.com/50/2f45c9f2f8407d46f51f203efc2e8181\_hd.jpg" class="origin\_image zh-lightbox-thumb" width="1007" data-original="https://pic2.zhimg.com/2f45c9f2f8407d46f51f203efc2e8181_r.jpg"></noscript></p><p><img src="//upload-images.jianshu.io/upload_images/12778909-433d2ab7e4a6af72.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/720/format/webp" alt=""></p><p>参考资料：Cython的官方文档，质量非常高：<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2Fdocs.cython.org%2Findex.html" target="_blank" rel="noopener">Welcome to Cython’s Documentation</a></p><h2 id="python调用cc使用swig">Python调用C/C++（使用SWIG）</h2><p>用C/C++对脚本语言的功能扩展是非常常见的事情，Python也不例外。除了SWIG，市面上还有若干用于Python扩展的工具包，比较知名的还有Boost.Python、SIP等，此外，Cython由于可以直接集成C/C++代码，并方便的生成Python模块，故也可以完成扩展Python的任务。</p><p>答主在这里选用SWIG的一个重要原因是，它不仅可以用于Python，也可以用于其他语言。如今SWIG已经支持C/C++的好基友Java，主流脚本语言Python、Perl、Ruby、PHP、JavaScript、tcl、Lua，还有Go、C#，以及R。SWIG是基于配置的，也就是说，原则上一套配置改变不同的编译方法就能适用各种语言（当然，这是理想情况了……）</p><p>SWIG的安装方便，有Windows的预编译包，解压即用，绿色健康。主流Linux通常集成swig的包，也可以下载源代码自己编译，SWIG非常小巧，通常安装不会出什么问题。</p><p>用SWIG扩展Python，你需要有一个待扩展的C/C++库。这个库有可能是你自己写的，也有可能是某个项目提供的。这里举一个不浮夸的例子：希望在Python中用到SSE4指令集的CRC32指令。</p><p>首先打开指令集的文档：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fsoftware.intel.com%2Fen-us%2Fnode%2F514245" target="_blank" rel="noopener">https://software.intel.com/en-us/node/514245</a><br>可以看到有6个函数。分析6个函数的原型，其参数和返回值都是简单的整数。于是书写SWIG的配置文件（为了简化起见，未包含2个64位函数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File: mymodule.i */</span></span><br><span class="line">%<span class="keyword">module</span> mymodule</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nmmintrin.h"</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _mm_popcnt_u32(<span class="keyword">unsigned</span> <span class="keyword">int</span> v);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> _mm_crc32_u8 (<span class="keyword">unsigned</span> <span class="keyword">int</span> crc, <span class="keyword">unsigned</span> <span class="keyword">char</span> v);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> _mm_crc32_u16(<span class="keyword">unsigned</span> <span class="keyword">int</span> crc, <span class="keyword">unsigned</span> <span class="keyword">short</span> v);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> _mm_crc32_u32(<span class="keyword">unsigned</span> <span class="keyword">int</span> crc, <span class="keyword">unsigned</span> <span class="keyword">int</span> v);</span><br></pre></td></tr></table></figure><p>接下来使用SWIG将这个配置文件编译为所谓Python Module Wrapper</p><pre><code>swig -python mymodule.i</code></pre><p>得到一个 mymodule_wrap.c和一个mymodule.py。把它编译为Python扩展：</p><p>Windows：</p><pre><code>cl /LD mymodule_wrap.c /o _mymodule.pyd -IC:\Python27\include C:\Python27\libs\python27.lib</code></pre><p>Linux：</p><pre><code>gcc -fPIC -shared mymodule_wrap.c -o _mymodule.so -I/usr/include/python2.7/ -lpython2.7</code></pre><p>注意输出文件名前面要加一个下划线。<br>现在可以立即在Python下使用这个module了：</p><pre><code>&gt;&gt;&gt; import mymodule&gt;&gt;&gt; mymodule._mm_popcnt_u32(10)2</code></pre><p>回顾这个配置文件分为3个部分：</p><ul><li>定义module名称mymodule，通常，module名称要和文件名保持一致。</li><li>%{ %} 包裹的部分是C语言的代码，这段代码会原封不动的复制到mymodule_wrap.c</li><li>欲导出的函数签名列表。直接从头文件里复制过来即可。</li></ul><p>还记得本文第2节的那个great_function吗？有了SWIG，事情就会变得如此简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* great_module.i */</span></span><br><span class="line">%<span class="keyword">module</span> great_module</span><br><span class="line">%&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">great_function</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">great_function</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure><p>换句话说，SWIG自动完成了诸如Python类型转换、module初始化、导出代码表生成的诸多工作。</p><p>对于C++，SWIG也可以应对。例如以下代码有C++类的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//great_class.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GREAT_CLASS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREAT_CLASS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Great</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setWall</span> <span class="params">(<span class="keyword">int</span> _s)</span> </span>&#123;s = _s;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getWall</span> <span class="params">()</span> </span>&#123;<span class="keyword">return</span> s;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GREAT_CLASS</span></span></span><br></pre></td></tr></table></figure><p>对应的SWIG配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* great_class.i */</span><br><span class="line">%module great_class</span><br><span class="line">%&#123;</span><br><span class="line">#include &quot;great_class.h&quot;</span><br><span class="line">%&#125;</span><br><span class="line">%include &quot;great_class.h&quot;</span><br></pre></td></tr></table></figure><p>这里不再重新敲一遍class的定义了，直接使用SWIG的%include指令</p><p>SWIG编译时要加-c++这个选项，生成的扩展名为cxx</p><pre><code>swig -c++ -python great_class.i</code></pre><p>Windows下编译：</p><pre><code>cl /LD great_class_wrap.cxx /o _great_class.pyd -IC:\Python27\include C:\Python27\libs\python27.lib</code></pre><p>Linux，使用C++的编译器</p><pre><code>g++ -fPIC -shared great_class_wrap.cxx -o _great_class.so  -I/usr/include/python2.7/ -lpython2.7</code></pre><p>在Python交互模式下测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> great_class</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = great_class.Great()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.setWall(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.getWall()</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>也就是说C++的class会直接映射到Python class</p><p>SWIG非常强大，对于Python接口而言，简单类型，甚至指针，都无需人工干涉即可自动转换，而复杂类型，尤其是自定义类型，SWIG提供了typemap供转换。而一旦使用了typemap，配置文件将不再在各个语言当中通用。</p><p><strong>参考资料：</strong><br>SWIG的官方文档，质量比较高。<a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2Fwww.swig.org%2FDoc3.0%2FContents.html%2523Contents" target="_blank" rel="noopener">SWIG Users Manual</a><br>有个对应的中文版官网，很多年没有更新了。</p><h2 id="写在最后">写在最后</h2><p>由于CPython自身的结构设计合理，使得Python的C/C++扩展非常容易。如果打算快速完成任务，Cython（C/C++调用Python）和SWIG（Python调用C/C++）是很不错的选择。但是，一旦涉及到比较复杂的转换任务，无论是继续使用Cython还是SWIG，仍然需要学习Python源代码。</p><p>本文使用的开发环境：<br>Python 2.7.10<br>Cython 0.22<br>SWIG 3.0.6<br>Windows 10 x64 RTM<br>CentOS 7.1 AMD 64<br>Mac OSX 10.10.4<br>文中所述原理与具体环境适用性强。<br>文章所述代码均用于演示，缺乏必备的异常检查## 目标</p><p>去除 iconfinder 上 icon 的水印</p><h2 id="原理">原理</h2><p>利用水印像素点和原图像素点颜色合并的原理，如果拥有加过水印的图片和水印图片，就可以反向推出原图原像素点的颜色；前提是你得拥有他的水印图片</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang方法</title>
      <link href="/article/golang%E6%96%B9%E6%B3%95/"/>
      <url>/article/golang%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="golang中的方法">Golang中的方法</h1><p>Golang允许用户定义类型，比如常见的结构体就属于用户定义的结构类型。方法可以给用户定义的类型添加新的行为，方法其实是一种特殊的函数，与函数的区别在于声明的时候在关键字func和函数名之间增加了一个参数。为了更好的理解方法的概念，我们先来看一段代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个user类型</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用值接收者实现一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Sending User Email To %s&lt;%s&gt;\n"</span>, u.name, u.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针接收者实现一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">changeEmail</span><span class="params">(email <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    u.email = email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// user类型的值可以用来调用使用值接收者声明的方法</span></span><br><span class="line">    tracy := user&#123;<span class="string">"Tracy"</span>, <span class="string">"tracy.qq.com"</span>&#125;</span><br><span class="line">    tracy.notify()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向user类型值的指针也可以调用使用值接收者声明的方法</span></span><br><span class="line">    kobe := &amp;user&#123;<span class="string">"Kobe"</span>, <span class="string">"kobe.qq.com"</span>&#125;</span><br><span class="line">    kobe.notify()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// user类型的值可以用来调用使用指针接收者声明的方法</span></span><br><span class="line">    tracy.changeEmail(<span class="string">"guoguo.qq.com"</span>)</span><br><span class="line">    tracy.notify()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向user类型值的指针也可以调用使用指针接收者声明的方法</span></span><br><span class="line">    kobe.changeEmail(<span class="string">"xiaobudian.qq.com"</span>)</span><br><span class="line">    kobe.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出结果如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sending User Email To Tracy&lt;tracy.qq.com&gt;</span><br><span class="line">Sending User Email To Kobe&lt;kobe.qq.com&gt;</span><br><span class="line">Sending User Email To Tracy&lt;guoguo.qq.com&gt;</span><br><span class="line">Sending User Email To Kobe&lt;xiaobudian.qq.com&gt;</span><br></pre></td></tr></table></figure><h2 id="值接收者和指针接收者">值接收者和指针接收者</h2><p>除了两者声明方法时候形式不同外，本质的区别在哪里呢？下面我们通过分析main函数中四段调用来理解两者的含义：</p><h3 id="1-类型的值调用使用值接收者声明的方法">1、类型的值调用使用值接收者声明的方法</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user类型的值可以用来调用使用值接收者声明的方法</span></span><br><span class="line">    tracy := user&#123;<span class="string">"Tracy"</span>, <span class="string">"tracy.qq.com"</span>&#125;</span><br><span class="line">    tracy.notify()</span><br></pre></td></tr></table></figure><p>这里我们声明并初始化了一个user类型的变量“tracy”，然后这个变量使用了值接收者声明的方法，即使用tracy的值作为接收者进行调用，此时方法notify()会接收到tracy的一个副本，这就是值接收者。</p><h3 id="2-类型的指针调用使用值接收者声明的方法">2、类型的指针调用使用值接收者声明的方法</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向user类型值的指针也可以调用使用值接收者声明的方法</span></span><br><span class="line">    kobe := &amp;user&#123;<span class="string">"Kobe"</span>, <span class="string">"kobe.qq.com"</span>&#125;</span><br><span class="line">    kobe.notify()</span><br></pre></td></tr></table></figure><p>在这里我们声明了一个名为kobe的指针变量，并给user结构初始化。接着，我们用这个指针变量调用了notify方法，为什么指针接收者可以调用使用值接收者声明的方法呢？其实，为了支持这种调用，Golang调整了指针的值，我们可以认为上面指针变量调用notify方法是执行了下面这种操作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*kobe).notify()</span><br></pre></td></tr></table></figure><p>我们发现，这不是指针解引用吗？没错，是的，指针变量被解引用为值时，这不就符合了值接收者的要求了吗。所以，也就是说指针变量调用使用值接收者声明的方法是合法的，并且其实就是使用类型的值来调用使用值接收者声明的方法。当然，这是Golang编译器背后做的事情。</p><blockquote><p>需要注意的是，此时notify()操作的仍然是值的一个副本，只不过这次操作的副本是kobe指针指向的值的一个副本！</p></blockquote><h3 id="3-类型的值调用使用指针接收者声明的方法">3、类型的值调用使用指针接收者声明的方法</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user类型的值可以用来调用使用指针接收者声明的方法</span></span><br><span class="line">    tracy.changeEmail(<span class="string">"guoguo.qq.com"</span>)</span><br><span class="line">    tracy.notify()</span><br></pre></td></tr></table></figure><p>既然类型的指针变量可以调用使用值接收者声明的方法，那么类型的值可以调用使用指针接收者声明的方法吗？答案是可以的。Golang编译器同样为我们调整了值，即上面的tracy.notify()实际上是执行了如下操作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&amp;tracy).notify()</span><br></pre></td></tr></table></figure><p>这样就符合了指针接收者的要求了。</p><h3 id="4-类型的指针调用使用指针接收者声明的方法">4、类型的指针调用使用指针接收者声明的方法</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向user类型值的指针也可以调用使用指针接收者声明的方法</span></span><br><span class="line">    kobe.changeEmail(<span class="string">"xiaobudian.qq.com"</span>)</span><br><span class="line">    kobe.notify()</span><br></pre></td></tr></table></figure><p>从代码中我们看到，指向user类型的指针调用了使用指针接收者声明的方法，这里操作的是实际值，并不是副本，并且在调用的方法里对值的修改对于调用者而言是可见的。也就是说，kobe.notify()调用完成之后，<a href="http://xn--emailxiaobudian-n53x05shu1dqi0bsd1aod1k.qq.com" target="_blank" rel="noopener">email字段被修改为xiaobudian.qq.com</a>，此时在main函数中如果打印kobe.email，那么这个结果应该是被修改后的结果。</p><p>讲到这里，大家应该懂了值接收者和指针接收者的区别了吧？</p><h2 id="值接收者和指针接收者区别">值接收者和指针接收者区别</h2><p>最重要的一点是值接收者使用值的副本来调用方法，而指针接受者使用实际值来调用方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Golang监控你的程序</title>
      <link href="/article/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Golang%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>/article/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Golang%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前记">前记</h2><p>你是如何使用 Golang 日志监控你的应用程序的呢？Golang 没有异常，只有错误。因此你的第一印象可能就是开发 Golang 日志策略并不是一件简单的事情。不支持异常事实上并不是什么问题，异常在很多编程语言中已经失去了其异常性：它们过于被滥用以至于它们的作用都被忽视了。<br>在进一步深入之前，我们首先会介绍 Golang 日志的基础，并讨论 Golang 日志标准、元数据意义、以及最小化 Golang 日志对性能的影响。通过日志，你可以追踪用户在你应用中的活动，快速识别你项目中失效的组件，并监控总体性能以及用户体验。</p><h2 id="golang日志基础">Golang日志基础</h2><h3 id="使用golang中log包">使用Golang中“log”包</h3><p>Golang 给你提供了一个称为 “log” 的原生日志库。它的日志器完美适用于追踪简单的活动，例如通过使用可用的选项在错误信息之前添加一个时间戳。</p><p>下面是一个 Golang 中如何记录错误日志的简单例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span>  </span><br><span class="line">    <span class="string">"errors"</span>   </span><br><span class="line">    <span class="string">"fmt"</span>    </span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 除法函数，除以 0 的时候会返回错误 */</span></span><br><span class="line">    ret,err = div(a, b)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; </span><br><span class="line">        log.Fatal(err)   </span><br><span class="line">    &#125;    </span><br><span class="line">    fmt.Println(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你尝试除以 0，你就会得到类似下面的结果：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>/<span class="number">08</span>/<span class="number">01</span> <span class="number">13</span>:<span class="number">38</span>:<span class="number">17</span> You cannot divide by <span class="number">0.</span></span><br><span class="line">exit status <span class="number">1</span></span><br></pre></td></tr></table></figure><p>为了快速测试一个 Golang 函数，你可以使用go playground。</p><p>为了确保你的日志总是能轻易访问，我们建议你把它们写到一个文件：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 按照所需读写权限创建文件</span></span><br><span class="line">    f, err := os.OpenFile(<span class="string">"filename"</span>, os.O_WRONLY|os.O_CREATE|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成后延迟关闭，而不是习惯!</span></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="comment">//设置日志输出到 f</span></span><br><span class="line">    log.SetOutput(f)</span><br><span class="line">    <span class="comment">//测试用例</span></span><br><span class="line">    log.Println(<span class="string">"check to make sure it works"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以找到 Golang 日志的完整指南，以及 “log”库内可用函数的完整列表。<br>现在你就可以记录它们的错误以及根本原因啦。<br>另外，日志也可以帮你将活动流拼接在一起，查找需要修复的错误上下文，或者调查在你的系统中单个请求如何影响其它应用层和 API。<br>为了获得更好的日志效果，你首先需要在你的项目中使用尽可能多的上下文丰富你的 Golang 日志，并标准化你使用的格式。这就是 Golang 原生库能达到的极限。使用最广泛的库是glog和logrus。必须承认还有很多好的库可以使用。如果你已经在使用支持 JSON 格式的库，你就不需要再换其它库了，后面我们会解释。</p><h2 id="为你golang日志统一格式">为你Golang日志统一格式</h2><h3 id="json格式的结构优势">JSON格式的结构优势</h3><p>在一个项目或者多个微服务中结构化你的 Golang 日志可能是最困难的事情，但一旦完成就很轻松了。结构化你的日志能使机器可读（参考我们收集日志的最佳实践博文）。灵活性和层级是 JSON 格式的核心，因此信息能够轻易被人类和机器解析以及处理。<br>下面是一个使用Logrus/Logmatic.io如何用 JSON 格式记录日志的例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    log <span class="string">"github.com/Sirupsen/logrus"</span></span><br><span class="line">    <span class="string">"github.com/logmatic/logmatic-go"</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用 JSONFormatter</span></span><br><span class="line">    log.SetFormatter(&amp;logmatic.JSONFormatter&#123;&#125;)</span><br><span class="line">    <span class="comment">// 使用 logrus 像往常那样记录事件</span></span><br><span class="line">    log.WithFields(log.Fields&#123;<span class="string">"string"</span>: <span class="string">"foo"</span>, <span class="string">"int"</span>: <span class="number">1</span>, <span class="string">"float"</span>: <span class="number">1.1</span>&#125;).Info(<span class="string">"My first ssl event from golang"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会输出结果：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;   </span><br><span class="line">    <span class="string">"date"</span>:<span class="string">"2016-05-09T10:56:00+02:00"</span>,</span><br><span class="line">    <span class="string">"float"</span>:<span class="number">1.1</span>,</span><br><span class="line">    <span class="string">"int"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">"level"</span>:<span class="string">"info"</span>,</span><br><span class="line">    <span class="string">"message"</span>:<span class="string">"My first ssl event from golang"</span>,</span><br><span class="line">    <span class="string">"String"</span>:<span class="string">"foo"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准化golang日志">标准化Golang日志</h3><p>同一个错误出现在你代码的不同部分，却以不同形式被记录下来是一件可耻的事情。下面是一个由于一个变量错误导致无法确定 web 页面加载状态的例子。一个开发者日志格式是：</p><pre><code>message: 'unknown error: cannot determine loading status from unknown error: missing or invalid arg value client'</code></pre><p>另一个人的格式却是：</p><pre><code>unknown error: cannot determine loading status - invalid client</code></pre><p>强制日志标准化的一个好的解决办法是在你的代码和日志库之间创建一个接口。这个标准化接口会包括所有你想添加到你日志中的可能行为的预定义日志消息。这么做可以防止出现不符合你想要的标准格式的自定义日志信息。这么做也便于日志调查。<br><img src="http://i1.fuimg.com/699606/2efd60ed21e0ba60.png" alt="流程图"></p><p>由于日志格式都被统一处理，使它们保持更新也变得更加简单。如果出现了一种新的错误类型，它只需要被添加到一个接口，这样每个组员都会使用完全相同的信息。<br>最常使用的简单例子就是在 Golang 日志信息前面添加日志器名称和 id。你的代码然后就会发送 “事件” 到你的标准化接口，它会继续讲它们转化为 Golang 日志消息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要部分，我们会在这里定义所有消息。</span></span><br><span class="line"><span class="comment">// Event 结构体很简单。为了当所有信息都被记录时能检索它们，</span></span><br><span class="line"><span class="comment">// 我们维护了一个 Id</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    invalidArgMessage = Event&#123;<span class="number">1</span>, <span class="string">"Invalid arg: %s"</span>&#125;</span><br><span class="line">    invalidArgValueMessage = Event&#123;<span class="number">2</span>, <span class="string">"Invalid arg value: %s =&gt; %v"</span>&#125;</span><br><span class="line">    missingArgMessage = Event&#123;<span class="number">3</span>, <span class="string">"Missing arg: %s"</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在我们应用程序中可以使用的所有日志事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span><span class="title">InvalidArg</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    l.entry.Errorf(invalidArgMessage.toString(), name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span><span class="title">InvalidArgValue</span><span class="params">(name <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    l.entry.WithField(<span class="string">"arg."</span> + name, </span><br><span class="line">    value).Errorf(invalidArgValueMessage.toString(), name, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span><span class="title">MissingArg</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    l.entry.Errorf(missingArgMessage.toString(), name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此如果我们使用前面例子中无效的参数值，我们就会得到相似的日志信息：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time=<span class="string">"2017-02-24T23:12:31+01:00"</span> </span><br><span class="line">level=error </span><br><span class="line">msg=<span class="string">"LoadPageLogger00003 - Missing arg: client - cannot determine loading status"</span> </span><br><span class="line">arg.client=&lt;<span class="literal">nil</span>&gt; logger.name=LoadPageLogger</span><br></pre></td></tr></table></figure><p>Json格式如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"arg.client"</span>:null,<span class="string">"level"</span>:<span class="string">"error"</span>,<span class="string">"logger.name"</span>:<span class="string">"LoadPageLogger"</span>,<span class="string">"msg"</span>:<span class="string">"LoadPageLogger00003 - Missing arg: client - cannot determine loading status"</span>, <span class="string">"time"</span>:<span class="string">"2017-02-24T23:14:28+01:00"</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="golang日志上下文的力量">Golang日志上下文的力量</h3><p>现在 Golang 日志已经按照特定结构和标准格式记录，时间会决定需要添加哪些上下文以及相关信息。为了能从你的日志中抽取信息，例如追踪一个用户活动或者工作流，上下文和元数据的顺序非常重要。</p><p>例如在 logrus 库中可以按照下面这样使用 JSON 格式添加hostname、appname和session 参数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于元数据，通常做法是通过复用来重用日志语句中的字段。</span></span><br><span class="line">contextualizedLog := log.WithFields(log.Fields&#123;</span><br><span class="line">    <span class="string">"hostname"</span>: <span class="string">"staging-1"</span>,</span><br><span class="line">    <span class="string">"appname"</span>: <span class="string">"foo-app"</span>,</span><br><span class="line">    <span class="string">"session"</span>: <span class="string">"1ce3f6v"</span></span><br><span class="line">&#125;)</span><br><span class="line">contextualizedLog.Info(<span class="string">"Simple event with global metadata"</span>)</span><br></pre></td></tr></table></figure><p>元数据可以视为 javascript 片段。为了更好地说明它们有多么重要，让我们看看几个 Golang 微服务中元数据的使用。你会清楚地看到是怎么在你的应用程序中跟踪用户的。这是因为你不仅需要知道一个错误发生了，还要知道是哪个实例以及什么模式导致了错误。假设我们有两个按顺序调用的微服务。上下文信息保存在头部（header）中传输：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloMicroService1</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line">    <span class="comment">// 该服务负责接收所有到来的用户请求</span></span><br><span class="line">    <span class="comment">// 我们会检查是否是一个新的会话还是已有会话的另一次调用</span></span><br><span class="line">    session := r.Header.Get(<span class="string">"x-session"</span>)</span><br><span class="line">    <span class="keyword">if</span> ( session == <span class="string">""</span>) &#123;</span><br><span class="line">        session = generateSessionId()</span><br><span class="line">        <span class="comment">// 为新会话记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 每个请求的 Track Id 都是唯一的，因此我们会为每个会话生成一个</span></span><br><span class="line">   track := generateTrackId()</span><br><span class="line">   <span class="comment">// 调用你的第二个微服务，添加 session/track</span></span><br><span class="line">   reqService2, _ := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://localhost:8082/"</span>, <span class="literal">nil</span>)</span><br><span class="line">   reqService2.Header.Add(<span class="string">"x-session"</span>, session)</span><br><span class="line">   reqService2.Header.Add(<span class="string">"x-track"</span>, track)</span><br><span class="line">   resService2, _ := client.Do(reqService2)</span><br></pre></td></tr></table></figure><p>当调用第二个服务时：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">helloMicroService2</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">     <span class="comment">// 类似之前的微服务，我们检查会话并生成新的 track</span></span><br><span class="line">     session := r.Header.Get(<span class="string">"x-session"</span>)</span><br><span class="line">     track := generateTrackId()</span><br><span class="line">     <span class="comment">// 这一次，我们检查请求中是否已经设置了一个 track id，</span></span><br><span class="line">     <span class="comment">// 如果是，它变为父 track</span></span><br><span class="line">     parent := r.Header.Get(<span class="string">"x-track"</span>)</span><br><span class="line">     <span class="keyword">if</span> (session == <span class="string">""</span>) &#123;</span><br><span class="line">         w.Header().Set(<span class="string">"x-parent"</span>, parent)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 为响应添加 meta 信息</span></span><br><span class="line">     w.Header().Set(<span class="string">"x-session"</span>, session)</span><br><span class="line">     w.Header().Set(<span class="string">"x-track"</span>, track)</span><br><span class="line">     <span class="keyword">if</span> (parent == <span class="string">""</span>) &#123;</span><br><span class="line">         w.Header().Set(<span class="string">"x-parent"</span>, track)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 填充响应</span></span><br><span class="line">     w.WriteHeader(http.StatusOK)</span><br><span class="line">     io.WriteString(w, fmt.Sprintf(aResponseMessage, <span class="number">2</span>, session, track, parent))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在第二个微服务中已经有和初始查询相关的上下文和信息，一个 JSON 格式的日志消息看起来类似如下。</p><p>在第一个微服务：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"appname"</span>:<span class="string">"go-logging"</span>,<span class="string">"level"</span>:<span class="string">"debug"</span>,<span class="string">"msg"</span>:<span class="string">"hello from ms 1"</span>,<span class="string">"session"</span>:<span class="string">"eUBrVfdw"</span>,<span class="string">"time"</span>:<span class="string">"2017-03-02T15:29:26+01:00"</span>,<span class="string">"track"</span>:<span class="string">"UzWHRihF"</span>&#125;</span><br></pre></td></tr></table></figure><p>在第二个微服务：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"appname"</span>:<span class="string">"go-logging"</span>,<span class="string">"level"</span>:<span class="string">"debug"</span>,<span class="string">"msg"</span>:<span class="string">"hello from ms 2"</span>,<span class="string">"parent"</span>:<span class="string">"UzWHRihF"</span>,<span class="string">"session"</span>:<span class="string">"eUBrVfdw"</span>,<span class="string">"time"</span>:<span class="string">"2017-03-02T15:29:26+01:00"</span>,<span class="string">"track"</span>:<span class="string">"DPRHBMuE"</span>&#125;</span><br></pre></td></tr></table></figure><p>如果在第二个微服务中出现了错误，多亏了 Golang 日志中保存的上下文信息，现在我们就可以确定它是怎样被调用的以及什么模式导致了这个错误。</p><h2 id="golang日志对性能的影响">Golang日志对性能的影响</h2><h3 id="不要在goroutine中使用日志">不要在Goroutine中使用日志</h3><p>在每个 goroutine 中创建一个新的日志器看起来很诱人。但最好别这么做。Goroutine 是一个轻量级线程管理器，它用于完成一个 “简单的” 任务。因此它不应该负责日志。它可能导致并发问题，因为在每个 goroutine 中使用</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.New()</span><br></pre></td></tr></table></figure><p>会重复接口，所有日志器会并发尝试访问同一个 io.Writer。为了限制对性能的影响以及避免并发调用 io.Writer，库通常使用一个特定的 goroutine 用于日志输出。</p><h3 id="使用异步库">使用异步库</h3><p>尽管有很多可用的 Golang 日志库，要注意它们中的大部分都是同步的（事实上是伪异步）。原因很可能是到现在为止它们中没有一个会由于日志严重影响性能。<br>但正如 Kjell Hedström 在他的实验中展示的，使用多个线程创建成千上万日志，即便是在最坏情况下，异步 Golang 日志也会有 40% 的性能提升。因此日志是有开销的，也会对你的应用程序性能产生影响。如果你并不需要处理大量的日志，使用伪异步 Golang 日志库可能就足够了。但如果你需要处理大量的日志，或者很关注性能，Kjell Hedström 的异步解决方案就很有趣（尽管事实上你可能需要进一步开发，因为它只包括了最小的功能需求）。</p><h3 id="使用严重等级管理golang日志">使用严重等级管理Golang日志</h3><p>一些日志库允许你启用或停用特定的日志器，这可能会派上用场。例如在生产环境中你可能不需要一些特定等级的日志。下面是一个如何在 glog 库中停用日志器的例子，其中日志器被定义为布尔值：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Log <span class="keyword">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Log)</span> <span class="title">Println</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Println(args...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> debug Log = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">    debug.Println(<span class="string">"DEBUGGING"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你就可以在配置文件中定义这些布尔参数来启用或者停用日志器。<br>没有一个好的 Golang 日志策略，Golang 日志可能开销很大。开发人员应该抵制记录几乎所有事情的诱惑 - 尽管它非常有趣！如果日志的目的是为了获取尽可能多的信息，为了避免包含无用元素的日志的白噪音，必须正确使用日志。</p><h2 id="希望你享受你的-golang-日志之旅">希望你享受你的 Golang 日志之旅</h2><p>在你项目一开始就考虑你的 Golang 日志策略非常重要。如果在你代码的任意地方都可以获得所有的上下文，追踪用户就会变得很简单。从不同服务中阅读没有标准化的日志是已经很痛苦的事情。一开始就计划在多个微服务中扩展相同用户或请求 id，后面就会允许你比较容易地过滤信息并在你的系统中跟踪活动。<br>你是在构架一个很大的 Golang 项目还是几个微服务也会影响你的日志策略。一个大项目的主要组件应该有按照它们功能命名的特定 Golang 日志器。这使你可以立即判断出日志来自你的哪一部分代码。然而对于微服务或者小的 Golang 项目，只有较少的核心组件需要它们自己的日志器。但在每种情形中，日志器的数目都应该保持低于核心功能的数目。<br>你现在已经可以使用 Golang 日志量化决定你的性能或者用户满意度啦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
