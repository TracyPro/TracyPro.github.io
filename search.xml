<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go语言常见数据结构实现原理之chan</title>
      <link href="/article/Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Bchan/"/>
      <url>/article/Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Bchan/</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>channel是Golang在语言层面提供的goroutine间的通信方式，比Unix管道更易用也更轻便。channel主要用于进程内各goroutine间通信，如果需要跨进程通信，建议使用分布式系统的方法来解决。本文从源码角度分析channel的实现机制。</p><h3 id="chan数据结构">chan数据结构</h3><p>src/runtime/chan.go:hchan定义了channel的数据结构：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// 当前队列中剩余元素个数</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// 环形队列长度，即可以存放的元素个数</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 环形队列指针</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span>         <span class="comment">// 每个元素的大小</span></span><br><span class="line">    closed   <span class="keyword">uint32</span>            <span class="comment">// 标识关闭状态</span></span><br><span class="line">    elemtype *_type         <span class="comment">// 元素类型</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>           <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>           <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">    recvq    waitq          <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">    sendq    waitq          <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line">    lock mutex              <span class="comment">// 互斥锁，chan不允许并发读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数据结构可以看出channel由队列、类型信息、goroutine等待队列组成，下面分别说明其原理。</p><h4 id="环形队列">环形队列</h4><p>chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的。下图展示了一个可缓存6个元素的channel示意图：<br><img src="./img_1.png" alt=""></p><ul><li>dataqsiz指示了队列长度为6，即可缓存6个元素；</li><li>buf指向队列的内存，队列中还剩余两个元素；</li><li>qcount表示队列中还有两个元素；</li><li>sendx指示后续写入的数据存储的位置，取值[0, 6)；</li><li>recvx指示从该位置读取数据, 取值[0, 6)；</li></ul><h4 id="等待队列">等待队列</h4><p>从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。 向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。被阻塞的goroutine将会挂在channel的等待队列中：</p><ul><li>因读阻塞的goroutine会被向channel写入数据的goroutine唤醒；</li><li>因写阻塞的goroutine会被从channel读数据的goroutine唤醒；</li></ul><p>下图展示了一个没有缓冲区的channel，有几个goroutine阻塞等待读数据：<br><img src="./img_2.png" alt=""></p><blockquote><p>注意，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。</p></blockquote><h4 id="类型信息">类型信息</h4><p>一个channel只能传递一种类型的值，类型信息存储在hchan数据结构中。</p><ul><li>elemtype代表类型，用于数据传递过程中的赋值；</li><li>elemsize代表类型大小，用于在buf中定位元素位置。</li></ul><h4 id="锁">锁</h4><p>一个channel同时仅允许被一个goroutine读写，为简单起见，本章后续部分说明读写过程时不再涉及加锁和解锁。</p><h3 id="channel读写">channel读写</h3><h4 id="创建channel">创建channel</h4><p>创建channel的过程实际上是初始化hchan结构。其中类型信息和缓冲区长度由make语句传入，buf的大小则与元素大小和缓冲区长度共同决定。</p><p>创建channel的伪代码如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    c = <span class="built_in">new</span>(hchan)</span><br><span class="line">    c.buf = malloc(元素类型大小*size)</span><br><span class="line">    c.elemsize = 元素类型大小</span><br><span class="line">    c.elemtype = 元素类型</span><br><span class="line">    c.dataqsiz = size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向channel写数据">向channel写数据</h4><p>向一个channel中写数据简单过程如下：</p><ol><li>如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程；</li><li>如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程；</li><li>如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒；</li></ol><p>简单流程图如下：<br><img src="./img_3.png" alt=""></p><h4 id="从channel读数据">从channel读数据</h4><p>从一个channel读数据简单过程如下：</p><ol><li>如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；</li><li>如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；</li><li>如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；</li><li>将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；</li></ol><p>简单流程图如下：<br><img src="./img_4.png" alt=""></p><h4 id="关闭channel">关闭channel</h4><p>关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。</p><p>除此之外，panic出现的常见场景还有：</p><ol><li>关闭值为nil的channel</li><li>关闭已经被关闭的channel</li><li>向已经关闭的channel写数据</li></ol><h3 id="常见用法">常见用法</h3><h4 id="单向channel">单向channel</h4><p>顾名思义，单向channel指只能用于发送或接收数据，实际上也没有单向channel。</p><p>我们知道channel可以通过参数传递，所谓单向channel只是对channel的一种使用限制，这跟C语言使用const修饰函数参数为只读是一个道理。</p><ul><li>func readChan(chanName &lt;-chan int)： 通过形参限定函数内部只能从channel中读取数据</li><li>func writeChan(chanName chan&lt;- int)： 通过形参限定函数内部只能向channel中写入数据</li></ul><p>一个简单的示例程序如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readChan</span><span class="params">(chanName &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    &lt;- chanName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeChan</span><span class="params">(chanName <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    chanName &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mychan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    writeChan(mychan)</span><br><span class="line">    readChan(mychan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mychan是个正常的channel，而readChan()参数限制了传入的channel只能用来读，writeChan()参数限制了传入的channel只能用来写。</p><h4 id="select">select</h4><p>使用select可以监控多channel，比如监控多个channel，当其中某一个channel有数据时，就从其读出数据。</p><p>一个简单的示例程序如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNumberToChan</span><span class="params">(chanName <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        chanName &lt;- <span class="number">1</span></span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> chan1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">var</span> chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> addNumberToChan(chan1)</span><br><span class="line">    <span class="keyword">go</span> addNumberToChan(chan2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e := &lt;- chan1 :</span><br><span class="line">            fmt.Printf(<span class="string">"Get element from chan1: %d\n"</span>, e)</span><br><span class="line">        <span class="keyword">case</span> e := &lt;- chan2 :</span><br><span class="line">            fmt.Printf(<span class="string">"Get element from chan2: %d\n"</span>, e)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"No element in chan1 and chan2.\n"</span>)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中创建两个channel： chan1和chan2。函数addNumberToChan()函数会向两个channel中周期性写入数据。通过select可以监控两个channel，任意一个可读时就从其中读出数据。</p><p>程序输出如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;<span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">Get element from chan1: <span class="number">1</span></span><br><span class="line">Get element from chan2: <span class="number">1</span></span><br><span class="line">No element in chan1 and chan2.</span><br><span class="line">Get element from chan2: <span class="number">1</span></span><br><span class="line">Get element from chan1: <span class="number">1</span></span><br><span class="line">No element in chan1 and chan2.</span><br><span class="line">Get element from chan2: <span class="number">1</span></span><br><span class="line">Get element from chan1: <span class="number">1</span></span><br><span class="line">No element in chan1 and chan2.</span><br></pre></td></tr></table></figure><p>从输出可见，从channel中读出数据的顺序是随机的，事实上select语句的多个case执行顺序是随机的，关于select的实现原理会有专门章节分析。</p><p>通过这个示例想说的是：select的case语句读channel不会阻塞，尽管channel中没有数据。这是由于case语句编译后调用读channel时会明确传入不阻塞的参数，此时读不到数据时不会将当前goroutine加入到等待队列，而是直接返回。</p><h4 id="range">range</h4><p>通过range可以持续从channel中读出数据，好像在遍历一个数组一样，当channel中没有数据时会阻塞当前goroutine，与读channel时阻塞处理机制一样。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanRange</span><span class="params">(chanName <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> e := <span class="keyword">range</span> chanName &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Get element from chan: %d\n"</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果向此channel写数据的goroutine退出时，系统检测到这种情况后会panic，否则range将会永久阻塞。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Channel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安天蜜网捕获“利用ElasticSearch Groovy漏洞进行门罗币(Dog)挖矿”事件分析</title>
      <link href="/article/%E5%AE%89%E5%A4%A9%E8%9C%9C%E7%BD%91%E6%8D%95%E8%8E%B7%E2%80%9C%E5%88%A9%E7%94%A8ElasticSearch-Groovy%E6%BC%8F%E6%B4%9E%E8%BF%9B%E8%A1%8C%E9%97%A8%E7%BD%97%E5%B8%81-Dog-%E6%8C%96%E7%9F%BF%E2%80%9D%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/article/%E5%AE%89%E5%A4%A9%E8%9C%9C%E7%BD%91%E6%8D%95%E8%8E%B7%E2%80%9C%E5%88%A9%E7%94%A8ElasticSearch-Groovy%E6%BC%8F%E6%B4%9E%E8%BF%9B%E8%A1%8C%E9%97%A8%E7%BD%97%E5%B8%81-Dog-%E6%8C%96%E7%9F%BF%E2%80%9D%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="概述">概述</h3><p>2019年6月13日，安天蜜网捕获到利用CVE-2015-1427(ElasticSearch Groovy)远程命令执行漏洞的攻击行为。该漏洞原理是Elaticsearch将groovy作为脚本语言，并使用基于黑白名单的沙盒机制限制危险代码执行，但该机制不够严格，可以被绕过，从而导致出现远程代码执行的情况。安天对此次事件进行了详细的样本分析，并给出预防及修复建议。</p><h3 id="具体分析">具体分析</h3><h4 id="关键攻击载荷">关键攻击载荷</h4><p>从攻击载荷来看，攻击者通过groovy作为脚本语言，向_search?pretty页面发送一段带有恶意链接为http://185.181.10.234/E5DB0E07C3D7BE80V520/init.sh的json脚本，进行恶意shell脚本下载，从而实现远程代码攻击，并进行挖矿行为<br><img src="./img_1.jpg" alt=""><br>解密后核心代码：<br><img src="./img_2.jpg" alt=""></p><h4 id="样本分析">样本分析</h4><h5 id="入侵脚本initsh分析">入侵脚本init.sh分析</h5><p>攻击者通过http://185.181.10.234/E5DB0E07C3D7BE80V520/init.sh下载并执行恶意脚本init.sh来植入Dog挖矿程序，同时对主机进行扫描等一系列操作。<br><img src="./img_3.jpg" alt=""><br>之后执行关闭防火墙、关闭selinux并释放占用的资源、杀掉其他与挖矿相关的进程、设置定时任务（每30分钟下载一次可执行文件<font color="#dd0000"><a href="http://update.sh" target="_blank" rel="noopener">update.sh</a></font>），获取ssh权限，进行iptables规则转发修改，同时清理相关操作历史、日志等操作。</p><p>检查并杀死其他存在的挖矿进程：<br><img src="./img_4.jpg" alt=""></p><p>设置定时任务：<br><img src="./img_5.jpg" alt=""></p><p>恶意脚本下载地址、备份地址以及大小设置:<br><img src="./img_6.jpg" alt=""></p><p>清理相关日志、历史：<br><img src="./img_7.jpg" alt=""></p><p>在此过程中，脚本会检查sysupdate、networkservice 和sysguard这3个进程是否启动，如果没有则进行启动。</p><p>当其中一个被kill掉后，调度文件重新启动:<br><img src="./img_8.jpg" alt=""></p><h5 id="样本分析sysguard-networkservice-sysupdate">样本分析sysguard、networkservice、sysupdate</h5><p>三个样本为go语言编写并使用UPX加壳，对应的main_main函数结构分别如下：</p><p>sysguard-main_main函数结构:<br><img src="./img_9.jpg" alt=""></p><p>networkservice-main_main函数结构:<br><img src="./img_10.jpg" alt=""></p><p>sysupdate-main函数函数结构:<br><img src="./img_11.jpg" alt=""></p><p>通过与之前捕获的systemctI样本对比发现，此次攻击分成挖矿、扫描、函数调用三个进程进行调度。并且在networkservice样本中发现了相关漏洞利用函数和扫描函数。</p><p>networkservice扫描函数:<br><img src="./img_12.jpg" alt=""><br>通过对比之前捕获的样本发现两次攻击手法类似，不同的是此次攻击是通过sysguard、networkservice（扫描）和sysupdate三个进程共同进行的。这也意味着，发现服务器被感染后要将这三个进程同时kill掉。</p><h5 id="配置文件configjson">配置文件config.json</h5><p>在下载的配置文件中，我们发现了多个矿池地址：</p><table><thead><tr><th style="text-align:center">矿池地址</th></tr></thead><tbody><tr><td style="text-align:center"><a href="http://xmr.f2pool.com:13531" target="_blank" rel="noopener">xmr.f2pool.com:13531</a></td></tr><tr><td style="text-align:center"><a href="http://cryptonightr.in.nicehash.com:3375" target="_blank" rel="noopener">cryptonightr.in.nicehash.com:3375</a></td></tr><tr><td style="text-align:center"><a href="http://cryptonightr.br.nicehash.com:3375" target="_blank" rel="noopener">cryptonightr.br.nicehash.com:3375</a></td></tr><tr><td style="text-align:center"><a href="http://cryptonightr.hk.nicehash.com:3375" target="_blank" rel="noopener">cryptonightr.hk.nicehash.com:3375</a></td></tr><tr><td style="text-align:center"><a href="http://cryptonightr.jp.nicehash.com:3375" target="_blank" rel="noopener">cryptonightr.jp.nicehash.com:3375</a></td></tr><tr><td style="text-align:center"><a href="http://cryptonightr.usa.nicehash.com:3375" target="_blank" rel="noopener">cryptonightr.usa.nicehash.com:3375</a></td></tr></tbody></table><p>配置文件矿池字段：<br><img src="./img_13.jpg" alt=""></p><h3 id="受影响的服务及漏洞">受影响的服务及漏洞</h3><table><thead><tr><th>服务</th><th>漏洞</th></tr></thead><tbody><tr><td>Weblogic</td><td>CVE-2017-10271</td></tr><tr><td>Thinkphp5</td><td>远程代码执行</td></tr><tr><td>Spring Data Commons</td><td>CVE-2018-1273</td></tr><tr><td>Hadoop</td><td>未授权访问</td></tr><tr><td>ElasticSearch</td><td>CVE-2014-3120  CVE-2015-1427</td></tr><tr><td>Drupal</td><td>CVE-2018-7600</td></tr><tr><td>Redis</td><td>未授权访问</td></tr><tr><td>SQL Server</td><td>弱密码</td></tr></tbody></table><h3 id="ioc">IOC</h3><p>攻击IP：</p><table><thead><tr><th>IP</th><th>地理位置</th></tr></thead><tbody><tr><td>132.145.186.243</td><td>美国</td></tr><tr><td>111.40.10.11</td><td>中国-黑龙江­哈尔滨</td></tr><tr><td>167.86.106.102</td><td>美国-科罗拉多州-利特尔顿</td></tr><tr><td>221.176.156.164</td><td>中国-河南-开封</td></tr><tr><td>185.181.10.234</td><td>德国-黑森州-法兰克福</td></tr></tbody></table><p>URL：</p><table><thead><tr><th style="text-align:center">URL</th></tr></thead><tbody><tr><td style="text-align:center"><a href="http://185.181.10.234/E5DB0E07C3D7BE80V520/config.json" target="_blank" rel="noopener">http://185.181.10.234/E5DB0E07C3D7BE80V520/config.json</a></td></tr><tr><td style="text-align:center"><a href="http://185.181.10.234/E5DB0E07C3D7BE80V520/networkservice" target="_blank" rel="noopener">http://185.181.10.234/E5DB0E07C3D7BE80V520/networkservice</a></td></tr><tr><td style="text-align:center"><a href="http://185.181.10.234/E5DB0E07C3D7BE80V520/sysguard" target="_blank" rel="noopener">http://185.181.10.234/E5DB0E07C3D7BE80V520/sysguard</a></td></tr><tr><td style="text-align:center"><a href="http://185.181.10.234/E5DB0E07C3D7BE80V520/sysupdate" target="_blank" rel="noopener">http://185.181.10.234/E5DB0E07C3D7BE80V520/sysupdate</a></td></tr><tr><td style="text-align:center"><a href="http://185.181.10.234/E5DB0E07C3D7BE80V520/update.sh" target="_blank" rel="noopener">http://185.181.10.234/E5DB0E07C3D7BE80V520/update.sh</a></td></tr><tr><td style="text-align:center"><a href="https://de.gsearch.com.de/api/config.json" target="_blank" rel="noopener">https://de.gsearch.com.de/api/config.json</a></td></tr><tr><td style="text-align:center"><a href="https://de.gsearch.com.de/api/networkservice" target="_blank" rel="noopener">https://de.gsearch.com.de/api/networkservice</a></td></tr><tr><td style="text-align:center"><a href="https://de.gsearch.com.de/api/sysguard" target="_blank" rel="noopener">https://de.gsearch.com.de/api/sysguard</a></td></tr><tr><td style="text-align:center"><a href="https://de.gsearch.com.de/api/sysupdate" target="_blank" rel="noopener">https://de.gsearch.com.de/api/sysupdate</a></td></tr><tr><td style="text-align:center"><a href="https://de.gsearch.com.de/api/update.sh" target="_blank" rel="noopener">https://de.gsearch.com.de/api/update.sh</a></td></tr><tr><td style="text-align:center"><a href="http://185.181.10.234/E5DB0E07C3D7BE80V520/init.sh" target="_blank" rel="noopener">http://185.181.10.234/E5DB0E07C3D7BE80V520/init.sh</a></td></tr></tbody></table><p>MD5：</p><table><thead><tr><th style="text-align:center">MD5</th></tr></thead><tbody><tr><td style="text-align:center">09c3dbdb39e1437a40b5c22600b375ca</td></tr><tr><td style="text-align:center">8e9957b496a745f5db09b0f963eba74e</td></tr><tr><td style="text-align:center">c31038f977f766eeba8415f3ba2c242c</td></tr><tr><td style="text-align:center">ff879d31ed80841482c27c90e2bfe268</td></tr><tr><td style="text-align:center">1cc08560de0edb78a9c4a0f1ba664e5f</td></tr></tbody></table><h3 id="预防与修复建议">预防与修复建议</h3><h4 id="预防建议">预防建议</h4><ul><li><p>确保系统与应用程序及时下载更新为官方提供的最新补丁；</p></li><li><p>禁止使用弱口令密码；</p></li><li><p>定期检查服务器异常，如CPU持续占用高、磁盘异常情况；</p></li><li><p>安装终端威胁安全防护产品–安天智甲终端防御系统。安天智甲终端防御系统可以为您量身定制专属安全基线，为您打造安全的内网环境；同时，文档安全保护功能、全网病毒定点清除功能、以及国产操作系统的安全防护功能更好的解决您遇到的安全问题，保护您的服务器。</p></li></ul><h4 id="修复建议">修复建议</h4><ul><li>断网、备份重要的crontab，关闭或删除定时任务：systemctl stop crontab或 rm -rf /etc/cron.d/*；</li><li>锁定crontab中的恶意文件；</li><li>查看并杀掉病毒进程：同时杀掉sysguard、networkservice、sysupdate三个进程；</li><li>删除病毒相关文件，确认无误后，重启服务器，安装漏洞补丁，并采用安天智甲终端防御系统进行预防和保护服务器的安全。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安天每日安全简讯2019-12-05</title>
      <link href="/article/%E5%AE%89%E5%A4%A9%E6%AF%8F%E6%97%A5%E5%AE%89%E5%85%A8%E7%AE%80%E8%AE%AF2019-12-05/"/>
      <url>/article/%E5%AE%89%E5%A4%A9%E6%AF%8F%E6%97%A5%E5%AE%89%E5%85%A8%E7%AE%80%E8%AE%AF2019-12-05/</url>
      
        <content type="html"><![CDATA[<h3 id="恶意软件callerspy伪装成聊天程序窃取用户信息">恶意软件CallerSpy伪装成聊天程序窃取用户信息</h3><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"https://techrepublicvideo.cbsistatic.com/media/2019/07/25/1576454211504/2019-07-25-wochit-mobile-malware-is-on-the-rise-thanks-to-banking-apps-and-weak-security_1898142_740.mp4","pic":"./img_1.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>趋势科技的网络安全研究人员发现并详细描述了被称为CallerSpy的木马恶意软件，他们认为该恶意软件攻击是网络间谍活动的一部分。尽管被广告宣传为聊天应用程序，但CallerSpy应用程序不包含任何聊天功能，CallerSpy的恶意功能包括收集设备上所有的通话记录、短信、联系人列表和文件，能够使用手机的麦克风记录周围环境的音频，以及能够截屏用户活动。所有被盗的数据都会定期上传到攻击者那里。</p><blockquote><p><a href="https://www.zdnet.com/article/this-new-android-malware-comes-disguised-as-a-chat-app/" target="_blank" rel="noopener">https://www.zdnet.com/article/this-new-android-malware-comes-disguised-as-a-chat-app/</a></p></blockquote><h3 id="新版本的icedid木马中使用了隐写负载">新版本的IcedID木马中使用了隐写负载</h3><p><img src="./img_2.png" alt=""><br>安全公司Proofpoint最近发布了一份报告，该报告涉及一系列归因于威胁行为者TA2101的垃圾邮件活动，恶意电子邮件浪潮针对美国，推动了IcedID木马。IcedID不仅是银行木马，而且是能够提取各种凭证的通用窃取者。该木马是由经验丰富的开发人员编写的成熟程序。 它部署了各种典型技术，包括Zeus风格的Webinject，用于各种浏览器的挂钩，隐藏的VNC和反向连接。在最近的更新中，恶意软件的作者给木马安装了隐写术。 在威胁环境中看到它并不是什么新鲜事物，但是它使此恶意软件更加隐蔽。</p><blockquote><p><a href="https://blog.malwarebytes.com/threat-analysis/2019/12/new-version-of-icedid-trojan-uses-steganographic-payloads/" target="_blank" rel="noopener">https://blog.malwarebytes.com/threat-analysis/2019/12/new-version-of-icedid-trojan-uses-steganographic-payloads/</a></p></blockquote><h3 id="两个恶意python库窃取了ssh和gpg密钥">两个恶意Python库窃取了SSH和GPG密钥</h3><p><img src="./img_3.png" alt=""><br>Python安全团队从PyPI（Python软件包索引）中删除了两个木马化的Python库，这些库被发现从受感染的开发人员的项目中窃取SSH和GPG密钥。第一个是“ python3-dateutil”，它模仿了流行的“ dateutil”库。 第二个是“jeIlyfish”（第一个L是I），它模仿“jellyfish”库。这两名恶意克隆者是在12月1日周日被德国软件开发人员Lukas Martini发现的。在Martini通知dateutil开发人员和PyPI安全团队后，这两个库都被删除了。</p><blockquote><p><a href="https://www.zdnet.com/article/two-malicious-python-libraries-removed-from-pypi/" target="_blank" rel="noopener">https://www.zdnet.com/article/two-malicious-python-libraries-removed-from-pypi/</a></p></blockquote><h3 id="西门子的s7-1200-plc产品中存在安全漏洞">西门子的S7-1200 PLC产品中存在安全漏洞</h3><p><img src="./img_4.jpg" alt=""><br>西门子最近发布了一份安全公告，其中包含针对研究人员在其S7-1200可编程逻辑控制器（PLC）中发现的漏洞的变通办法和缓解措施，该漏洞可用于绕过固件完整性检查以加载恶意软件或劫持设备的工业流程。西门子表示：“我们正在审查我们的产品模型，并将在SSA-686531上发布更新，以防其他模型受到影响。研究人员还发现，可编程逻辑控制器（PLC）中的特殊访问功能也可以很好地用作：作为防御者的取证工具。他们利用该功能查看PLC存储器的内容，因此工厂操作员也可以使用它来查找设备上的恶意代码。</p><blockquote><p><a href="https://www.darkreading.com/vulnerabilities/threats/siemens-offers-workarounds-for-newly-found-plc-vulnerability/d/d-id/1336503" target="_blank" rel="noopener">https://www.darkreading.com/vulnerabilities/threats/siemens-offers-workarounds-for-newly-found-plc-vulnerability/d/d-id/1336503</a></p></blockquote><h3 id="goahead嵌入式web服务器中存在安全漏洞">GoAhead嵌入式Web服务器中存在安全漏洞</h3><p><img src="./img_5.png" alt=""><br>思科Talos的专家在GoAhead的嵌入式web服务器中发现了两个漏洞，包括一个超危的远程代码执行漏洞。第一个漏洞(跟踪为CVE-2019-5096)与如何处理多部分/表单数据请求有关。未经身份验证的攻击者可以利用这个缺陷触发一个空闲后使用的条件，并通过发送特殊的HTTP请求在服务器上执行任意代码。Talos在GoAhead web服务器中发现的第二个漏洞(被跟踪为CVE-2019-5097)可被未经身份验证的攻击者利用，通过发送经过特殊处理的HTTP请求来造成拒绝服务(DoS)条件。Talos在8月份向EmbedThis报告了这些漏洞，供应商在11月21日修复了它们。</p><blockquote><p><a href="https://securityaffairs.co/wordpress/94692/hacking/goahead-rce.html" target="_blank" rel="noopener">https://securityaffairs.co/wordpress/94692/hacking/goahead-rce.html</a></p></blockquote><h3 id="accusoft-imagegear中存在代码执行漏洞">Accusoft ImageGear中存在代码执行漏洞</h3><p><img src="./img_6.jpg" alt=""><br>思科Talos发现，文档和映像库Accusoft ImageGear中的漏洞可能使攻击者能够在易受攻击的计算机上远程执行代码。作为CVE-2019-5083进行跟踪，第一个问题影响igcore19d.dll TIF_decode_thunderscan函数。第二个漏洞CVE-2019-5076影响了该工具包的igcore19d.dll PNG标头解析器。在ImageGear的igcore19d.dll GEM Raster解析器中发现了另一个越界写入漏洞。跟踪为CVE-2019-5132，它需要特制的GEM文件才能在受影响的系统上执行代码。第四个漏洞CVE-2019-5133影响了该库的igcore19d.dll BMP解析器。思科Talos于7月底将漏洞报告给Accusoft。上周发布了补丁。</p><blockquote><p><a href="https://www.securityweek.com/code-execution-vulnerabilities-patched-accusoft-imagegear" target="_blank" rel="noopener">https://www.securityweek.com/code-execution-vulnerabilities-patched-accusoft-imagegear</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISC和CISC科普</title>
      <link href="/article/RISC%E5%92%8CCISC%E7%A7%91%E6%99%AE/"/>
      <url>/article/RISC%E5%92%8CCISC%E7%A7%91%E6%99%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>RISC是英文Reduced Instruction Set Computer<br>CISC是英文Complex Instruction Set Computer<br>RISC（精简指令集计算机）和CISC（复杂指令集计算机）是当前CPU的两种架构。它们的区别在于不同的CPU设计理念和方法。</p></blockquote><h3 id="cisc架构">CISC架构</h3><p>早期的CPU全部是CISC架构，它的设计目的是要用最少的机器语言指令来完成所需的计算任务。比如对于乘法运算，在CISC架构的CPU上，您可能需要这样一条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL ADDRA, ADDRB</span><br></pre></td></tr></table></figure><p>就可以将ADDRA和ADDRB中的数相乘并将结果储存在ADDRA中。将ADDRA, ADDRB中的数据读入寄存器，相乘和将结果写回内存的操作全部依赖于CPU中设计的逻辑来实现。这种架构会增加CPU结构的复杂性和对CPU工艺的要求，但对于编译器的开发十分有利。比如上面的例子，C程序中的<font color="#dd0000">a*=b</font>就可以直接编译为一条乘法指令。今天只有Intel及其兼容CPU还在使用CISC架构。</p><h3 id="risc架构">RISC架构</h3><p>RISC架构要求软件来指定各个操作步骤。上面的例子如果要在RISC架构上实现，将ADDRA, ADDRB中的数据读入寄存器，相乘和将结果写回内存的操作都必须由软件来实现，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV A, ADDRA; </span><br><span class="line">MOV B, ADDRB; </span><br><span class="line">MUL A, B; </span><br><span class="line">STR ADDRA, A;</span><br></pre></td></tr></table></figure><p>这种架构可以降低CPU的复杂性以及允许在同样的工艺水平下生产出功能更强大的CPU，但对于编译器的设计有更高的要求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APT恶意软件分析之从WORD中提取EXE技术</title>
      <link href="/article/APT%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%8EWORD%E4%B8%AD%E6%8F%90%E5%8F%96EXE%E6%8A%80%E6%9C%AF/"/>
      <url>/article/APT%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%8EWORD%E4%B8%AD%E6%8F%90%E5%8F%96EXE%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>本文章讲解的是一个word恶意样本的提取出来恶意EXE文件的方法。</p><h1 id="恶意样本下载地址">恶意样本下载地址</h1><p>注册登录后即可下载原始的word恶意样本</p><blockquote><p><a href="https://malwr.com/analysis/MjQxOTQ5NWNjMGZlNGFiZmJkYzcwOTlkNDE3ZDdhZTU/" target="_blank" rel="noopener">https://malwr.com/analysis/MjQxOTQ5NWNjMGZlNGFiZmJkYzcwOTlkNDE3ZDdhZTU/</a></p></blockquote><h1 id="分析工具准备工作">分析工具准备工作</h1><h1 id="安装依赖包">安装依赖包</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//bitbucket.org/decalage/olefileio_pl/downloads/olefile-0.41.zip</span></span><br><span class="line"></span><br><span class="line">unzip oldfile - <span class="number">0.41</span>.zip</span><br><span class="line"></span><br><span class="line">cd oldfile - <span class="number">0.41</span></span><br><span class="line"></span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure><h1 id="下载oledump">下载oledump</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//didierstevens.com/files/software/oledump_V0_0_4.zip</span></span><br><span class="line"></span><br><span class="line">wget http:<span class="comment">//didierstevens.com/files/software/pecheck_v0_3_0.zip</span></span><br></pre></td></tr></table></figure><h1 id="word恶意样本分析">word恶意样本分析</h1><h1 id="查看word恶意样本信息">查看word恶意样本信息</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oledump.py <span class="number">1.</span>doc</span><br></pre></td></tr></table></figure><blockquote><p>结果说明: 模块7包含了一个宏</p></blockquote><p><img src="./oledump_apt_1.png" alt="avatar"></p><h1 id="查看宏脚本">查看宏脚本</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oledump.py - s <span class="number">7</span> - v  <span class="number">1.</span>doc</span><br></pre></td></tr></table></figure><p>输出内容：<br><img src="./oledump_apt_2.png" alt="avatar"></p><h1 id="查看word中插入的内容">查看word中插入的内容</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oledump.py - s <span class="number">14</span>  <span class="number">1.</span>doc</span><br></pre></td></tr></table></figure><p>结果：<br><img src="./oledump_apt_3.png" alt="avatar"></p><h4 id="宏内容解码">宏内容解码</h4><ul><li>解码脚本：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line">__description__ = <span class="string">'&amp;H decoder for oledump.py'</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'Didier Stevens'</span></span><br><span class="line"></span><br><span class="line">__version__ = <span class="string">'0.0.1'</span></span><br><span class="line"></span><br><span class="line">__date__ = <span class="string">'2014/12/19'</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Source code put in public domain by Didier Stevens, no Copyright</span></span><br><span class="line"><span class="string">https://DidierStevens.com</span></span><br><span class="line"><span class="string">Use at your own risk</span></span><br><span class="line"><span class="string">History:</span></span><br><span class="line"><span class="string">  2014/12/19: start</span></span><br><span class="line"><span class="string">Todo:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cAmpersandHexDecoder</span><span class="params">(cDecoderParent)</span>:</span></span><br><span class="line"></span><br><span class="line">    name = <span class="string">'&amp;H decoder'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, stream, options)</span>:</span></span><br><span class="line">        self.stream = stream</span><br><span class="line">        self.options = options</span><br><span class="line">        self.done = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Available</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.done</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Decode</span><span class="params">(self)</span>:</span></span><br><span class="line">        decoded = <span class="string">''</span>.join([chr(int(s[<span class="number">2</span>:], <span class="number">16</span>)) <span class="keyword">for</span> s <span class="keyword">in</span> re.compile(<span class="string">'&amp;H[0-9a-f]&#123;2&#125;'</span>, re.IGNORECASE).findall(self.stream)])</span><br><span class="line">        self.name = <span class="string">'&amp;H decoder'</span></span><br><span class="line">        self.done = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> decoded</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">AddDecoder(cAmpersandHexDecoder)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oledump.py -s <span class="number">14</span>  -D decoder_ay.py <span class="number">1.</span>doc  | more</span><br></pre></td></tr></table></figure><ul><li>进行解码</li></ul><p>结果输出：<br><img src="./oledump_apt_4.png" alt="avatar"></p><h4 id="word样本中的exe病毒样本导出">WORD样本中的EXE病毒样本导出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python oledump.py -s <span class="number">14</span>  -D decoder_ay.py -d <span class="number">1.</span>doc  &gt;<span class="number">1.</span>exe</span><br></pre></td></tr></table></figure><h4 id="查看virustotal结果">查看virustotal结果</h4><p><img src="./oledump_apt_5.png" alt="avatar"></p><blockquote><p>【原文】<a href="http://blog.sina.com.cn/s/blog_e8e60bc00102velj.html" target="_blank" rel="noopener">原链接</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> APT样本提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用go管理Makefile</title>
      <link href="/article/%E4%BD%BF%E7%94%A8go%E7%AE%A1%E7%90%86Makefile/"/>
      <url>/article/%E4%BD%BF%E7%94%A8go%E7%AE%A1%E7%90%86Makefile/</url>
      
        <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>很多时候， 我们需要运行多个命令来能完成一件事，又或者某个命令需要指定很多参数。这个时候，就需要使用脚本来取代这些复杂的命令，减少输错命令的可能，也可以为后来者指明常用的操作。</p><h3 id="makefile">Makefile</h3><p>Makefile就是为此而生的，相对于用途广泛的shell脚本，Makefile专注于构建自动化过程， 通常用于编译源码等。 很多项目都会提供Makefile文件，只需要简单地运行<code>make</code> 就能轻松完成编译构建的过程。</p><p>简单介绍下Makefile的规则。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target: dependencies</span><br><span class="line">    system command(s)</span><br></pre></td></tr></table></figure><ul><li><p>target通常是程序要生成的目标文件的名字。但也可以是一个动作的名字。</p></li><li><p>dependencies是依赖，通常是文件，完成target所需要的输入。</p></li><li><p>system command(s) 是完成 target 所需要运行的指令， 即 shell 命令。<br>一条语句一行， 使用单个 tab 缩进。</p></li></ul><p>使用 make 命令可以运行各种 target。 如果不带 target 参数，<br>第一个 target 会被作为默认目标。</p><p>很多时候， Makefile 不是为了编译， 也不再引用任何文件，<br>仅仅是为了整合多个命令， 比写脚本方便多。<br>这个时候涉及到一个叫做伪目标的指令 <code>.PHONY</code>。<br><code>.PHONY</code> 后面跟着的多个 target 都不是要生成的文件的名字，<br>而是指代一个动作， 一个行为。 比如 test 指运行测试， clean 清理文件等。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: all test clean doc ci</span><br></pre></td></tr></table></figure><p>更多内容可以参考<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fseisman.github.io%2Fhow-to-write-makefile%2Findex.html" target="_blank" rel="noopener">跟我一起写 Makefile</a></p><h3 id="实践">实践</h3><p><strong>注意， windows 下没有 make 命令， 所以 Makefile 也就无法使用。</strong></p><p>你可以在 docker 容器中运行命令， 可以参考另一篇文章<br><code>在 VS Code 中使用容器开发</code>。</p><p>在项目的根目录添加 <code>Makefile</code> 文件:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">all: gotool build</span><br><span class="line">build:</span><br><span class="line">    @<span class="keyword">go</span> build ./</span><br><span class="line">run:</span><br><span class="line">    @<span class="keyword">go</span> run ./</span><br><span class="line">clean:</span><br><span class="line">    rm -f web</span><br><span class="line">    find . -name <span class="string">"[._]*.s[a-w][a-z]"</span> | xargs -i rm -f &#123;&#125;</span><br><span class="line">gotool:</span><br><span class="line">    <span class="keyword">go</span> fmt ./</span><br><span class="line">    <span class="keyword">go</span> vet ./</span><br><span class="line">ca:</span><br><span class="line">    MSYS_NO_PATHCONV=<span class="number">1</span> openssl req -<span class="built_in">new</span> -nodes -x509 -out conf/server.crt -keyout conf/server.key -days <span class="number">3650</span> -subj <span class="string">"/C=CN/ST=SH/L=SH/O=CoolCat/OU=CoolCat Software/CN=127.0.0.1/emailAddress=coolcat@qq.com"</span></span><br><span class="line">mysql:</span><br><span class="line">    docker-compose up -d mysql</span><br><span class="line">dbcli:</span><br><span class="line">    docker-compose run --rm dbclient</span><br><span class="line"></span><br><span class="line">help:</span><br><span class="line">    @echo <span class="string">"make - 格式化 Go 代码， 并编译生成二进制文件"</span></span><br><span class="line">    @echo <span class="string">"make build - 编译 Go 代码， 生成二进制文件"</span></span><br><span class="line">    @echo <span class="string">"make run - 直接运行 Go 代码"</span></span><br><span class="line">    @echo <span class="string">"make clean - 移除二进制文件和 vim swap files"</span></span><br><span class="line">    @echo <span class="string">"make gotool - 运行 Go 工具 'fmt' and 'vet'"</span></span><br><span class="line">    @echo <span class="string">"make ca - 生成证书文件"</span></span><br><span class="line">    @echo <span class="string">"make mysql - 启动 mysql 服务器"</span></span><br><span class="line">    @echo <span class="string">"make dbcli - 连接到 mysql 命令行"</span></span><br><span class="line"></span><br><span class="line">。PHONY: all build run clean gotool ca mysql dbcli help</span><br></pre></td></tr></table></figure><p>这里的所有 target 都是伪目标。用来包装一些简单的 shell 命令。</p><p>可以在项目根目录下运行以下命令:</p><ul><li>make - 格式化 Go 代码， 并编译生成二进制文件</li><li>make build - 编译 Go 代码， 生成二进制文件</li><li>make run - 直接运行 Go 代码</li><li>make clean - 移除二进制文件和 vim swap files</li><li>make gotool - 运行 Go 工具 ‘fmt’ and ‘vet’</li><li>make ca - 生成证书文件</li><li>make mysql - 启动 mysql 服务器</li><li>make dbcli - 连接到 mysql 命令行</li><li>make help - 查看帮助信息</li></ul><p>有了 Makefile 的帮助， 很多事情变得简单起来了，<br>比如要生成证书文件， 只需要运行 <code>make ca</code> 就行了，<br>不用输入一大行命令了。</p><h3 id="总结">总结</h3><p>Makefile 是 linux 下常用的工具， 对于提升效率是非常有效的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> make </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花花与三猫CatLive-第三篇</title>
      <link href="/article/%E8%8A%B1%E8%8A%B1%E4%B8%8E%E4%B8%89%E7%8C%ABCatLive-%E7%AC%AC%E4%B8%89%E7%AF%87/"/>
      <url>/article/%E8%8A%B1%E8%8A%B1%E4%B8%8E%E4%B8%89%E7%8C%ABCatLive-%E7%AC%AC%E4%B8%89%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="带家里胆最大的猫咪出门以为可以遛弯儿结果怂成一团">带家里胆最大的猫咪出门，以为可以遛弯儿，结果怂成一团！</h2><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"video":{"url":"http://gslb.miaopai.com/stream/wssuU3yJrVOqvDLg3UursIbQ~jemHI8VtDNSBg__.mp4","pic":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1575045065&di=3a926764f3c280d97a71f67dbfa06ecb&imgtype=jpg&er=1&src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2F5ba90764c07e49e0315523ce4aafc580dbad2b1c.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      
      
        <tags>
            
            <tag> 猫咪 </tag>
            
            <tag> 短视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker搭建MongoDB环境</title>
      <link href="/article/Docker-%E6%90%AD%E5%BB%BAMongoDB%E7%8E%AF%E5%A2%83/"/>
      <url>/article/Docker-%E6%90%AD%E5%BB%BAMongoDB%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h3 id="从dockerhub下载mongodb官方镜像">从DockerHUB下载MongoDB官方镜像</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mongo</span><br></pre></td></tr></table></figure><h3 id="运行镜像生成容器">运行镜像生成容器</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">27017</span>:<span class="number">27017</span> --name mongo -v /home/data/db:/data/db -d mongo --auth</span><br><span class="line">-p <span class="number">27017</span>:<span class="number">27017</span> 端口映射</span><br><span class="line">-v /home/data/db:/data/db 通过卷挂载将MongoDB的数据存在宿主机的/home/data/db中</span><br><span class="line">-- auth 设置授权与鉴权</span><br></pre></td></tr></table></figure><h3 id="添加admin用户">添加admin用户</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mongo mongo admin</span><br></pre></td></tr></table></figure><h3 id="创建数据库">创建数据库</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&#123; user: <span class="string">'root'</span>, pwd: <span class="string">'password'</span>, roles: [ &#123; role: <span class="string">"userAdminAnyDatabase"</span>, db: <span class="string">"admin"</span> &#125; ] &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker教程</title>
      <link href="/article/Docker%E6%95%99%E7%A8%8B/"/>
      <url>/article/Docker%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="跟我学-docker企业级私有仓库-harbor十七完结篇">跟我学 Docker：企业级私有仓库 harbor（十七）完结篇</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F22%3Ft%3D1567387069929" target="_blank" rel="noopener">https://www.sudo.ren/article/22?t=1567387069929</a></p><h3 id="跟我学-docker跨主机容器间通信之-overlay十六">跟我学 Docker：跨主机容器间通信之 overlay（十六）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F21%3Ft%3D1567387061602" target="_blank" rel="noopener">https://www.sudo.ren/article/21?t=1567387061602</a></p><h3 id="跟我学-dockerdocker-跨主机通信之-macvlan十五">跟我学 Docker：docker 跨主机通信之 macvlan（十五）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F20%3Ft%3D1567387054474" target="_blank" rel="noopener">https://www.sudo.ren/article/20?t=1567387054474</a></p><h3 id="跟我学-docker容器的四种网络类型十四">跟我学 Docker：容器的四种网络类型（十四）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F19%3Ft%3D1567387044323" target="_blank" rel="noopener">https://www.sudo.ren/article/19?t=1567387044323</a></p><h3 id="跟我学-docker容器编排-docker-compose十三">跟我学 Docker：容器编排 docker-compose（十三）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F18%3Ft%3D1567387033915" target="_blank" rel="noopener">https://www.sudo.ren/article/18?t=1567387033915</a></p><h3 id="跟我学-dockerdocker-私有仓库-registry十二">跟我学 Docker：docker 私有仓库 registry（十二）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F17%3Ft%3D1567387025131" target="_blank" rel="noopener">https://www.sudo.ren/article/17?t=1567387025131</a></p><h3 id="跟我学-dockerdocker-容器间的互联和应用十一">跟我学 Docker：docker 容器间的互联和应用（十一）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F16%3Ft%3D1567387016458" target="_blank" rel="noopener">https://www.sudo.ren/article/16?t=1567387016458</a></p><h3 id="跟我学-dockerdocker-镜像的分层十">跟我学 Docker：docker 镜像的分层（十）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F15%3Ft%3D1567387003906" target="_blank" rel="noopener">https://www.sudo.ren/article/15?t=1567387003906</a></p><h3 id="跟我学-dockerdockerfile-自动构建私有云平台九">跟我学 Docker：dockerfile 自动构建私有云平台（九）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F14%3Ft%3D1567386989954" target="_blank" rel="noopener">https://www.sudo.ren/article/14?t=1567386989954</a></p><h3 id="跟我学-dockerdockerfile-自动构建镜像八">跟我学 Docker：dockerfile 自动构建镜像（八）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F13%3Ft%3D1567386976354" target="_blank" rel="noopener">https://www.sudo.ren/article/13?t=1567386976354</a></p><h3 id="跟我学-docker手动制作-docker-镜像七">跟我学 Docker：手动制作 docker 镜像（七）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F12%3Ft%3D1567386968066" target="_blank" rel="noopener">https://www.sudo.ren/article/12?t=1567386968066</a></p><h3 id="跟我学-dockerdocker-数据卷存储六">跟我学 Docker：docker 数据卷存储（六）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F11%3Ft%3D1567386957538" target="_blank" rel="noopener">https://www.sudo.ren/article/11?t=1567386957538</a></p><h3 id="跟我学-dockerdocker-的网络原理五">跟我学 Docker：docker 的网络原理（五）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F10%3Ft%3D1567386947466" target="_blank" rel="noopener">https://www.sudo.ren/article/10?t=1567386947466</a></p><h3 id="跟我学-dockerdocker-容器日常管理四">跟我学 Docker：docker 容器日常管理（四）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F9%3Ft%3D1567386936625" target="_blank" rel="noopener">https://www.sudo.ren/article/9?t=1567386936625</a></p><h3 id="跟我学-dockerdocker-镜像的常用命令三">跟我学 Docker：docker 镜像的常用命令（三）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F8%3Ft%3D1567386925401" target="_blank" rel="noopener">https://www.sudo.ren/article/8?t=1567386925401</a></p><h3 id="跟我学-docker启动第一个-docker-容器二">跟我学 Docker：启动第一个 docker 容器（二）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F7%3Ft%3D1567386909531" target="_blank" rel="noopener">https://www.sudo.ren/article/7?t=1567386909531</a></p><h3 id="跟我学-dockerdocker-的介绍和安装一">跟我学 Docker：docker 的介绍和安装（一）</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.sudo.ren%2Farticle%2F6%3Ft%3D1567386895266" target="_blank" rel="noopener">https://www.sudo.ren/article/6?t=1567386895266</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一张图告诉你, 科班程序员和自学编程的差别在哪 网友：真实！！</title>
      <link href="/article/%E4%B8%80%E5%BC%A0%E5%9B%BE%E5%91%8A%E8%AF%89%E4%BD%A0-%E7%A7%91%E7%8F%AD%E7%A8%8B%E5%BA%8F%E5%91%98%E5%92%8C-%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%88%AB%E5%9C%A8%E5%93%AA-%E7%BD%91%E5%8F%8B%EF%BC%9A%E7%9C%9F%E5%AE%9E%EF%BC%81%EF%BC%81/"/>
      <url>/article/%E4%B8%80%E5%BC%A0%E5%9B%BE%E5%91%8A%E8%AF%89%E4%BD%A0-%E7%A7%91%E7%8F%AD%E7%A8%8B%E5%BA%8F%E5%91%98%E5%92%8C-%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%88%AB%E5%9C%A8%E5%93%AA-%E7%BD%91%E5%8F%8B%EF%BC%9A%E7%9C%9F%E5%AE%9E%EF%BC%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>自学编程的程序员，似乎都处于轻视链的底端，而计算机专业的毕业生，似乎自然存在着一种自卑感。自学编程和科班程序员的差距，到底有多大？这也是行将“入坑”的编程喜好者，最关怀的一个问题。</p><h3 id="学问体系的差异">学问体系的差异</h3><p>科班出身的程序员，相关于自学编程者，具备愈加完善的学问体系，在实践工作中，能更快的构成完好的任职，从而更深化地处理问题。</p><p><img src="./img_1.png" alt=""></p><p>由于大学期间，曾经系统的学习了计算机学问，因而科班程序员的学问体系愈加完好，学起东西的速度也更快。</p><p>自学成才者，可能由于触及到本人未知的根底概念，而不得不先补根底，再学习。</p><p>那么，谁的代码写的更好呢？还真不一定！</p><h3 id="就业的区别">就业的区别</h3><p>关于 BAT 大厂而言，僧多粥少，为了降低用人风险，他们更倾向于招聘科班选手。</p><p>关于初创公司而言，我没有时间等你从一个理论型选手，生长为实战型选手，我更喜欢具有短平快的技术。</p><p><img src="./img_2.png" alt=""></p><p>索性，没有公司会仅仅看学历一个标签，代码 or 成果，这两个标签页非常重要。开源项目的掌管或参与，漂亮而充实的 GitHub 页面、优秀的 Top Coder，也会是很亮眼的标签。</p><p><img src="./img_3.png" alt=""></p><h3 id="具有资源的不同">具有资源的不同</h3><p>科班程序员就像是宠物饲养员，被狗狗熏着熏着，本人也会把本人想象成狗了。</p><p>自学成才的，自家里只养了条狗，需求更努力的与大咖们交流思想，才干把本人想象成狗。</p><p><img src="./img_4.png" alt=""></p><p>市场的需求量大增，编程入门门槛的降低，让无数自学编程的喜好者，涌入了这一行业，殊不知，若不时辰坚持学习心态，锐意进取，那么就会如马云那句名言：</p><p><img src="./img_5.png" alt=""></p><p>反之，关于科班程序员而言，就算是再牛，人之为学，不日进则日退，不过几年，也会泯然众人矣。</p><p>话说回来，到底科班程序员，和自学成才的人，有什么区别呢？一张图能够表达的明明白白。</p><p><img src="./img_6.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可以免费自学的10个编程网站</title>
      <link href="/article/%E5%8F%AF%E4%BB%A5%E5%85%8D%E8%B4%B9%E8%87%AA%E5%AD%A6%E7%9A%8410%E4%B8%AA%E7%BC%96%E7%A8%8B%E7%BD%91%E7%AB%99/"/>
      <url>/article/%E5%8F%AF%E4%BB%A5%E5%85%8D%E8%B4%B9%E8%87%AA%E5%AD%A6%E7%9A%8410%E4%B8%AA%E7%BC%96%E7%A8%8B%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p><img src="./header.jpeg" alt=""><br>编程学习,很多人包括一些企业家，和市场营销人员都认为学习编程对一个人走向成功十分有帮助。在过去的一年里，我一直在学习编程。它有助我成为一个更好的创业者，我甚至可以提供一些帮助，当我的团队需要解决一些 bug 的时候。</p><p>现在，如果你想学编程的话，这 10个网站可以帮助你，它们都提供了免费的课程供你学习，因此你无需担心费用的问题。</p><h2 id="codecademy"><a href="https://link.jianshu.com?t=http://www.codecademy.com/" target="_blank" rel="noopener">Codecademy</a></h2><p>其中，Codecademy 是最受欢迎的免费编程学习网站之一。事实上，已经有超过 2400 万人通过这家公司的教育模式学会了编程。Codecademy 开设的课程有 HTML&amp;CSS，JavaScript，jQuery 的，PHP，Python 和 Ruby。</p><h2 id="coursera"><a href="https://link.jianshu.com?t=https://www.coursera.org/courses?query=programming" target="_blank" rel="noopener">Coursera</a></h2><p>Coursera 成立于 2012 年，如今已经成长为一个主要以营利为目的的技术教育公司，现提供来自 119 家机构的超过 1000 门课程。如果你想要获得证书，可能需要为一定的课程付费，这里也有一些来自不同大学的免费编程课程，如华盛顿大学，斯坦福大学，多伦多大学和范德比尔特大学等。</p><h2 id="edx"><a href="https://link.jianshu.com?t=https://www.edx.org/" target="_blank" rel="noopener">edX</a></h2><p>edX 是另一个领先的在线学习平台，重点是它不是以营利为目的，而是开源的。edX 是由美国哈佛大学和麻省理工学院于 2012 年联合创办的，所以你将会在这里学习到先进的技术和理论。如今，edX 已涵盖了 60 所学校。此外在这里，你应该不会错过哈佛大学的计算机科学导论的，免费的哦。</p><h2 id="udemy"><a href="https://link.jianshu.com?t=https://www.udemy.com/" target="_blank" rel="noopener">Udemy</a></h2><p>Udemy 成立于 2010 年，是一个在线学习平台，可以帮助你改善或学习工作技能。虽然有部分课程需要付费，但也有大量的免费编程学习课程，通过视频讲授。</p><h2 id="agupieware"><a href="https://link.jianshu.com?t=http://blog.agupieware.com/2014/05/online-learning-bachelors-level.html" target="_blank" rel="noopener">aGupieWare</a></h2><p>一个独立 APP 开发者从美国的一些领先机构调查了计算机科学程序，然后基于斯坦福大学，麻省理工学院，卡耐基梅隆大学伯克利分校和哥伦比亚大学提供的免费课程，它创建了一个类似的课程。该程序分为 15 个课程：3 个入门课程，7 门核心课程和 5 个选修课程。</p><p>对有潜力的程序员来说，这简直是一个完美的入门程序。（本段感觉译的不是很好，有其他见解还请赐教~）</p><h2 id="github"><a href="https://link.jianshu.com?t=https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md#professional-development" target="_blank" rel="noopener">GitHub</a></h2><p>这个我想大多数开发者都知道就不多说了，作为开源代码库以及版本控制系统，Github 拥有 140 多万开发者用户。</p><h2 id="code-avengers"><a href="https://link.jianshu.com?t=https://www.codeavengers.com/" target="_blank" rel="noopener">Code Avengers</a></h2><p>Code Avengers 提供了很多有趣的和互动性的程序设计课程，教你如何编写游戏，应用程序，以及如何使用 JavaScript，HTML 和 CSS 创建网站。每门课程只需要 12 个小时即可完成，并且支持英语，俄语，荷兰语，西班牙语，意大利语，土耳其语和葡萄牙语。</p><h2 id="khan-academy"><a href="https://link.jianshu.com?t=https://www.khanacademy.org/" target="_blank" rel="noopener">Khan Academy</a></h2><p>Khan Academy 由教育家萨尔曼汗创建于 2006 年，是其免费在线学习机构之一。这里提供一步一步的视频教程，你可以在这里学习如何使用 JavaScript 和 ProcessingJS 编写动画，游戏等，或者学习如何使用 HTML 和 CSS 创建网页。</p><h2 id="free-code-camp"><a href="https://www.freecodecamp.cn/" target="_blank" rel="noopener">Free Code Camp</a></h2><p>在这里，你可以学习 HTML5，CSS3，JavaScript，数据库，DevTools，Node.js，Angular.js 和 Agile 的知识。你甚至免费创建自己的应用，以锻炼自己的编程技巧。总之，在这里你可以学习到真正的技能，并且对你解决实际中的问题十分有帮助。</p><h2 id="html5-rocks"><a href="https://www.html5rocks.com/en/" target="_blank" rel="noopener">HTML5 Rocks</a></h2><p>为对抗苹果的 HTML 5，谷歌于 2010 年推出该项目。该网站提供了大量的教程，资源以及最新的 HTML5 更新。它是开源的，因此开发人员可以尽情使用 HTML5 代码。由于这比大多数课程都要先进，因此在这里你肯定会比没来之前获得更多的知识和经验。</p><p>学习编程常常需要看一些比较昂贵的书籍和课程，但是现在由于互联网的发展，市场上有很多可以免费学习编程的网站，所以费用问题就不用太担心了。</p><p>我强烈建议每个企业家都能去学学代码，这对于你成为一个成功的企业家非常有帮助。</p><p>在 entrepreneur 看到这篇文章，也许会对大家有帮助，就拿来翻译一下，需要的朋友可以看一下。有不足之处还请指正，多谢。</p><blockquote><p>写在最最后</p></blockquote><p>本文为译文，所以文章里列举的学编程网站均是来自国外，可能对一些英文不是很好的小伙伴来说用起来有点儿吃力，其实国内也有一些编程学习网站，像网易云课堂、慕课网、极客学院等，大家可以参考一下。但是，如果英文不错的话，Aylee 还是建议大家多看看国外的网站，毕竟代码都是用英文写的吧是吧哈哈～开个玩笑啦～～总之，希望本文对大家会有所帮助吧。</p><hr><blockquote><p>转载于简书作者：Aylee姓Liu</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python解析pcap文件</title>
      <link href="/article/Python%E8%A7%A3%E6%9E%90pcap%E6%96%87%E4%BB%B6/"/>
      <url>/article/Python%E8%A7%A3%E6%9E%90pcap%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>需求：使用Python解析pcap数据包文件，获取基于TCP/IP的应用层协议类型。</p></blockquote><p>使用<font color="#dd0000"> dpkt </font>模块</p><h2 id="dpkt安装">dpkt安装</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install dpkt</span><br></pre></td></tr></table></figure><p>dpkt模块的使用方法，可以查看官网<a href="https://dpkt.readthedocs.io/en/latest/" target="_blank" rel="noopener">dpkt官网</a>。</p><h2 id="了解pcap数据包各层结构如下图所示">了解pcap数据包，各层结构，如下图所示：</h2><p><img src="./OSI.png" alt="alt tcp/ip" title="TCP/IP模型与OSI模型对比"><br>我们要做的就是通过解析，知道应用层是哪一种协议。</p><h2 id="代码实现">代码实现</h2><h3 id="pcap样本文件">pcap样本文件</h3><p>如下图所示：<br><img src="./pcap_tcp.png" alt="alt pcap" title="pcap样本截图"><br>里面有很多基于TCP/IP的协议，如SSH、SMTP和SMB等。</p><h3 id="读取pcap文件">读取pcap文件</h3><p>通过dpkt模块下的Reader()函数读取，并返回文件句柄对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pcap_obj</span><span class="params">(self)</span>:</span></span><br><span class="line">    f = open(self.file)</span><br><span class="line">    <span class="keyword">return</span> dpkt.pcap.Reader(f)</span><br></pre></td></tr></table></figure><h3 id="遍历解析">遍历解析</h3><p>逐层遍历，直到获取TCP层中应用层的数据（payload）, 并写入一个列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tcp_data</span><span class="params">(self)</span>:</span></span><br><span class="line">    pcap = self.get_pcap_obj()</span><br><span class="line">    <span class="keyword">for</span> timestamp, buf <span class="keyword">in</span> pcap:</span><br><span class="line">        <span class="comment"># 解析以太网层</span></span><br><span class="line">        eth = dpkt.ethernet.Ethernet(buf)</span><br><span class="line">        <span class="comment"># 判断是否为IP层，如果不是，下一次循环</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(eth.data, dpkt.ip.IP):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ip = eth.data</span><br><span class="line">        <span class="comment"># 过滤掉UDP</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(ip.data, dpkt.tcp.TCP):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        tcp = ip.data</span><br><span class="line">        self.data_list.append(tcp.data)</span><br><span class="line">    <span class="keyword">return</span> self.data_list</span><br></pre></td></tr></table></figure><h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dpkt</span><br><span class="line"></span><br><span class="line">file = <span class="string">'./base_protoall.pcap'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParsePcap</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pcap_file)</span>:</span></span><br><span class="line">        self.file = pcap_file</span><br><span class="line">        self.data_list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pcap_obj</span><span class="params">(self)</span>:</span></span><br><span class="line">        f = open(self.file)</span><br><span class="line">        <span class="keyword">return</span> dpkt.pcap.Reader(f)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_tcp_data</span><span class="params">(self)</span>:</span></span><br><span class="line">        pcap = self.get_pcap_obj()</span><br><span class="line">        <span class="keyword">for</span> timestamp, buf <span class="keyword">in</span> pcap:</span><br><span class="line">            <span class="comment"># 解析以太网层</span></span><br><span class="line">            eth = dpkt.ethernet.Ethernet(buf)</span><br><span class="line">            <span class="comment"># 判断是否为IP层，如果不是，下一次循环</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isinstance(eth.data, dpkt.ip.IP):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            ip = eth.data</span><br><span class="line">            <span class="comment"># 过滤掉UDP</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isinstance(ip.data, dpkt.tcp.TCP):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            tcp = ip.data</span><br><span class="line">            self.data_list.append(tcp.data)</span><br><span class="line">        <span class="keyword">return</span> self.data_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parse = ParsePcap(file)</span><br><span class="line">    data_list = parse.get_tcp_data()</span><br><span class="line">    <span class="keyword">for</span> tcp <span class="keyword">in</span> data_list:</span><br><span class="line">        <span class="keyword">print</span> tcp</span><br></pre></td></tr></table></figure><h3 id="运行结果">运行结果</h3><p><img src="./goland.png" alt="alt goland" title="运行截图"></p><p>与通过wireshark查看的payload数据是相同的。</p><p><img src="./wireshark.png" alt="alt wireshark" title="wireshark截图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dep使用</title>
      <link href="/article/dep%E4%BD%BF%E7%94%A8/"/>
      <url>/article/dep%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="dep简介">dep简介</h2><p><font color="#dd0000">dep</font>是一个golang项目的包管理工具，一般只需要2-3个命令就可以将go依赖包自动下载并归档到<font color="#dd0000">vender</font>的目录中。dep官网参考：<a href="https://github.com/golang/dep" target="_blank" rel="noopener">https://github.com/golang/dep</a></p><h2 id="dep安装">dep安装</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/golang/dep/cmd/dep</span><br></pre></td></tr></table></figure><h2 id="dep使用">dep使用</h2><h3 id="进入到项目目录">进入到项目目录</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/gopath/src/demo</span><br></pre></td></tr></table></figure><h3 id="dep初始化初始化配置文件gopkgtoml">dep初始化，初始化配置文件Gopkg.toml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep init</span><br></pre></td></tr></table></figure><h3 id="dep加载依赖包自动归档到vendor目录">dep加载依赖包，自动归档到vendor目录</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep ensure</span><br></pre></td></tr></table></figure><p>最终会生成vendor目录，Gopkg.toml和Gopkg.lock的文件</p><h2 id="dep的配置文件">dep的配置文件</h2><p><font color="#dd0000">Gopkg.toml</font>记录依赖包列表。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># Gopkg.toml example</span><br><span class="line">#</span><br><span class="line"># Refer to https:<span class="comment">//golang.github.io/dep/docs/Gopkg.toml.html</span></span><br><span class="line"># <span class="keyword">for</span> detailed Gopkg.toml documentation.</span><br><span class="line">#</span><br><span class="line"># required = [<span class="string">"github.com/user/thing/cmd/thing"</span>]</span><br><span class="line"># ignored = [<span class="string">"github.com/user/project/pkgX"</span>, <span class="string">"bitbucket.org/user/project/pkgA/pkgY"</span>]</span><br><span class="line">#</span><br><span class="line"># [[constraint]]</span><br><span class="line">#   name = <span class="string">"github.com/user/project"</span></span><br><span class="line">#   version = <span class="string">"1.0.0"</span></span><br><span class="line">#</span><br><span class="line"># [[constraint]]</span><br><span class="line">#   name = <span class="string">"github.com/user/project2"</span></span><br><span class="line">#   branch = <span class="string">"dev"</span></span><br><span class="line">#   source = <span class="string">"github.com/myfork/project2"</span></span><br><span class="line">#</span><br><span class="line"># [[override]]</span><br><span class="line">#   name = <span class="string">"github.com/x/y"</span></span><br><span class="line">#   version = <span class="string">"2.4.0"</span></span><br><span class="line">#</span><br><span class="line"># [prune]</span><br><span class="line">#   non-<span class="keyword">go</span> = <span class="literal">false</span></span><br><span class="line">#   <span class="keyword">go</span>-tests = <span class="literal">true</span></span><br><span class="line">#   unused-packages = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">ignored = [<span class="string">"demo"</span>]</span><br><span class="line"></span><br><span class="line">[[constraint]]</span><br><span class="line">  name = <span class="string">"github.com/BurntSushi/toml"</span></span><br><span class="line">  version = <span class="string">"0.3.0"</span></span><br><span class="line">  </span><br><span class="line">[prune]</span><br><span class="line">  <span class="keyword">go</span>-tests = <span class="literal">true</span></span><br><span class="line">  unused-packages = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="dep-help">dep-help</h2><p>更多<font color="#dd0000">dep</font>的命令帮助参考<font color="#dd0000">dep</font>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ dep</span><br><span class="line">Dep is a tool <span class="keyword">for</span> managing dependencies <span class="keyword">for</span> Go projects</span><br><span class="line"></span><br><span class="line">Usage: <span class="string">"dep [command]"</span></span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line"></span><br><span class="line">  init     Set up a <span class="built_in">new</span> Go project, or migrate an existing one</span><br><span class="line">  status   Report the status of the project<span class="string">'s dependencies</span></span><br><span class="line"><span class="string">  ensure   Ensure a dependency is safely vendored in the project</span></span><br><span class="line"><span class="string">  prune    Pruning is now performed automatically by dep ensure.</span></span><br><span class="line"><span class="string">  version  Show the dep version information</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Examples:</span></span><br><span class="line"><span class="string">  dep init                               set up a new project</span></span><br><span class="line"><span class="string">  dep ensure                             install the project'</span>s dependencies</span><br><span class="line">  dep ensure -update                     update the locked versions of all dependencies</span><br><span class="line">  dep ensure -add github.com/pkg/errors  add a dependency to the project</span><br><span class="line"></span><br><span class="line">Use <span class="string">"dep help [command]"</span> <span class="keyword">for</span> more information about a command.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> dep </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>etcd常用命令</title>
      <link href="/article/etcd%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/article/etcd%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="etcdctl介绍">etcdctl介绍</h2><hr><p>etcdctl是一个命令行的客户端，它提供了一下简洁的命令，可理解为命令工具集，可以方便我们在对服务进行测试或者手动修改数据库内容。etcdctl与其他xxxctl的命令原理及操作类似（例如kubectl，systemctl）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用法：etcdctl \[global options\] command \[command options\]\[args…\]</span><br></pre></td></tr></table></figure><h2 id="etcd常用命令">Etcd常用命令</h2><hr><h3 id="数据库操作命令">数据库操作命令</h3><p>etcd 在键的组织上采用了层次化的空间结构（类似于文件系统中目录的概念），数据库操作围绕对键值和目录的 CRUD [增删改查]（符合 REST 风格的一套操作：Create, Read, Update, Delete）完整生命周期的管理。</p><p>具体的命令选项参数可以通过 etcdctl command --help来获取相关帮助。</p><h4 id="对象为键值">对象为键值</h4><ul><li><p>set增无论是否存在etcdctl-set-key-value)set[增:无论是否存在]:etcdctl set key value</p></li><li><p>mk增必须不存在etcdctl-mk-key-value)mk[增:必须不存在]:etcdctl mk key value</p></li><li><p>rm删etcdctl-rm-key)rm[删]:etcdctl rm key</p></li><li><p>update改etcdctl-update-key-value)update[改]:etcdctl update key value</p></li><li><p>get查etcdctl-get-key)get[查]:etcdctl get key</p></li></ul><h4 id="对象为目录">对象为目录</h4><ul><li><p>setdir增无论是否存在etcdctl-setdir-dir)setdir[增:无论是否存在]:etcdctl setdir dir</p></li><li><p>mkdir增必须不存在-etcdctl-mkdir-dir)mkdir[增:必须不存在]: etcdctl mkdir dir</p></li><li><p>rmdir删etcdctl-rmdir-dir)rmdir[删]:etcdctl rmdir dir</p></li><li><p>updatedir改etcdctl-updatedir-dir)updatedir[改]:etcdctl updatedir dir</p></li><li><p>ls查etcdclt-ls)ls[查]:etcdclt ls</p></li></ul><h3 id="非数据库操作命令">非数据库操作命令</h3><ul><li>backup备份-etcd-的数据)backup[备份 etcd 的数据]</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl backup</span><br></pre></td></tr></table></figure><ul><li>watch监测一个键值的变化一旦键值发生更新就会输出最新的值并退出)watch[监测一个键值的变化，一旦键值发生更新，就会输出最新的值并退出]</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl watch key</span><br></pre></td></tr></table></figure><ul><li>exec-watch监测一个键值的变化一旦键值发生更新就执行给定命令)exec-watch[监测一个键值的变化，一旦键值发生更新，就执行给定命令]</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl <span class="built_in">exec</span>-watch key --sh -c “ls”</span><br></pre></td></tr></table></figure><ul><li>member通过-list-add-remove-update-命令列出-添加-删除-更新etcd-实例到-etcd-集群中)member[通过 list、add、remove、update 命令列出、添加、删除 、更新etcd 实例到 etcd 集群中]</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl member list；etcdctl member add 实例；etcdctl member remove 实例；etcdctl member update 实例。</span><br></pre></td></tr></table></figure><ul><li>etcdctl-cluster-health检查集群健康状态)etcdctl cluster-health[检查集群健康状态]</li></ul><h3 id="常用配置参数">常用配置参数</h3><p>设置配置文件，默认为/etc/etcd/etcd.conf。</p><table><thead><tr><th>配置参数</th><th>参数说明</th></tr></thead><tbody><tr><td>-name</td><td>节点名称</td></tr><tr><td>-data-dir</td><td>保存日志和快照的目录，默认为当前工作目录，指定节点的数据存储目录</td></tr><tr><td>-addr</td><td>公布的ip地址和端口。 默认为127.0.0.1:2379</td></tr><tr><td>-bind-addr</td><td>用于客户端连接的监听地址，默认为-addr配置</td></tr><tr><td>-peers</td><td>集群成员逗号分隔的列表，例如 127.0.0.1:2380,127.0.0.1:2381</td></tr><tr><td>-peer-addr</td><td>集群服务通讯的公布的IP地址，默认为 127.0.0.1:2380.</td></tr><tr><td>-peer-bind-addr</td><td>集群服务通讯的监听地址，默认为-peer-addr配置</td></tr><tr><td>-wal-dir</td><td>指定节点的was文件的存储目录，若指定了该参数，wal文件会和其他数据文件分开存储</td></tr><tr><td>-listen-client-urls</td><td>监听URL，用于与其他节点通讯</td></tr><tr><td>-listen-peer-urls</td><td>监听URL，用于与其他节点通讯</td></tr><tr><td>-initial-advertise-peer-urls</td><td>告知集群其他节点url.</td></tr><tr><td>-advertise-client-urls</td><td>告知客户端url, 也就是服务的url</td></tr><tr><td>-initial-cluster-token</td><td>集群的ID</td></tr><tr><td>-initial-cluster</td><td>集群中所有节点</td></tr><tr><td>-initial-cluster-state</td><td>-initial-cluster-state=new 表示从无到有搭建etcd集群</td></tr><tr><td>-discovery-srv</td><td>用于DNS动态服务发现，指定DNS SRV域名</td></tr><tr><td>-discovery</td><td>用于etcd动态发现，指定etcd发现服务的URL [<a href="https://discovery.etcd.io/" target="_blank" rel="noopener">https://discovery.etcd.io/</a>],用环境变量表示</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基于etcd实现分布式锁</title>
      <link href="/article/golang%E5%9F%BA%E4%BA%8Eetcd%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/article/golang%E5%9F%BA%E4%BA%8Eetcd%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>我们希望同一时间只有一个线程能够访问到资源，但是分布式资源点之间的协调会非常麻烦，这个时候我们就需要一个分布式锁。</p><h3 id="etcd分布式锁实现原理">etcd分布式锁实现原理：</h3><p>1.利用租约在etcd集群中创建一个key，这个key有两种形态，存在和不存在，而这两种形态就是互斥量。<br>2.如果这个key不存在，那么线程创建key，成功则获取到锁，该key就为存在状态。<br>3.如果该key已经存在，那么线程就不能创建key，则获取锁失败。</p><h3 id="锁结构体">锁结构体：</h3><p>在使用该锁时，需要传入Ttl,Conf,Key字段来初始化锁</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EtcdMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Ttl <span class="keyword">int64</span>  <span class="comment">//租约时间</span></span><br><span class="line">    Conf clientv3.Config  <span class="comment">//etcd集群配置</span></span><br><span class="line">    Key <span class="keyword">string</span>   <span class="comment">//etcd的key</span></span><br><span class="line">    cancel context.CancelFunc  <span class="comment">//关闭续租的func</span></span><br><span class="line">    lease clientv3.Lease</span><br><span class="line">    leaseID clientv3.LeaseID</span><br><span class="line">    txn clientv3.Txn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化锁">初始化锁：</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(em *EtcdMutex)</span><span class="title">init</span><span class="params">()</span><span class="title">error</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">var</span> ctx context.Context</span><br><span class="line">    client,err := clientv3.New(em.Conf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    em.txn = clientv3.NewKV(client).Txn(context.TODO())</span><br><span class="line">    em.lease = clientv3.NewLease(client)</span><br><span class="line">    leaseResp,err := em.lease.Grant(context.TODO(),em.Ttl)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    ctx,em.cancel = context.WithCancel(context.TODO())</span><br><span class="line">    em.leaseID = leaseResp.ID</span><br><span class="line">    _,err = em.lease.KeepAlive(ctx,em.leaseID)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取锁">获取锁:</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(em *EtcdMutex)</span><span class="title">Lock</span><span class="params">()</span><span class="title">error</span></span>&#123;</span><br><span class="line">    err := em.init()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//LOCK:</span></span><br><span class="line">        em.txn.If(clientv3.Compare(clientv3.CreateRevision(em.Key),<span class="string">"="</span>,<span class="number">0</span>)).</span><br><span class="line">            Then(clientv3.OpPut(em.Key,<span class="string">""</span>,clientv3.WithLease(em.leaseID))).</span><br><span class="line">            Else()</span><br><span class="line">    txnResp,err := em.txn.Commit()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !txnResp.Succeeded&#123;   <span class="comment">//判断txn.if条件是否成立</span></span><br><span class="line">        <span class="keyword">return</span> fmt.Errof(<span class="string">"抢锁失败"</span>)        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放锁">释放锁：</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(em *EtcdMutex)</span><span class="title">UnLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    em.cancel()</span><br><span class="line">    em.lease.Revoke(context.TODO(),em.leaseID)</span><br><span class="line">    fmt.Println(<span class="string">"释放了锁"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用锁">调用锁：</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> conf = clientv3.Config&#123;</span><br><span class="line">        Endpoints:   []<span class="keyword">string</span>&#123;<span class="string">"172.16.196.129:2380"</span>, <span class="string">"192.168.50.250:2380"</span>&#125;,</span><br><span class="line">        DialTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">    &#125;</span><br><span class="line">    eMutex1 := &amp;EtcdMutex&#123;</span><br><span class="line">        Conf:conf,</span><br><span class="line">        Ttl:<span class="number">10</span>,</span><br><span class="line">        Key:<span class="string">"lock"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">     eMutex2 := &amp;EtcdMutex&#123;</span><br><span class="line">        Conf:conf,</span><br><span class="line">        Ttl:<span class="number">10</span>,</span><br><span class="line">        Key:<span class="string">"lock"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//groutine1 </span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        err := eMutex1.Lock()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">            fmt.Println(<span class="string">"groutine1抢锁失败"</span>)</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"groutine1抢锁成功"</span>)</span><br><span class="line">        time.Sleep(<span class="number">10</span>*time.Second)</span><br><span class="line">        <span class="keyword">defer</span> eMutex.UnLock()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//groutine2</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        err := eMutex2.Lock()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">            fmt.Println(<span class="string">"groutine2抢锁失败"</span>)</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"groutine2抢锁成功"</span>)</span><br><span class="line">        <span class="keyword">defer</span> eMutex.UnLock()</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(<span class="number">30</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>etcd应用场景</title>
      <link href="/article/etcd%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/article/etcd%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>提到etcd很多人第一反应就是一个键值存储仓库。不过etcd官方文档的定义却是这样的：</p><blockquote><p>A highly-available key value store for shared configuration and service discovery.</p></blockquote><h4 id="包含了配置共享和服务发现">包含了配置共享和服务发现。</h4><p>etcd作为一个受到ZooKeeper与doozer启发而催生的项目，除了拥有与之类似的功能外，更专注于以下四点。</p><ul><li>简单：基于HTTP+JSON的API让你用curl就可以轻松使用。</li><li>安全：可选SSL客户认证机制。</li><li>快速：每个实例每秒支持一千次写操作。</li><li>可信：使用Raft算法充分实现了分布式。</li></ul><p>接下来将针对剖析一些etcd的经典使用场景，来看看etcd这个基于Raft强一致性算法的分布式存储仓库能给我们带来哪些帮助。</p><blockquote><p>值得注意的是，分布式系统中的数据分为控制数据和应用数据。使用etcd的场景默认处理的数据都是控制数据，对于应用数据，只推荐数据量很小，但是更新访问频繁的情况。</p></blockquote><h3 id="场景一服务发现">场景一：服务发现</h3><p>在分布式系统中“服务发现”也是比较常见的问题：在同一个集群环境中不同的应用或服务，如何能够找到对方并建立连接，来完成后续的行为。本质上来说，服务发现就是想要知道集群中是否有进程在监听udp或tcp端口，并能通过名字就可以查找和连接。而要解决服务发现的问题，需要满足如下三个方面，缺一不可。</p><ol><li>一个强一致性、高可用的服务存储目录： 基于Raft算法的etcd天生就是这样一个强一致性高可用的服务存储目录【安全的记录集群中的应用或服务的信息(地址、端口等)】。</li><li>一种注册服务和监控服务健康状态的机制：用户可以在etcd中注册服务，并且对注册的服务设置key TTL，定时保持服务的心跳以达到监控健康状态的效果。【能够完成新的应用或服务的注册添加进来，同样也能对现有的服务是否可用进行监控】</li><li>一种查找和连接服务的机制： 通过在etcd指定的主题下注册的服务也能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个Proxy模式的etcd，这样就可以确保能访问etcd集群的服务都能互相连接。【已有的服务当被使用能够被找到并能连接】</li></ol><p><img src="./%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.jpg" alt=""></p><p>来看服务发现对应的具体场景：</p><ul><li>微服务协同工作架构中，服务动态添加。随着Docker容器的流行，多种微服务共同协作，构成一个相对功能强大的架构的案例越来越多。透明化的动态添加这些服务的需求也日益强烈。通过服务发现机制，在etcd中注册某个服务名字的目录，在该目录下存储可用的服务节点的IP。在使用服务的过程中，只要从服务目录下查找可用的服务节点去使用即可。</li></ul><p><img src="./%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8D%8F%E5%90%8C.jpg" alt=""></p><ul><li>PaaS平台中应用多实例与实例故障重启透明化。PaaS平台中的应用一般都有多个实例，通过域名，不仅可以透明的对这多个实例进行访问，而且还可以做到负载均衡。但是应用的某个实例随时都有可能故障重启，这时就需要动态的配置域名解析（路由）中的信息。通过etcd的服务发现功能就可以轻松解决这个动态配置的问题。</li></ul><p><img src="./cloud.jpg" alt=""></p><h3 id="场景二消息发布与订阅">场景二：消息发布与订阅</h3><p>在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。通过这种方式可以做到分布式系统配置的集中式管理与动态更新。</p><ul><li>应用中用到的一些配置信息放到etcd上进行集中管理。这类场景的使用方式通常是这样：应用在启动的时候主动从etcd获取一次配置信息，同时，在etcd节点上注册一个Watcher并等待，以后每次配置有更新的时候，etcd都会实时通知订阅者，以此达到获取最新配置信息的目的。</li><li>分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在etcd中，供各个客户端订阅使用。使用etcd的key TTL功能可以确保机器状态是实时更新的。</li><li>分布式日志收集系统。这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用（或主题）来分配收集任务单元，因此可以在etcd上创建一个以应用（主题）命名的目录P，并将这个应用（主题相关）的所有机器ip，以子目录的形式存储到目录P上，然后设置一个etcd递归的Watcher，递归式的监控应用（主题）目录下所有信息的变动。这样就实现了机器IP（消息）变动的时候，能够实时通知到收集器调整任务分配。</li><li>系统中信息需要动态自动获取与人工干预修改信息请求内容的情况。通常是暴露出接口，例如JMX接口，来获取一些运行时的信息。引入etcd之后，就不用自己实现一套方案了，只要将这些信息存放到指定的etcd目录中即可，etcd的这些目录就可以通过HTTP的接口在外部访问。</li></ul><p><img src="./message.jpg" alt=""></p><h3 id="场景三负载均衡">场景三：负载均衡</h3><p>在场景一中也提到了负载均衡，本文所指的负载均衡均为软负载均衡。分布式系统中，为了保证服务的高可用以及数据的一致性，通常都会把数据和服务部署多份，以此达到对等服务，即使其中的某一个服务失效了，也不影响使用。由此带来的坏处是数据写入性能下降，而好处则是数据访问时的负载均衡。因为每个对等服务节点上都存有完整的数据，所以用户的访问流量就可以分流到不同的机器上。</p><ul><li>etcd本身分布式架构存储的信息访问支持负载均衡。etcd集群化以后，每个etcd的核心节点都可以处理用户的请求。所以，把数据量小但是访问频繁的消息数据直接存储到etcd中也是个不错的选择，如业务系统中常用的二级代码表（在表中存储代码，在etcd中存储代码所代表的具体含义，业务系统调用查表的过程，就需要查找表中代码的含义）。</li><li>利用etcd维护一个负载均衡节点表。etcd可以监控一个集群中多个节点的状态，当有一个请求发过来后，可以轮询式的把请求转发给存活着的多个状态。类似KafkaMQ，通过ZooKeeper来维护生产者和消费者的负载均衡。同样也可以用etcd来做ZooKeeper的工作。</li></ul><p><img src="./%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.jpg" alt=""></p><h3 id="场景四分布式通知与协调">场景四：分布式通知与协调</h3><p>这里说到的分布式通知与协调，与消息发布和订阅有些相似。都用到了etcd中的Watcher机制，通过注册与异步通知机制，实现分布式环境下不同系统之间的通知与协调，从而对数据变更做到实时处理。实现方式通常是这样：不同系统都在etcd上对同一个目录进行注册，同时设置Watcher观测该目录的变化（如果对子目录的变化也有需要，可以设置递归模式），当某个系统更新了etcd的目录，那么设置了Watcher的系统就会收到通知，并作出相应处理。</p><ul><li>通过etcd进行低耦合的心跳检测。检测系统和被检测系统通过etcd上某个目录关联而非直接关联起来，这样可以大大减少系统的耦合性。</li><li>通过etcd完成系统调度。某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了etcd上某些目录节点的状态，而etcd就把这些变化通知给注册了Watcher的推送系统客户端，推送系统再作出相应的推送任务。</li><li>通过etcd完成工作汇报。大部分类似的任务分发系统，子任务启动后，到etcd来注册一个临时工作目录，并且定时将自己的进度进行汇报（将进度写入到这个临时目录），这样任务管理者就能够实时知道任务进度。</li></ul><p><img src="./%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C.jpg" alt=""></p><h3 id="场景五分布式锁">场景五：分布式锁</h3><p>因为etcd使用Raft算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。</p><ul><li>保持独占即所有获取锁的用户最终只有一个可以得到。etcd为此提供了一套实现分布式锁原子操作CAS（CompareAndSwap）的API。通过设置prevExist值，可以保证在多个节点同时去创建某个目录时，只有一个成功。而创建成功的用户就可以认为是获得了锁。</li><li>控制时序，即所有想要获得锁的用户都会被安排执行，但是获得锁的顺序也是全局唯一的，同时决定了执行顺序。etcd为此也提供了一套API（自动创建有序键），对一个目录建值时指定为POST动作，这样etcd会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用API按顺序列出所有当前目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。</li></ul><p><img src="./%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.jpg" alt=""></p><h3 id="场景六分布式队列">场景六：分布式队列</h3><p>分布式队列的常规用法与场景五中所描述的分布式锁的控制时序用法类似，即创建一个先进先出的队列，保证顺序。</p><p>另一种比较有意思的实现是在保证队列达到某个条件时再统一按顺序执行。这种方法的实现可以在/queue这个目录中另外建立一个/queue/condition节点。</p><ul><li>condition可以表示队列大小。比如一个大的任务需要很多小任务就绪的情况下才能执行，每次有一个小任务就绪，就给这个condition数字加1，直到达到大任务规定的数字，再开始执行队列里的一系列小任务，最终执行大任务。</li><li>condition可以表示某个任务在不在队列。这个任务可以是所有排序任务的首个执行程序，也可以是拓扑结构中没有依赖的点。通常，必须执行这些任务后才能执行队列中的其他任务。</li><li>condition还可以表示其它的一类开始执行任务的通知。可以由控制程序指定，当condition出现变化时，开始执行队列任务。</li></ul><p><img src="./%E5%88%86%E5%B8%83%E5%BC%8F%E9%98%9F%E5%88%97.jpg" alt=""></p><h3 id="场景七集群监控与leader竞选">场景七：集群监控与Leader竞选</h3><p>通过etcd来进行监控实现起来非常简单并且实时性强。</p><ol><li>前面几个场景已经提到Watcher机制，当某个节点消失或有变动时，Watcher会第一时间发现并告知用户。</li><li>节点可以设置TTL key，比如每隔30s发送一次心跳使代表该机器存活的节点继续存在，否则节点消失。</li></ol><p>这样就可以第一时间检测到各节点的健康状态，以完成集群的监控要求。</p><p>另外，使用分布式锁，可以完成Leader竞选。这种场景通常是一些长时间CPU计算或者使用IO操作的机器，只需要竞选出的Leader计算或处理一次，就可以把结果复制给其他的Follower。从而避免重复劳动，节省计算资源。</p><p>这个的经典场景是搜索系统中建立全量索引。如果每个机器都进行一遍索引的建立，不但耗时而且建立索引的一致性不能保证。通过在etcd的CAS机制同时创建一个节点，创建成功的机器作为Leader，进行索引计算，然后把计算结果分发到其它节点。</p><p><img src="./leader.jpg" alt=""></p><h3 id="场景八为什么用etcd而不用zookeeper">场景八：为什么用etcd而不用ZooKeeper？</h3><p>etcd实现的这些功能，ZooKeeper都能实现。那么为什么要用etcd而非直接使用ZooKeeper呢？</p><p>相较之下，ZooKeeper有如下缺点：</p><ol><li>复杂。ZooKeeper的部署维护复杂，管理员需要掌握一系列的知识和技能；而Paxos强一致性算法也是素来以复杂难懂而闻名于世；另外，ZooKeeper的使用也比较复杂，需要安装客户端，官方只提供了Java和C两种语言的接口。</li><li>Java编写。这里不是对Java有偏见，而是Java本身就偏向于重型应用，它会引入大量的依赖。而运维人员则普遍希望保持强一致、高可用的机器集群尽可能简单，维护起来也不易出错。</li><li>发展缓慢。Apache基金会项目特有的<a href="http://www.infoworld.com/article/2612082/open-source-software/has-apache-lost-its-way-.html" target="_blank" rel="noopener">“Apache Way”</a>在开源界饱受争议，其中一大原因就是由于基金会庞大的结构以及松散的管理导致项目发展缓慢。</li></ol><p>而etcd作为一个后起之秀，其优点也很明显。</p><ol><li>简单。使用Go语言编写部署简单；使用HTTP作为接口使用简单；使用Raft算法保证强一致性让用户易于理解。</li><li>数据持久化。etcd默认数据一更新就进行持久化。</li><li>安全。etcd支持SSL客户端安全认证。</li></ol><p>最后，etcd作为一个年轻的项目，真正告诉迭代和开发中，这既是一个优点，也是一个缺点。优点是它的未来具有无限的可能性，缺点是无法得到大项目长时间使用的检验。然而，目前CoreOS、Kubernetes和CloudFoundry等知名项目均在生产环境中使用了etcd，所以总的来说，etcd值得你去尝试。</p><h2 id="后续etcd实现原理解读">后续：etcd实现原理解读</h2><h3 id="架构">架构</h3><p><img src="./etcd%E6%9E%B6%E6%9E%84.jpg" alt=""></p><p>从etcd的架构图中我们可以看到，etcd主要分为四个部分。</p><ul><li>HTTP Server： 用于处理用户发送的API请求以及其它etcd节点的同步与心跳信息请求。</li><li>Store：用于处理etcd支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是etcd对用户提供的大多数API功能的具体实现。</li><li>Raft：Raft强一致性算法的具体实现，是etcd的核心。</li><li>WAL：Write Ahead Log（预写式日志），是etcd的数据存储方式。除了在内存中存有所有数据的状态以及节点的索引以外，etcd就通过WAL进行持久化存储。WAL中，所有的数据提交前都会事先记录日志。Snapshot是为了防止数据过多而进行的状态快照；Entry表示存储的具体日志内容。</li></ul><p>通常，一个用户的请求发送过来，会经由HTTP Server转发给Store进行具体的事务处理，如果涉及到节点的修改，则交给Raft模块进行状态的变更、日志的记录，然后再同步给别的etcd节点以确认数据提交，最后进行数据的提交，再次同步。</p><h3 id="新版etcd重要变更列表">新版etcd重要变更列表</h3><ul><li>获得了IANA认证的端口，2379用于客户端通信，2380用于节点通信，与原先的（4001 peers / 7001 clients）共用。</li><li>每个节点可监听多个广播地址。监听的地址由原来的一个扩展到多个，用户可以根据需求实现更加复杂的集群环境，如一个是公网IP，一个是虚拟机（容器）之类的私有IP。</li><li>etcd可以代理访问leader节点的请求，所以如果你可以访问任何一个etcd节点，那么你就可以无视网络的拓扑结构对整个集群进行读写操作。</li><li>etcd集群和集群中的节点都有了自己独特的ID。这样就防止出现配置混淆，不是本集群的其他etcd节点发来的请求将被屏蔽。</li><li>etcd集群启动时的配置信息目前变为完全固定，这样有助于用户正确配置和启动。</li><li>运行时节点变化(Runtime Reconfiguration)。用户不需要重启 etcd 服务即可实现对 etcd 集群结构进行变更。启动后可以动态变更集群配置。</li><li>重新设计和实现了Raft算法，使得运行速度更快，更容易理解，包含更多测试代码。</li><li>Raft日志现在是严格的只能向后追加、预写式日志系统，并且在每条记录中都加入了CRC校验码。</li><li>启动时使用的_etcd/* 关键字不再暴露给用户</li><li>废弃集群自动调整功能的standby模式，这个功能使得用户维护集群更困难。</li><li>新增Proxy模式，不加入到etcd一致性集群中，纯粹进行代理转发。</li><li>ETCD_NAME（-name）参数目前是可选的，不再用于唯一标识一个节点。</li><li>摒弃通过配置文件配置 etcd 属性的方式，你可以用环境变量的方式代替。</li><li>通过自发现方式启动集群必须要提供集群大小，这样有助于用户确定集群实际启动的节点数量。</li></ul><h3 id="etcd概念词汇表">etcd概念词汇表</h3><ul><li>Raft：etcd所采用的保证分布式系统强一致性的算法。</li><li>Node：一个Raft状态机实例。</li><li>Member： 一个etcd实例。它管理着一个Node，并且可以为客户端请求提供服务。</li><li>Cluster：由多个Member构成可以协同工作的etcd集群。</li><li>Peer：对同一个etcd集群中另外一个Member的称呼。</li><li>Client： 向etcd集群发送HTTP请求的客户端。</li><li>WAL：预写式日志，etcd用于持久化存储的日志格式。</li><li>snapshot：etcd防止WAL文件过多而设置的快照，存储etcd数据状态。</li><li>Proxy：etcd的一种模式，为etcd集群提供反向代理服务。</li><li>Leader：Raft算法中通过竞选而产生的处理所有数据提交的节点。</li><li>Follower：竞选失败的节点作为Raft中的从属节点，为算法提供强一致性保证。</li><li>Candidate：当Follower超过一定时间接收不到Leader的心跳时转变为Candidate开始竞选。</li><li>Term：某个节点成为Leader到下一次竞选时间，称为一个Term。</li><li>Index：数据项编号。Raft中通过Term和Index来定位数据。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花花与三猫CatLive-第二篇</title>
      <link href="/article/%E8%8A%B1%E8%8A%B1%E4%B8%8E%E4%B8%89%E7%8C%ABCatLive-%E7%AC%AC%E4%BA%8C%E7%AF%87/"/>
      <url>/article/%E8%8A%B1%E8%8A%B1%E4%B8%8E%E4%B8%89%E7%8C%ABCatLive-%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="花花与三猫的养猫日常-给猫咪洗屁屁">花花与三猫的养猫日常 :给猫咪洗屁屁!</h2><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"theme":"#FADFA3","loop":true,"video":{"url":"https://vdse.bdstatic.com/c973beddb915910024b4ad72c7080474.mp4","pic":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1575045065&di=3a926764f3c280d97a71f67dbfa06ecb&imgtype=jpg&er=1&src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2F5ba90764c07e49e0315523ce4aafc580dbad2b1c.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      
      
        <tags>
            
            <tag> 猫咪 </tag>
            
            <tag> 短视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花花与三猫CatLive-第一篇</title>
      <link href="/article/%E8%8A%B1%E8%8A%B1%E4%B8%8E%E4%B8%89%E7%8C%ABCatLive/"/>
      <url>/article/%E8%8A%B1%E8%8A%B1%E4%B8%8E%E4%B8%89%E7%8C%ABCatLive/</url>
      
        <content type="html"><![CDATA[<h2 id="花花与三猫的养猫日常-橘猫吃播开始吃海鲜了">花花与三猫的养猫日常 :橘猫吃播开始吃海鲜了</h2><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"theme":"#FADFA3","loop":true,"video":{"url":"https://vdse.bdstatic.com/28fee90459ac36d58cbeaa01689a8354.mp4","pic":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1575045065&di=3a926764f3c280d97a71f67dbfa06ecb&imgtype=jpg&er=1&src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2F5ba90764c07e49e0315523ce4aafc580dbad2b1c.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      
      
        <tags>
            
            <tag> 猫咪 </tag>
            
            <tag> 短视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python与C混合编程遇到的问题</title>
      <link href="/article/Python%E4%B8%8EC%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/article/Python%E4%B8%8EC%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="相互调用的方式选择">相互调用的方式选择</h2><p>在做项目时，调研过两种方式：一是扩展Python ctypes 类型；二是引入Python开发文件实现Python的扩展。</p><h3 id="扩展-ctypes-类型">扩展 ctypes 类型</h3><p>项目中遇到的第一个需要扩展的地方是，C/C++项目中用了C++ stl::vector。问题来了，在Python 的 ctypes 中没相关类型的封装呀，于是第一时间想到的是扩展 ctypes 类型。可是在实现的时候才发现这种方式是有多麻烦。</p><h4 id="编写-c-gt-python-的接口文件">编写 c =&gt; python 的接口文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vectory_py.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">point_t</span>&gt;* new_vector()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">point_t</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete_vector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">point_t</span>&gt;* v)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor called in C++ for "</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">vector_size</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">point_t</span>&gt;* v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v-&gt;size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">point_t</span> vector_get(<span class="built_in">vector</span>&lt;<span class="keyword">point_t</span>&gt;* v, <span class="keyword">int</span> i)&#123;</span><br><span class="line">        <span class="keyword">return</span> v-&gt;at(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">vector_push_back</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">point_t</span>&gt;* v, <span class="keyword">point_t</span> i)</span></span>&#123;</span><br><span class="line">        v-&gt;push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译： gcc -fPIC -shared -lpython3.6m -o vector_py.so vectory_py.c</p></blockquote><h4 id="编写-ctypes-类型文件">编写 ctypes 类型文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c_point_t</span><span class="params">(Structure)</span>:</span></span><br><span class="line">    _fields_ = [(<span class="string">"x"</span>, c_int), (<span class="string">"y"</span>, c_int)]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span><span class="params">(object)</span>:</span></span><br><span class="line">    lib = cdll.LoadLibrary(<span class="string">'./vector_py_lib.so'</span>) <span class="comment"># class level loading lib</span></span><br><span class="line">    lib.new_vector.restype = c_void_p</span><br><span class="line">    lib.new_vector.argtypes = []</span><br><span class="line">    lib.delete_vector.restype = <span class="keyword">None</span></span><br><span class="line">    lib.delete_vector.argtypes = [c_void_p]</span><br><span class="line">    lib.vector_size.restype = c_int</span><br><span class="line">    lib.vector_size.argtypes = [c_void_p]</span><br><span class="line">    lib.vector_get.restype = c_point_t</span><br><span class="line">    lib.vector_get.argtypes = [c_void_p, c_int]</span><br><span class="line">    lib.vector_push_back.restype = <span class="keyword">None</span></span><br><span class="line">    lib.vector_push_back.argtypes = [c_void_p, c_point_t]</span><br><span class="line">    lib.foo.restype = <span class="keyword">None</span></span><br><span class="line">    lib.foo.argtypes = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.vector = Vector.lib.new_vector()  <span class="comment"># pointer to new vector</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span>  <span class="comment"># when reference count hits 0 in Python,</span></span><br><span class="line">        Vector.lib.delete_vector(self.vector)  <span class="comment"># call C++ vector destructor</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Vector.lib.vector_size(self.vector)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, i)</span>:</span>  <span class="comment"># access elements in vector at index</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; len(self):</span><br><span class="line">            <span class="keyword">return</span> Vector.lib.vector_get(self.vector, c_int(i))</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">'Vector index out of range'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'[&#123;&#125;]'</span>.format(<span class="string">', '</span>.join(str(self[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self))))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, i)</span>:</span>  <span class="comment"># push calls vector's push_back</span></span><br><span class="line">        Vector.lib.vector_push_back(self.vector, i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span>  <span class="comment"># foo in Python calls foo in C++</span></span><br><span class="line">        Vector.lib.foo(self.vector)</span><br></pre></td></tr></table></figure><h4 id="然后才是调用">然后才是调用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> vector <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = Vector()</span><br><span class="line">b = c_point_t(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">a.push(b)</span><br><span class="line">a.foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)) :</span><br><span class="line">    print(a[i].x)</span><br><span class="line">    print(a[i].y)</span><br></pre></td></tr></table></figure><h3 id="为python写扩展">为Python写扩展</h3><p>完成上述的操作后，我头很大，很难想象当项目稍微修改后，我们要跟随变化的代码量有多大！于是换了一种思路，为Python写扩展。</p><h4 id="安装python开发包">安装Python开发包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y python36-devel</span><br></pre></td></tr></table></figure><h4 id="修改数据交互文件">修改数据交互文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;python3.6m/Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">PyObject* <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyObject* result = PyList_New(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">        PyObject* sub = PyList_New(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            PyList_Append(sub, Py_BuildValue(<span class="string">"&#123;s:i, s:i&#125;"</span>, <span class="string">"x"</span>, i, <span class="string">"y"</span>, <span class="number">100</span> - i));</span><br><span class="line">        &#125;</span><br><span class="line">        PyList_Append(result, sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用">调用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lib = cdll.LoadLibrary(<span class="string">'./extlist.so'</span>) <span class="comment"># class level loading lib</span></span><br><span class="line">lib.foo.restype = py_object</span><br><span class="line">b = lib.foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(b)) :</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(len(b[i])) :</span><br><span class="line">      d = b[i][j]</span><br><span class="line">      print(d[<span class="string">'x'</span>])</span><br></pre></td></tr></table></figure><p>很显然，第二种方式中，我已经封装了很复杂的结构了，如果用 c++ 来表示的话，将是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;point&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="遇到的问题">遇到的问题</h3><h3 id="python-c-混编时-segment">Python C 混编时 Segment</h3><p>这个问题困扰了我有一段时间，开始一直在纠结是代码哪错了，后来恍然大悟，Python 和 C 的堆栈是完全不同的，而当我在交互大量数据的时候，Python GC 可能会把 C 的内存当作未使用，直接给释放了(尤其是上述第二种方案)，这就是问题所在。(Python GC 中使用的代龄后续专门开文章来说明，欢迎关注公众号 cn_isnap)<br>这里的解决方案其实有很多，内存能撑过Python前两代的检查就可了，或者是纯C管理。在这里我推荐一种粗暴的解决方案：<br>对于任何调用Python对象或Python C API的C代码，确保你首先已经正确地获取和释放了GIL。 这可以用 PyGILState_Ensure() 和 PyGILState_Release() 来做到，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* Make sure we own the GIL */</span></span><br><span class="line">PyGILState_STATE state = PyGILState_Ensure();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use functions in the interpreter */</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* Restore previous GIL state and return */</span></span><br><span class="line">PyGILState_Release(state);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现C/C++与Python程序之间通信</title>
      <link href="/article/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0C-C-%E4%B8%8EPython%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%9F/"/>
      <url>/article/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0C-C-%E4%B8%8EPython%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>属于混合编程的问题。较全面的介绍一下，不仅限于题主提出的问题。<br>以下讨论中，Python指它的标准实现，即CPython（虽然不是很严格）</p><h2 id="本文结构">本文结构</h2><ul><li>C/C++ 调用 Python （基础篇）— 仅讨论Python官方提供的实现方式</li><li>Python 调用 C/C++ （基础篇）— 仅讨论Python官方提供的实现方式</li><li>C/C++ 调用 Python （高级篇）— 使用 Cython</li><li>Python 调用 C/C++ （高级篇）— 使用 SWIG</li></ul><p>练习本文中的例子，需要搭建Python扩展开发环境。具体细节见<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fzhuanlan.zhihu.com%2Fpython-dev%2F20150730" target="_blank" rel="noopener">搭建Python扩展开发环境 - 蛇之魅惑 - 知乎专栏</a></p><h2 id="cc-调用-python基础篇">C/C++ 调用 Python（基础篇）</h2><p>Python 本身就是一个C库。你所看到的可执行体python只不过是个stub。真正的python实体在动态链接库里实现，在Windows平台上，这个文件位于 %SystemRoot%\System32\python27.dll。</p><p>你也可以在自己的程序中调用Python，看起来非常容易：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//my_python.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Py_SetProgramName(argv[<span class="number">0</span>]);</span><br><span class="line">  Py_Initialize();</span><br><span class="line">  PyRun_SimpleString(<span class="string">"print 'Hello Python!'\n"</span>);</span><br><span class="line">  Py_Finalize();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Windows平台下，打开Visual Studio命令提示符，编译命令为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl my_python.c -IC:\Python27\include C:\Python27\libs\python27.lib</span><br></pre></td></tr></table></figure><p>在Linux下编译命令为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc my_python.c -o my_python -I/usr/include/python2<span class="number">.7</span>/ -lpython2<span class="number">.7</span></span><br></pre></td></tr></table></figure><p>在Mac OS X 下的编译命令同上</p><p>产生可执行文件后，直接运行，结果为输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Python!</span><br></pre></td></tr></table></figure><p>Python库函数PyRun_SimpleString可以执行字符串形式的Python代码。</p><p>虽然非常简单，但这段代码除了能用C语言动态生成一些Python代码之外，并没有什么用处。我们需要的是C语言的数据结构能够和Python交互。</p><p>下面举个例子，比如说，有一天我们用Python写了一个功能特别强大的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">great_function</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>接下来要把它包装成C语言的函数。我们期待的C语言的对应函数应该是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">great_function_from_python</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res; </span><br><span class="line">    <span class="comment">// some magic</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，复用Python模块得做‘import’，这里也不例外。所以我们把great_function放到一个module里，比如说，这个module名字叫 great_module.py</p><p>接下来就要用C来调用Python了，完整的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">great_function_from_python</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    PyObject *pModule,*pFunc;</span><br><span class="line">    PyObject *pArgs, *pValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* import */</span></span><br><span class="line">    pModule = PyImport_Import(PyString_FromString(<span class="string">"great_module"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* great_module.great_function */</span></span><br><span class="line">    pFunc = PyObject_GetAttrString(pModule, <span class="string">"great_function"</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* build args */</span></span><br><span class="line">    pArgs = PyTuple_New(<span class="number">1</span>);</span><br><span class="line">    PyTuple_SetItem(pArgs,<span class="number">0</span>, PyInt_FromLong(a));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call */</span></span><br><span class="line">    pValue = PyObject_CallObject(pFunc, pArgs);</span><br><span class="line"></span><br><span class="line">    res = PyInt_AsLong(pValue);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可以窥见Python内部运行的方式：</p><ul><li>所有Python元素，module、function、tuple、string等等，实际上都是PyObject。C语言里操纵它们，一律使用PyObject *。</li><li>Python的类型与C语言类型可以相互转换。Python类型XXX转换为C语言类型YYY要使用PyXXX_AsYYY函数；C类型YYY转换为Python类型XXX要使用PyXXX_FromYYY函数。</li><li>也可以创建Python类型的变量，使用PyXXX_New可以创建类型为XXX的变量。</li><li>若a是Tuple，则a[i] = b对应于 PyTuple_SetItem(a,i,b)，有理由相信还有一个函数PyTuple_GetItem完成取得某一项的值。</li><li>不仅Python语言很优雅，Python的库函数API也非常优雅。</li></ul><p>现在我们得到了一个C语言的函数了，可以写一个main测试它</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">great_function_from_python</span><span class="params">(<span class="keyword">int</span> a)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Py_Initialize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,great_function_from_python(<span class="number">2</span>));</span><br><span class="line">    Py_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译的方式就用本节开头使用的方法。</p><p>在Linux/Mac OSX运行此示例之前，可能先需要设置环境变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bash:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> PYTHONPATH=.:$PYTHONPATH</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">csh:</span><br><span class="line"></span><br><span class="line">    setenv PYTHONPATH .:$PYTHONPATH</span><br></pre></td></tr></table></figure><h2 id="python-调用-cc基础篇">Python 调用 C/C++（基础篇）</h2><p>这种做法称为Python扩展。<br>比如说，我们有一个功能强大的C函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">great_function</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>期望在Python里这样使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> great_module <span class="keyword">import</span> great_function </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>great_function(<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>考虑最简单的情况。我们把功能强大的函数放入C文件 great_module.c 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">great_function</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject * _great_function(PyObject *self, PyObject *args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">"i"</span>, &amp;_a))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    res = great_function(_a);</span><br><span class="line">    <span class="keyword">return</span> PyLong_FromLong(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyMethodDef GreateModuleMethods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"great_function"</span>,</span><br><span class="line">        _great_function,</span><br><span class="line">        METH_VARARGS,</span><br><span class="line">        <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">PyMODINIT_FUNC <span class="title">initgreat_module</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) Py_InitModule(<span class="string">"great_module"</span>, GreateModuleMethods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了功能强大的函数great_function外，这个文件中还有以下部分：</p><ul><li>包裹函数_great_function。它负责将Python的参数转化为C的参数（PyArg_ParseTuple），调用实际的great_function，并处理great_function的返回值，最终返回给Python环境。</li><li>导出表GreateModuleMethods。它负责告诉Python这个模块里有哪些函数可以被Python调用。导出表的名字可以随便起，每一项有4个参数：第一个参数是提供给Python环境的函数名称，第二个参数是_great_function，即包裹函数。第三个参数的含义是参数变长，第四个参数是一个说明性的字符串。导出表总是以{NULL, NULL, 0, NULL}结束。</li><li>导出函数initgreat_module。这个的名字不是任取的，是你的module名称添加前缀init。导出函数中将模块名称与导出表进行连接。</li></ul><p>在Windows下面，在Visual Studio命令提示符下编译这个文件的命令是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /LD great_module.c /o great_module.pyd -IC:\Python27\include C:\Python27\libs\python27.lib</span><br></pre></td></tr></table></figure><p>/LD 即生成动态链接库。编译成功后在当前目录可以得到 great_module.pyd（实际上是dll）。这个pyd可以在Python环境下直接当作module使用。</p><p>在Linux下面，则用gcc编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared great_module.c -o great_module.so -I/usr/include/python2.7/ -lpython2.7</span><br></pre></td></tr></table></figure><p>在当前目录下得到great_module.so，同理可以在Python中直接使用。</p><p><strong>本部分参考资料</strong></p><ul><li>《Python源码剖析-深度探索动态语言核心技术》是系统介绍CPython实现以及运行原理的优秀教程。</li><li>Python 官方文档的这一章详细介绍了C/C++与Python的双向互动<a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdocs.python.org%2F2%2Fextending%2Findex.html%2523extending-index" target="_blank" rel="noopener">Extending and Embedding the Python Interpreter</a></li><li>关于编译环境，本文所述方法仅为出示原理所用。规范的方式如下：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdocs.python.org%2F2%2Fextending%2Fbuilding.html%2523building" target="_blank" rel="noopener">3. Building C and C++ Extensions with distutils</a></li><li>作为字典使用的官方参考文档 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdocs.python.org%2F2%2Fc-api%2Findex.html%2523c-api-index" target="_blank" rel="noopener">Python/C API Reference Manual</a></li></ul><p>用以上的方法实现C/C++与Python的混合编程，需要对Python的内部实现有相当的了解。接下来介绍当前较为成熟的技术Cython和SWIG。</p><h2 id="cc-调用-python使用cython">C/C++ 调用 Python（使用Cython）</h2><p>在前面的小节中谈到，Python的数据类型和C的数据类型貌似是有某种“一一对应”的关系的，此外，由于Python（确切的说是CPython）本身是由C语言实现的，故Python数据类型之间的函数运算也必然与C语言有对应关系。那么，有没有可能“自动”的做替换，把Python代码直接变成C代码呢？答案是肯定的，这就是Cython主要解决的问题。</p><p>安装Cython非常简单。Python 2.7.9以上的版本已经自带easy_install：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install -U cython</span><br></pre></td></tr></table></figure><p>在Windows环境下依然需要Visual Studio，由于安装的过程需要编译Cython的源代码，故上述命令需要在Visual Studio命令提示符下完成。一会儿使用Cython的时候，也需要在Visual Studio命令提示符下进行操作，这一点和第一部分的要求是一样的。</p><p>继续以例子说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#great_module.pyx</span><br><span class="line">cdef public great_function(a,index):</span><br><span class="line">    <span class="keyword">return</span> a[index]</span><br></pre></td></tr></table></figure><p>这其中有非Python关键字cdef和public。这些关键字属于Cython。由于我们需要在C语言中使用“编译好的Python代码”，所以得让great_function从外面变得可见，方法就是以“public”修饰。而cdef类似于Python的def，只有使用cdef才可以使用Cython的关键字public。</p><p>这个函数中其他的部分与正常的Python代码是一样的。</p><p>接下来编译 great_module.pyx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cython great_module.pyx</span><br></pre></td></tr></table></figure><p>得到great_module.h和great_module.c。打开great_module.h可以找到这样一句声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__PYX_EXTERN_C DL_IMPORT(PyObject) *great_function(PyObject *, PyObject *)</span><br></pre></td></tr></table></figure><p>写一个main使用great_function。注意great_function并不规定a是何种类型，它的功能只是提取a的第index的成员而已，故使用great_function的时候，a可以传入Python String，也可以传入tuple之类的其他可迭代类型。仍然使用之前提到的类型转换函数PyXXX_FromYYY和PyXXX_AsYYY。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"great_module.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    PyObject *tuple;</span><br><span class="line">    Py_Initialize();</span><br><span class="line">    initgreat_module();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,PyString_AsString(</span><br><span class="line">                great_function(</span><br><span class="line">                    PyString_FromString(<span class="string">"hello"</span>),</span><br><span class="line">                    PyInt_FromLong(<span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            ));</span><br><span class="line">    tuple = Py_BuildValue(<span class="string">"(iis)"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">"three"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,PyInt_AsLong(</span><br><span class="line">                great_function(</span><br><span class="line">                    tuple,</span><br><span class="line">                    PyInt_FromLong(<span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">            ));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,PyString_AsString(</span><br><span class="line">                great_function(</span><br><span class="line">                    tuple,</span><br><span class="line">                    PyInt_FromLong(<span class="number">2</span>)</span><br><span class="line">                )</span><br><span class="line">            ));</span><br><span class="line">    Py_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译命令和第一部分相同：<br>在Windows下编译命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl main.c great_module.c -IC:\Python27\include C:\Python27\libs\python27.lib</span><br></pre></td></tr></table></figure><p>在Linux下编译命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c great_module.c -o main -I/usr/include/python2.7/ -lpython2.7</span><br></pre></td></tr></table></figure><p>这个例子中我们使用了Python的动态类型特性。如果你想指定类型，可以利用Cython的静态类型关键字。例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#great_module.pyx</span><br><span class="line">cdef public char great_function(const char * a,int index):</span><br><span class="line">    <span class="keyword">return</span> a[index]</span><br></pre></td></tr></table></figure><p>cython编译后得到的.h里，great_function的声明是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">PYX_EXTERN_C <span class="title">DL_IMPORT</span><span class="params">(<span class="keyword">char</span>)</span> <span class="title">great_function</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>很开心对不对！<br>这样的话，我们的main函数已经几乎看不到Python的痕迹了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"great_module.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Py_Initialize();</span><br><span class="line">    initgreat_module();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,great_function(<span class="string">"Hello"</span>,<span class="number">2</span>));</span><br><span class="line">    Py_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这一部分的最后我们给一个看似实用的应用（仅限于Windows）：<br>还是利用刚才的great_module.pyx，准备一个dllmain.c：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"great_module.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> __declspec(dllexport) <span class="keyword">int</span> __stdcall _great_function(<span class="keyword">const</span> <span class="keyword">char</span> * a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> great_function(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL,DWORD fdwReason,LPVOID lpReserved)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>( fdwReason ) &#123; </span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">            Py_Initialize();</span><br><span class="line">            initgreat_module();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">            Py_Finalize();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Visual Studio命令提示符下编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /LD dllmain.c great_module.c -IC:\Python27\include C:\Python27\libs\python27.lib</span><br></pre></td></tr></table></figure><p>会得到一个dllmain.dll。我们在Excel里面使用它，没错，传说中的<strong>Excel与Python混合编程</strong>：</p><p><noscript><img data-rawheight="797" data-rawwidth="1007" src="https://pic2.zhimg.com/50/2f45c9f2f8407d46f51f203efc2e8181\_hd.jpg" class="origin\_image zh-lightbox-thumb" width="1007" data-original="https://pic2.zhimg.com/2f45c9f2f8407d46f51f203efc2e8181_r.jpg"></noscript></p><p><img src="//upload-images.jianshu.io/upload_images/12778909-433d2ab7e4a6af72.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/720/format/webp" alt=""></p><p>参考资料：Cython的官方文档，质量非常高：<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2Fdocs.cython.org%2Findex.html" target="_blank" rel="noopener">Welcome to Cython’s Documentation</a></p><h2 id="python调用cc使用swig">Python调用C/C++（使用SWIG）</h2><p>用C/C++对脚本语言的功能扩展是非常常见的事情，Python也不例外。除了SWIG，市面上还有若干用于Python扩展的工具包，比较知名的还有Boost.Python、SIP等，此外，Cython由于可以直接集成C/C++代码，并方便的生成Python模块，故也可以完成扩展Python的任务。</p><p>答主在这里选用SWIG的一个重要原因是，它不仅可以用于Python，也可以用于其他语言。如今SWIG已经支持C/C++的好基友Java，主流脚本语言Python、Perl、Ruby、PHP、JavaScript、tcl、Lua，还有Go、C#，以及R。SWIG是基于配置的，也就是说，原则上一套配置改变不同的编译方法就能适用各种语言（当然，这是理想情况了……）</p><p>SWIG的安装方便，有Windows的预编译包，解压即用，绿色健康。主流Linux通常集成swig的包，也可以下载源代码自己编译，SWIG非常小巧，通常安装不会出什么问题。</p><p>用SWIG扩展Python，你需要有一个待扩展的C/C++库。这个库有可能是你自己写的，也有可能是某个项目提供的。这里举一个不浮夸的例子：希望在Python中用到SSE4指令集的CRC32指令。</p><p>首先打开指令集的文档：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fsoftware.intel.com%2Fen-us%2Fnode%2F514245" target="_blank" rel="noopener">https://software.intel.com/en-us/node/514245</a><br>可以看到有6个函数。分析6个函数的原型，其参数和返回值都是简单的整数。于是书写SWIG的配置文件（为了简化起见，未包含2个64位函数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File: mymodule.i */</span></span><br><span class="line">%<span class="keyword">module</span> mymodule</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nmmintrin.h"</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _mm_popcnt_u32(<span class="keyword">unsigned</span> <span class="keyword">int</span> v);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> _mm_crc32_u8 (<span class="keyword">unsigned</span> <span class="keyword">int</span> crc, <span class="keyword">unsigned</span> <span class="keyword">char</span> v);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> _mm_crc32_u16(<span class="keyword">unsigned</span> <span class="keyword">int</span> crc, <span class="keyword">unsigned</span> <span class="keyword">short</span> v);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> _mm_crc32_u32(<span class="keyword">unsigned</span> <span class="keyword">int</span> crc, <span class="keyword">unsigned</span> <span class="keyword">int</span> v);</span><br></pre></td></tr></table></figure><p>接下来使用SWIG将这个配置文件编译为所谓Python Module Wrapper</p><pre><code>swig -python mymodule.i</code></pre><p>得到一个 mymodule_wrap.c和一个mymodule.py。把它编译为Python扩展：</p><p>Windows：</p><pre><code>cl /LD mymodule_wrap.c /o _mymodule.pyd -IC:\Python27\include C:\Python27\libs\python27.lib</code></pre><p>Linux：</p><pre><code>gcc -fPIC -shared mymodule_wrap.c -o _mymodule.so -I/usr/include/python2.7/ -lpython2.7</code></pre><p>注意输出文件名前面要加一个下划线。<br>现在可以立即在Python下使用这个module了：</p><pre><code>&gt;&gt;&gt; import mymodule&gt;&gt;&gt; mymodule._mm_popcnt_u32(10)2</code></pre><p>回顾这个配置文件分为3个部分：</p><ul><li>定义module名称mymodule，通常，module名称要和文件名保持一致。</li><li>%{ %} 包裹的部分是C语言的代码，这段代码会原封不动的复制到mymodule_wrap.c</li><li>欲导出的函数签名列表。直接从头文件里复制过来即可。</li></ul><p>还记得本文第2节的那个great_function吗？有了SWIG，事情就会变得如此简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* great_module.i */</span></span><br><span class="line">%<span class="keyword">module</span> great_module</span><br><span class="line">%&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">great_function</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">great_function</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure><p>换句话说，SWIG自动完成了诸如Python类型转换、module初始化、导出代码表生成的诸多工作。</p><p>对于C++，SWIG也可以应对。例如以下代码有C++类的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//great_class.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GREAT_CLASS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREAT_CLASS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Great</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setWall</span> <span class="params">(<span class="keyword">int</span> _s)</span> </span>&#123;s = _s;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getWall</span> <span class="params">()</span> </span>&#123;<span class="keyword">return</span> s;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GREAT_CLASS</span></span></span><br></pre></td></tr></table></figure><p>对应的SWIG配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* great_class.i */</span><br><span class="line">%module great_class</span><br><span class="line">%&#123;</span><br><span class="line">#include &quot;great_class.h&quot;</span><br><span class="line">%&#125;</span><br><span class="line">%include &quot;great_class.h&quot;</span><br></pre></td></tr></table></figure><p>这里不再重新敲一遍class的定义了，直接使用SWIG的%include指令</p><p>SWIG编译时要加-c++这个选项，生成的扩展名为cxx</p><pre><code>swig -c++ -python great_class.i</code></pre><p>Windows下编译：</p><pre><code>cl /LD great_class_wrap.cxx /o _great_class.pyd -IC:\Python27\include C:\Python27\libs\python27.lib</code></pre><p>Linux，使用C++的编译器</p><pre><code>g++ -fPIC -shared great_class_wrap.cxx -o _great_class.so  -I/usr/include/python2.7/ -lpython2.7</code></pre><p>在Python交互模式下测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> great_class</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = great_class.Great()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.setWall(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.getWall()</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>也就是说C++的class会直接映射到Python class</p><p>SWIG非常强大，对于Python接口而言，简单类型，甚至指针，都无需人工干涉即可自动转换，而复杂类型，尤其是自定义类型，SWIG提供了typemap供转换。而一旦使用了typemap，配置文件将不再在各个语言当中通用。</p><p><strong>参考资料：</strong><br>SWIG的官方文档，质量比较高。<a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2Fwww.swig.org%2FDoc3.0%2FContents.html%2523Contents" target="_blank" rel="noopener">SWIG Users Manual</a><br>有个对应的中文版官网，很多年没有更新了。</p><h2 id="写在最后">写在最后</h2><p>由于CPython自身的结构设计合理，使得Python的C/C++扩展非常容易。如果打算快速完成任务，Cython（C/C++调用Python）和SWIG（Python调用C/C++）是很不错的选择。但是，一旦涉及到比较复杂的转换任务，无论是继续使用Cython还是SWIG，仍然需要学习Python源代码。</p><p>本文使用的开发环境：<br>Python 2.7.10<br>Cython 0.22<br>SWIG 3.0.6<br>Windows 10 x64 RTM<br>CentOS 7.1 AMD 64<br>Mac OSX 10.10.4<br>文中所述原理与具体环境适用性强。<br>文章所述代码均用于演示，缺乏必备的异常检查## 目标</p><p>去除 iconfinder 上 icon 的水印</p><h2 id="原理">原理</h2><p>利用水印像素点和原图像素点颜色合并的原理，如果拥有加过水印的图片和水印图片，就可以反向推出原图原像素点的颜色；前提是你得拥有他的水印图片</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang方法</title>
      <link href="/article/golang%E6%96%B9%E6%B3%95/"/>
      <url>/article/golang%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="golang中的方法">Golang中的方法</h1><p>Golang允许用户定义类型，比如常见的结构体就属于用户定义的结构类型。方法可以给用户定义的类型添加新的行为，方法其实是一种特殊的函数，与函数的区别在于声明的时候在关键字func和函数名之间增加了一个参数。为了更好的理解方法的概念，我们先来看一段代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个user类型</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用值接收者实现一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Sending User Email To %s&lt;%s&gt;\n"</span>, u.name, u.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针接收者实现一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">changeEmail</span><span class="params">(email <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    u.email = email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// user类型的值可以用来调用使用值接收者声明的方法</span></span><br><span class="line">    tracy := user&#123;<span class="string">"Tracy"</span>, <span class="string">"tracy.qq.com"</span>&#125;</span><br><span class="line">    tracy.notify()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向user类型值的指针也可以调用使用值接收者声明的方法</span></span><br><span class="line">    kobe := &amp;user&#123;<span class="string">"Kobe"</span>, <span class="string">"kobe.qq.com"</span>&#125;</span><br><span class="line">    kobe.notify()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// user类型的值可以用来调用使用指针接收者声明的方法</span></span><br><span class="line">    tracy.changeEmail(<span class="string">"guoguo.qq.com"</span>)</span><br><span class="line">    tracy.notify()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向user类型值的指针也可以调用使用指针接收者声明的方法</span></span><br><span class="line">    kobe.changeEmail(<span class="string">"xiaobudian.qq.com"</span>)</span><br><span class="line">    kobe.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出结果如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sending User Email To Tracy&lt;tracy.qq.com&gt;</span><br><span class="line">Sending User Email To Kobe&lt;kobe.qq.com&gt;</span><br><span class="line">Sending User Email To Tracy&lt;guoguo.qq.com&gt;</span><br><span class="line">Sending User Email To Kobe&lt;xiaobudian.qq.com&gt;</span><br></pre></td></tr></table></figure><h2 id="值接收者和指针接收者">值接收者和指针接收者</h2><p>除了两者声明方法时候形式不同外，本质的区别在哪里呢？下面我们通过分析main函数中四段调用来理解两者的含义：</p><h3 id="1-类型的值调用使用值接收者声明的方法">1、类型的值调用使用值接收者声明的方法</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user类型的值可以用来调用使用值接收者声明的方法</span></span><br><span class="line">    tracy := user&#123;<span class="string">"Tracy"</span>, <span class="string">"tracy.qq.com"</span>&#125;</span><br><span class="line">    tracy.notify()</span><br></pre></td></tr></table></figure><p>这里我们声明并初始化了一个user类型的变量“tracy”，然后这个变量使用了值接收者声明的方法，即使用tracy的值作为接收者进行调用，此时方法notify()会接收到tracy的一个副本，这就是值接收者。</p><h3 id="2-类型的指针调用使用值接收者声明的方法">2、类型的指针调用使用值接收者声明的方法</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向user类型值的指针也可以调用使用值接收者声明的方法</span></span><br><span class="line">    kobe := &amp;user&#123;<span class="string">"Kobe"</span>, <span class="string">"kobe.qq.com"</span>&#125;</span><br><span class="line">    kobe.notify()</span><br></pre></td></tr></table></figure><p>在这里我们声明了一个名为kobe的指针变量，并给user结构初始化。接着，我们用这个指针变量调用了notify方法，为什么指针接收者可以调用使用值接收者声明的方法呢？其实，为了支持这种调用，Golang调整了指针的值，我们可以认为上面指针变量调用notify方法是执行了下面这种操作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*kobe).notify()</span><br></pre></td></tr></table></figure><p>我们发现，这不是指针解引用吗？没错，是的，指针变量被解引用为值时，这不就符合了值接收者的要求了吗。所以，也就是说指针变量调用使用值接收者声明的方法是合法的，并且其实就是使用类型的值来调用使用值接收者声明的方法。当然，这是Golang编译器背后做的事情。</p><blockquote><p>需要注意的是，此时notify()操作的仍然是值的一个副本，只不过这次操作的副本是kobe指针指向的值的一个副本！</p></blockquote><h3 id="3-类型的值调用使用指针接收者声明的方法">3、类型的值调用使用指针接收者声明的方法</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user类型的值可以用来调用使用指针接收者声明的方法</span></span><br><span class="line">    tracy.changeEmail(<span class="string">"guoguo.qq.com"</span>)</span><br><span class="line">    tracy.notify()</span><br></pre></td></tr></table></figure><p>既然类型的指针变量可以调用使用值接收者声明的方法，那么类型的值可以调用使用指针接收者声明的方法吗？答案是可以的。Golang编译器同样为我们调整了值，即上面的tracy.notify()实际上是执行了如下操作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&amp;tracy).notify()</span><br></pre></td></tr></table></figure><p>这样就符合了指针接收者的要求了。</p><h3 id="4-类型的指针调用使用指针接收者声明的方法">4、类型的指针调用使用指针接收者声明的方法</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向user类型值的指针也可以调用使用指针接收者声明的方法</span></span><br><span class="line">    kobe.changeEmail(<span class="string">"xiaobudian.qq.com"</span>)</span><br><span class="line">    kobe.notify()</span><br></pre></td></tr></table></figure><p>从代码中我们看到，指向user类型的指针调用了使用指针接收者声明的方法，这里操作的是实际值，并不是副本，并且在调用的方法里对值的修改对于调用者而言是可见的。也就是说，kobe.notify()调用完成之后，<a href="http://xn--emailxiaobudian-n53x05shu1dqi0bsd1aod1k.qq.com" target="_blank" rel="noopener">email字段被修改为xiaobudian.qq.com</a>，此时在main函数中如果打印kobe.email，那么这个结果应该是被修改后的结果。</p><p>讲到这里，大家应该懂了值接收者和指针接收者的区别了吧？</p><h2 id="值接收者和指针接收者区别">值接收者和指针接收者区别</h2><p>最重要的一点是值接收者使用值的副本来调用方法，而指针接受者使用实际值来调用方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Golang监控你的程序</title>
      <link href="/article/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Golang%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>/article/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Golang%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前记">前记</h2><p>你是如何使用 Golang 日志监控你的应用程序的呢？Golang 没有异常，只有错误。因此你的第一印象可能就是开发 Golang 日志策略并不是一件简单的事情。不支持异常事实上并不是什么问题，异常在很多编程语言中已经失去了其异常性：它们过于被滥用以至于它们的作用都被忽视了。<br>在进一步深入之前，我们首先会介绍 Golang 日志的基础，并讨论 Golang 日志标准、元数据意义、以及最小化 Golang 日志对性能的影响。通过日志，你可以追踪用户在你应用中的活动，快速识别你项目中失效的组件，并监控总体性能以及用户体验。</p><h2 id="golang日志基础">Golang日志基础</h2><h3 id="使用golang中log包">使用Golang中“log”包</h3><p>Golang 给你提供了一个称为 “log” 的原生日志库。它的日志器完美适用于追踪简单的活动，例如通过使用可用的选项在错误信息之前添加一个时间戳。</p><p>下面是一个 Golang 中如何记录错误日志的简单例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span>  </span><br><span class="line">    <span class="string">"errors"</span>   </span><br><span class="line">    <span class="string">"fmt"</span>    </span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 除法函数，除以 0 的时候会返回错误 */</span></span><br><span class="line">    ret,err = div(a, b)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; </span><br><span class="line">        log.Fatal(err)   </span><br><span class="line">    &#125;    </span><br><span class="line">    fmt.Println(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你尝试除以 0，你就会得到类似下面的结果：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>/<span class="number">08</span>/<span class="number">01</span> <span class="number">13</span>:<span class="number">38</span>:<span class="number">17</span> You cannot divide by <span class="number">0.</span></span><br><span class="line">exit status <span class="number">1</span></span><br></pre></td></tr></table></figure><p>为了快速测试一个 Golang 函数，你可以使用go playground。</p><p>为了确保你的日志总是能轻易访问，我们建议你把它们写到一个文件：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 按照所需读写权限创建文件</span></span><br><span class="line">    f, err := os.OpenFile(<span class="string">"filename"</span>, os.O_WRONLY|os.O_CREATE|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成后延迟关闭，而不是习惯!</span></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="comment">//设置日志输出到 f</span></span><br><span class="line">    log.SetOutput(f)</span><br><span class="line">    <span class="comment">//测试用例</span></span><br><span class="line">    log.Println(<span class="string">"check to make sure it works"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以找到 Golang 日志的完整指南，以及 “log”库内可用函数的完整列表。<br>现在你就可以记录它们的错误以及根本原因啦。<br>另外，日志也可以帮你将活动流拼接在一起，查找需要修复的错误上下文，或者调查在你的系统中单个请求如何影响其它应用层和 API。<br>为了获得更好的日志效果，你首先需要在你的项目中使用尽可能多的上下文丰富你的 Golang 日志，并标准化你使用的格式。这就是 Golang 原生库能达到的极限。使用最广泛的库是glog和logrus。必须承认还有很多好的库可以使用。如果你已经在使用支持 JSON 格式的库，你就不需要再换其它库了，后面我们会解释。</p><h2 id="为你golang日志统一格式">为你Golang日志统一格式</h2><h3 id="json格式的结构优势">JSON格式的结构优势</h3><p>在一个项目或者多个微服务中结构化你的 Golang 日志可能是最困难的事情，但一旦完成就很轻松了。结构化你的日志能使机器可读（参考我们收集日志的最佳实践博文）。灵活性和层级是 JSON 格式的核心，因此信息能够轻易被人类和机器解析以及处理。<br>下面是一个使用Logrus/Logmatic.io如何用 JSON 格式记录日志的例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    log <span class="string">"github.com/Sirupsen/logrus"</span></span><br><span class="line">    <span class="string">"github.com/logmatic/logmatic-go"</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用 JSONFormatter</span></span><br><span class="line">    log.SetFormatter(&amp;logmatic.JSONFormatter&#123;&#125;)</span><br><span class="line">    <span class="comment">// 使用 logrus 像往常那样记录事件</span></span><br><span class="line">    log.WithFields(log.Fields&#123;<span class="string">"string"</span>: <span class="string">"foo"</span>, <span class="string">"int"</span>: <span class="number">1</span>, <span class="string">"float"</span>: <span class="number">1.1</span>&#125;).Info(<span class="string">"My first ssl event from golang"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会输出结果：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;   </span><br><span class="line">    <span class="string">"date"</span>:<span class="string">"2016-05-09T10:56:00+02:00"</span>,</span><br><span class="line">    <span class="string">"float"</span>:<span class="number">1.1</span>,</span><br><span class="line">    <span class="string">"int"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">"level"</span>:<span class="string">"info"</span>,</span><br><span class="line">    <span class="string">"message"</span>:<span class="string">"My first ssl event from golang"</span>,</span><br><span class="line">    <span class="string">"String"</span>:<span class="string">"foo"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准化golang日志">标准化Golang日志</h3><p>同一个错误出现在你代码的不同部分，却以不同形式被记录下来是一件可耻的事情。下面是一个由于一个变量错误导致无法确定 web 页面加载状态的例子。一个开发者日志格式是：</p><pre><code>message: 'unknown error: cannot determine loading status from unknown error: missing or invalid arg value client'</code></pre><p>另一个人的格式却是：</p><pre><code>unknown error: cannot determine loading status - invalid client</code></pre><p>强制日志标准化的一个好的解决办法是在你的代码和日志库之间创建一个接口。这个标准化接口会包括所有你想添加到你日志中的可能行为的预定义日志消息。这么做可以防止出现不符合你想要的标准格式的自定义日志信息。这么做也便于日志调查。<br><img src="http://i1.fuimg.com/699606/2efd60ed21e0ba60.png" alt="流程图"></p><p>由于日志格式都被统一处理，使它们保持更新也变得更加简单。如果出现了一种新的错误类型，它只需要被添加到一个接口，这样每个组员都会使用完全相同的信息。<br>最常使用的简单例子就是在 Golang 日志信息前面添加日志器名称和 id。你的代码然后就会发送 “事件” 到你的标准化接口，它会继续讲它们转化为 Golang 日志消息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要部分，我们会在这里定义所有消息。</span></span><br><span class="line"><span class="comment">// Event 结构体很简单。为了当所有信息都被记录时能检索它们，</span></span><br><span class="line"><span class="comment">// 我们维护了一个 Id</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    invalidArgMessage = Event&#123;<span class="number">1</span>, <span class="string">"Invalid arg: %s"</span>&#125;</span><br><span class="line">    invalidArgValueMessage = Event&#123;<span class="number">2</span>, <span class="string">"Invalid arg value: %s =&gt; %v"</span>&#125;</span><br><span class="line">    missingArgMessage = Event&#123;<span class="number">3</span>, <span class="string">"Missing arg: %s"</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在我们应用程序中可以使用的所有日志事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span><span class="title">InvalidArg</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    l.entry.Errorf(invalidArgMessage.toString(), name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span><span class="title">InvalidArgValue</span><span class="params">(name <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    l.entry.WithField(<span class="string">"arg."</span> + name, </span><br><span class="line">    value).Errorf(invalidArgValueMessage.toString(), name, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span><span class="title">MissingArg</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    l.entry.Errorf(missingArgMessage.toString(), name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此如果我们使用前面例子中无效的参数值，我们就会得到相似的日志信息：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time=<span class="string">"2017-02-24T23:12:31+01:00"</span> </span><br><span class="line">level=error </span><br><span class="line">msg=<span class="string">"LoadPageLogger00003 - Missing arg: client - cannot determine loading status"</span> </span><br><span class="line">arg.client=&lt;<span class="literal">nil</span>&gt; logger.name=LoadPageLogger</span><br></pre></td></tr></table></figure><p>Json格式如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"arg.client"</span>:null,<span class="string">"level"</span>:<span class="string">"error"</span>,<span class="string">"logger.name"</span>:<span class="string">"LoadPageLogger"</span>,<span class="string">"msg"</span>:<span class="string">"LoadPageLogger00003 - Missing arg: client - cannot determine loading status"</span>, <span class="string">"time"</span>:<span class="string">"2017-02-24T23:14:28+01:00"</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="golang日志上下文的力量">Golang日志上下文的力量</h3><p>现在 Golang 日志已经按照特定结构和标准格式记录，时间会决定需要添加哪些上下文以及相关信息。为了能从你的日志中抽取信息，例如追踪一个用户活动或者工作流，上下文和元数据的顺序非常重要。</p><p>例如在 logrus 库中可以按照下面这样使用 JSON 格式添加hostname、appname和session 参数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于元数据，通常做法是通过复用来重用日志语句中的字段。</span></span><br><span class="line">contextualizedLog := log.WithFields(log.Fields&#123;</span><br><span class="line">    <span class="string">"hostname"</span>: <span class="string">"staging-1"</span>,</span><br><span class="line">    <span class="string">"appname"</span>: <span class="string">"foo-app"</span>,</span><br><span class="line">    <span class="string">"session"</span>: <span class="string">"1ce3f6v"</span></span><br><span class="line">&#125;)</span><br><span class="line">contextualizedLog.Info(<span class="string">"Simple event with global metadata"</span>)</span><br></pre></td></tr></table></figure><p>元数据可以视为 javascript 片段。为了更好地说明它们有多么重要，让我们看看几个 Golang 微服务中元数据的使用。你会清楚地看到是怎么在你的应用程序中跟踪用户的。这是因为你不仅需要知道一个错误发生了，还要知道是哪个实例以及什么模式导致了错误。假设我们有两个按顺序调用的微服务。上下文信息保存在头部（header）中传输：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloMicroService1</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line">    <span class="comment">// 该服务负责接收所有到来的用户请求</span></span><br><span class="line">    <span class="comment">// 我们会检查是否是一个新的会话还是已有会话的另一次调用</span></span><br><span class="line">    session := r.Header.Get(<span class="string">"x-session"</span>)</span><br><span class="line">    <span class="keyword">if</span> ( session == <span class="string">""</span>) &#123;</span><br><span class="line">        session = generateSessionId()</span><br><span class="line">        <span class="comment">// 为新会话记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 每个请求的 Track Id 都是唯一的，因此我们会为每个会话生成一个</span></span><br><span class="line">   track := generateTrackId()</span><br><span class="line">   <span class="comment">// 调用你的第二个微服务，添加 session/track</span></span><br><span class="line">   reqService2, _ := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://localhost:8082/"</span>, <span class="literal">nil</span>)</span><br><span class="line">   reqService2.Header.Add(<span class="string">"x-session"</span>, session)</span><br><span class="line">   reqService2.Header.Add(<span class="string">"x-track"</span>, track)</span><br><span class="line">   resService2, _ := client.Do(reqService2)</span><br></pre></td></tr></table></figure><p>当调用第二个服务时：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">helloMicroService2</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">     <span class="comment">// 类似之前的微服务，我们检查会话并生成新的 track</span></span><br><span class="line">     session := r.Header.Get(<span class="string">"x-session"</span>)</span><br><span class="line">     track := generateTrackId()</span><br><span class="line">     <span class="comment">// 这一次，我们检查请求中是否已经设置了一个 track id，</span></span><br><span class="line">     <span class="comment">// 如果是，它变为父 track</span></span><br><span class="line">     parent := r.Header.Get(<span class="string">"x-track"</span>)</span><br><span class="line">     <span class="keyword">if</span> (session == <span class="string">""</span>) &#123;</span><br><span class="line">         w.Header().Set(<span class="string">"x-parent"</span>, parent)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 为响应添加 meta 信息</span></span><br><span class="line">     w.Header().Set(<span class="string">"x-session"</span>, session)</span><br><span class="line">     w.Header().Set(<span class="string">"x-track"</span>, track)</span><br><span class="line">     <span class="keyword">if</span> (parent == <span class="string">""</span>) &#123;</span><br><span class="line">         w.Header().Set(<span class="string">"x-parent"</span>, track)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 填充响应</span></span><br><span class="line">     w.WriteHeader(http.StatusOK)</span><br><span class="line">     io.WriteString(w, fmt.Sprintf(aResponseMessage, <span class="number">2</span>, session, track, parent))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在第二个微服务中已经有和初始查询相关的上下文和信息，一个 JSON 格式的日志消息看起来类似如下。</p><p>在第一个微服务：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"appname"</span>:<span class="string">"go-logging"</span>,<span class="string">"level"</span>:<span class="string">"debug"</span>,<span class="string">"msg"</span>:<span class="string">"hello from ms 1"</span>,<span class="string">"session"</span>:<span class="string">"eUBrVfdw"</span>,<span class="string">"time"</span>:<span class="string">"2017-03-02T15:29:26+01:00"</span>,<span class="string">"track"</span>:<span class="string">"UzWHRihF"</span>&#125;</span><br></pre></td></tr></table></figure><p>在第二个微服务：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"appname"</span>:<span class="string">"go-logging"</span>,<span class="string">"level"</span>:<span class="string">"debug"</span>,<span class="string">"msg"</span>:<span class="string">"hello from ms 2"</span>,<span class="string">"parent"</span>:<span class="string">"UzWHRihF"</span>,<span class="string">"session"</span>:<span class="string">"eUBrVfdw"</span>,<span class="string">"time"</span>:<span class="string">"2017-03-02T15:29:26+01:00"</span>,<span class="string">"track"</span>:<span class="string">"DPRHBMuE"</span>&#125;</span><br></pre></td></tr></table></figure><p>如果在第二个微服务中出现了错误，多亏了 Golang 日志中保存的上下文信息，现在我们就可以确定它是怎样被调用的以及什么模式导致了这个错误。</p><h2 id="golang日志对性能的影响">Golang日志对性能的影响</h2><h3 id="不要在goroutine中使用日志">不要在Goroutine中使用日志</h3><p>在每个 goroutine 中创建一个新的日志器看起来很诱人。但最好别这么做。Goroutine 是一个轻量级线程管理器，它用于完成一个 “简单的” 任务。因此它不应该负责日志。它可能导致并发问题，因为在每个 goroutine 中使用</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.New()</span><br></pre></td></tr></table></figure><p>会重复接口，所有日志器会并发尝试访问同一个 io.Writer。为了限制对性能的影响以及避免并发调用 io.Writer，库通常使用一个特定的 goroutine 用于日志输出。</p><h3 id="使用异步库">使用异步库</h3><p>尽管有很多可用的 Golang 日志库，要注意它们中的大部分都是同步的（事实上是伪异步）。原因很可能是到现在为止它们中没有一个会由于日志严重影响性能。<br>但正如 Kjell Hedström 在他的实验中展示的，使用多个线程创建成千上万日志，即便是在最坏情况下，异步 Golang 日志也会有 40% 的性能提升。因此日志是有开销的，也会对你的应用程序性能产生影响。如果你并不需要处理大量的日志，使用伪异步 Golang 日志库可能就足够了。但如果你需要处理大量的日志，或者很关注性能，Kjell Hedström 的异步解决方案就很有趣（尽管事实上你可能需要进一步开发，因为它只包括了最小的功能需求）。</p><h3 id="使用严重等级管理golang日志">使用严重等级管理Golang日志</h3><p>一些日志库允许你启用或停用特定的日志器，这可能会派上用场。例如在生产环境中你可能不需要一些特定等级的日志。下面是一个如何在 glog 库中停用日志器的例子，其中日志器被定义为布尔值：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Log <span class="keyword">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Log)</span> <span class="title">Println</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Println(args...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> debug Log = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">    debug.Println(<span class="string">"DEBUGGING"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你就可以在配置文件中定义这些布尔参数来启用或者停用日志器。<br>没有一个好的 Golang 日志策略，Golang 日志可能开销很大。开发人员应该抵制记录几乎所有事情的诱惑 - 尽管它非常有趣！如果日志的目的是为了获取尽可能多的信息，为了避免包含无用元素的日志的白噪音，必须正确使用日志。</p><h2 id="希望你享受你的-golang-日志之旅">希望你享受你的 Golang 日志之旅</h2><p>在你项目一开始就考虑你的 Golang 日志策略非常重要。如果在你代码的任意地方都可以获得所有的上下文，追踪用户就会变得很简单。从不同服务中阅读没有标准化的日志是已经很痛苦的事情。一开始就计划在多个微服务中扩展相同用户或请求 id，后面就会允许你比较容易地过滤信息并在你的系统中跟踪活动。<br>你是在构架一个很大的 Golang 项目还是几个微服务也会影响你的日志策略。一个大项目的主要组件应该有按照它们功能命名的特定 Golang 日志器。这使你可以立即判断出日志来自你的哪一部分代码。然而对于微服务或者小的 Golang 项目，只有较少的核心组件需要它们自己的日志器。但在每种情形中，日志器的数目都应该保持低于核心功能的数目。<br>你现在已经可以使用 Golang 日志量化决定你的性能或者用户满意度啦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
